https://leetcode.cn/problems/house-robber-iii/description/


以下是“打家劫舍 III”问题的两种核心解法：**递归 + 双 Map 缓存** 和 **动态规划（后序遍历）**，包含完整思路、代码实现和详细解释，方便对比学习：


### 一、解法一：递归 + 双 Map 缓存
#### 核心思路
利用两个 `Map` 分别缓存“偷当前节点”和“不偷当前节点”的最大金额，避免重复递归计算，逻辑直观易理解：
- `stealCache`：key = 节点，value = 偷该节点时，以其为根的子树能偷的最大金额。
- `notStealCache`：key = 节点，value = 不偷该节点时，以其为根的子树能偷的最大金额。

递归决策逻辑：
1. 若偷当前节点 → 左右子节点必须不偷，金额 = 当前节点值 + 左子节点不偷的金额 + 右子节点不偷的金额。
2. 若不偷当前节点 → 左右子节点可偷或不偷（取最大值），金额 = max(左子偷/不偷) + max(右子偷/不偷)。

#### 代码实现
```java
import java.util.HashMap;
import java.util.Map;

// 二叉树节点定义（题目默认提供，此处为完整示例）
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    // 缓存“偷当前节点”的最大金额
    private Map<TreeNode, Integer> stealCache = new HashMap<>();
    // 缓存“不偷当前节点”的最大金额
    private Map<TreeNode, Integer> notStealCache = new HashMap<>();

    public int rob(TreeNode root) {
        // 最终结果：根节点“偷”和“不偷”的最大值
        return Math.max(dfs(root, true), dfs(root, false));
    }

    // 递归函数：计算节点 node 在 steal（是否偷）状态下的最大金额
    private int dfs(TreeNode node, boolean steal) {
        // 终止条件：空节点无金额可偷
        if (node == null) {
            return 0;
        }

        // 缓存命中：直接返回结果，避免重复计算
        if (steal) {
            if (stealCache.containsKey(node)) {
                return stealCache.get(node);
            }
        } else {
            if (notStealCache.containsKey(node)) {
                return notStealCache.get(node);
            }
        }

        int maxMoney;
        if (steal) {
            // 偷当前节点：左右子节点必须不偷
            maxMoney = node.val 
                      + dfs(node.left, false)  // 左子不偷
                      + dfs(node.right, false); // 右子不偷
            stealCache.put(node, maxMoney); // 存入缓存
        } else {
            // 不偷当前节点：左右子节点取“偷/不偷”的最大值
            int leftMax = Math.max(dfs(node.left, true), dfs(node.left, false));
            int rightMax = Math.max(dfs(node.right, true), dfs(node.right, false));
            maxMoney = leftMax + rightMax;
            notStealCache.put(node, maxMoney); // 存入缓存
        }

        return maxMoney;
    }
}
```


### 二、解法二：动态规划（后序遍历）
#### 核心思路
通过后序遍历二叉树（先处理左右子树，再处理当前节点），为每个节点维护一个长度为 2 的 `dp` 数组，直接存储两种状态的最大金额，无需额外缓存：
- `dp[0]`：不偷当前节点时，以其为根的子树能偷的最大金额。
- `dp[1]`：偷当前节点时，以其为根的子树能偷的最大金额。

状态转移方程：
1. 不偷当前节点 → `dp[0] = max(左子dp[0], 左子dp[1]) + max(右子dp[0], 右子dp[1])`（左右子树自由选择）。
2. 偷当前节点 → `dp[1] = 当前节点值 + 左子dp[0] + 右子dp[0]`（左右子树必须不偷）。

#### 代码实现
```java
class Solution {
    public int rob(TreeNode root) {
        int[] rootDP = postOrderDp(root);
        // 根节点“偷”和“不偷”的最大值即为结果
        return Math.max(rootDP[0], rootDP[1]);
    }

    // 后序遍历：返回节点 node 的 dp 数组 [不偷, 偷]
    private int[] postOrderDp(TreeNode node) {
        // 终止条件：空节点的 dp 数组为 [0, 0]
        if (node == null) {
            return new int[]{0, 0};
        }

        // 递归处理左右子树（后序遍历核心：先子后父）
        int[] leftDP = postOrderDp(node.left);
        int[] rightDP = postOrderDp(node.right);

        // 计算当前节点的 dp 数组
        int[] currDP = new int[2];
        // currDP[0]：不偷当前节点
        currDP[0] = Math.max(leftDP[0], leftDP[1]) + Math.max(rightDP[0], rightDP[1]);
        // currDP[1]：偷当前节点
        currDP[1] = node.val + leftDP[0] + rightDP[0];

        return currDP;
    }
}
```


### 三、两种解法对比与核心说明
| 维度                | 递归 + 双 Map 缓存                | 动态规划（后序遍历）              |
|---------------------|-----------------------------------|-----------------------------------|
| **核心思想**        | 缓存两种状态的结果，避免重复递归  | 后序遍历推导状态，用数组存储当前节点的两种状态 |
| **空间复杂度**      | \(O(n)\)（缓存 + 递归栈）         | \(O(n)\)（仅递归栈，无额外缓存）  |
| **时间复杂度**      | \(O(n)\)（每个节点仅计算 2 次）   | \(O(n)\)（每个节点仅遍历 1 次）   |
| **代码简洁度**      | 稍繁琐（需维护两个 Map）          | 更简洁（无缓存，仅状态推导）      |
| **逻辑直观性**      | 高（直接对应“偷/不偷”的决策）     | 中等（需理解后序遍历与状态转移）  |
| **工程推荐度**      | 中等（适合快速理解）              | 高（效率更优，代码更简洁）        |

#### 关键补充：
1. 两种解法本质一致：都是通过“枚举每个节点的两种状态”求解，区别仅在于“状态存储方式”（Map 缓存 vs DP 数组）。
2. 动态规划更优：无需额外维护 Map 缓存，空间开销略小，且代码更简洁，是工程中的首选方案。
3. 双 Map 缓存更易理解：直接映射“状态-结果”，适合刚接触该问题时入门，帮助理解核心决策逻辑。


### 四、测试用例验证
以示例二叉树 `[3,2,3,null,3,null,1]` 为例：
```
    3
   / \
  2   3
   \   \
    3   1
```
- 双 Map 解法：`max(dfs(root, true)=3+3+1=7, dfs(root, false)=max(2/3)+max(3/1)=3+3=6)` → 结果 7。
- 动态规划解法：根节点 DP 数组 `[6,7]` → 结果 7。

两种解法均能正确输出最大金额 7，验证有效。
