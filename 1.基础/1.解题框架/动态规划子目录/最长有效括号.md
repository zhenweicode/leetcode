
https://leetcode.cn/problems/longest-valid-parentheses/description/?envType=study-plan-v2&envId=top-100-liked

# 最长有效括号（Longest Valid Parentheses）- Java 小白友好版（多解法+扩展题）
核心结论：最长有效括号是找字符串中**连续且合法**的括号子串长度，Java 有 3 种经典解法（动态规划、栈、双指针），其中双指针空间最优（O(1)），栈最直观，动态规划适合理解子问题逻辑。


## 先搞懂题目（小白必看）
- 输入：只含 `'('` 和 `')'` 的字符串（比如 `"(()"`、`")()())"`）
- 输出：最长「有效括号子串」的长度（有效 = 括号成对且闭合，子串 = 字符连续）
- 示例：
  - 输入 `"(()"`：有效子串是 `"()"`（位置 1-2），长度 2
  - 输入 `")()())"`：有效子串是 `"()()"`（2-5）或 `"(())"`（1-4），长度 4
  - 输入 `""`：没有有效子串，长度 0

关键提醒：别和「子序列」搞混！子序列可以不连续（比如 `"(()"` 的子序列 `"(())"` 不算，因为原字符串中两个 `'('` 中间夹了 `'('`，无法连续组成 `"(())"`）。


## 解法一：动态规划（DP）- 小白能懂的「递推思路」
### 核心思想（用历史结果推当前结果）
动态规划的本质是「记住之前的答案，帮现在解题」。这里我们定义一个数组 `dp`：
- `dp[i]` 表示：以字符串第 `i` 个字符（从 0 开始数）结尾的「最长有效括号子串长度」
- 比如字符串 `"()()"`，`dp[1] = 2`（以第 1 个字符 `')'` 结尾的有效子串是 `"()"`），`dp[3] = 4`（以第 3 个字符 `')'` 结尾的有效子串是 `"()()"`）

为什么这么定义？因为有效括号子串一定以 `')'` 结尾（以 `'('` 结尾的肯定无效），所以我们只需要关注 `')'` 的位置。

### 分情况讨论（小白逐句看）
假设当前遍历到第 `i` 个字符（`s[i]`），只看 `s[i] = ')'` 的情况（`s[i] = '('` 时 `dp[i] = 0`，直接跳过）：
1. 情况 1：`s[i-1] = '('`（比如 `"...()"`）
   - 当前 `s[i]` 和前一个字符刚好组成 `"()"`，有效长度至少是 2
   - 如果 `i >= 2`（前面还有字符），还要加上 `dp[i-2]`（前两个字符结尾的有效长度）
   - 例子：`"()()"` 中 `i=3`（第二个 `')'`），`s[2] = '('`，`dp[3] = dp[1] + 2 = 2 + 2 = 4`
2. 情况 2：`s[i-1] = ')'`（比如 `"...))"`）
   - 此时要找 `s[i]` 对应的 `'('`：前一个 `')'` 已经组成了 `dp[i-1]` 长度的有效子串，所以对应的 `'('` 应该在 `i - dp[i-1] - 1` 位置
   - 如果 `s[i - dp[i-1] - 1] = '('`（找到匹配的 `'('`），则 `dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]`（中间有效长度 + 当前匹配的 2 + 左侧更早的有效长度）
   - 例子：`"(()))()"` 中 `i=4`（第三个 `')'`），`dp[3] = 2`（`"(())"` 的长度），`i - dp[i-1] -1 = 4-2-1=1`，`s[1] = '('`，所以 `dp[4] = 2 + 2 + dp[0] = 4 + 0 = 4`

### 边界处理（避免数组越界）
- 字符串长度 < 2 时，直接返回 0（比如 `"("` 或 `")"` 都无效）
- `dp[0] = 0`（单个字符不可能有效）

### 小白能复制的代码
```java
public int longestValidParentheses(String s) {
    int n = s.length();
    if (n < 2) return 0; // 长度不够，直接返回0
    int[] dp = new int[n]; // dp数组：记录以每个位置结尾的最长有效长度
    int maxLen = 0; // 保存最大长度，最后返回
    
    // 从第1个字符开始遍历（第0个字符不可能有效）
    for (int i = 1; i < n; i++) {
        if (s.charAt(i) == ')') { // 只关注')'结尾的情况
            // 情况1：前一个字符是'('，刚好组成"()"
            if (s.charAt(i-1) == '(') {
                dp[i] = (i >= 2) ? dp[i-2] + 2 : 2; // i>=2时加前面的有效长度，否则直接是2
            } 
            // 情况2：前一个字符是')'，找对应的'('
            else if (i - dp[i-1] > 0 && s.charAt(i - dp[i-1] - 1) == '(') {
                // 计算当前有效长度：中间有效+2+左侧有效
                dp[i] = dp[i-1] + ((i - dp[i-1] >= 2) ? dp[i - dp[i-1] - 2] : 0) + 2;
            }
            // 更新最大长度
            if (dp[i] > maxLen) {
                maxLen = dp[i];
            }
        }
        // 若是'('，dp[i]默认0，不用处理
    }
    return maxLen;
}
```

### 复杂度分析（小白也能懂）
- 时间复杂度：O(n)，只遍历字符串一次（每个字符看一遍）
- 空间复杂度：O(n)，用了一个长度为 n 的 dp 数组（存储每个位置的结果）


## 解法二：栈（Stack）- 小白能懂的「匹配逻辑」
### 核心思想（用栈记录位置，找有效子串的边界）
栈是「先进后出」的结构，这里我们用栈来记录括号的「索引位置」，核心是：
- 遇到 `'('`：把它的索引压入栈（相当于“存档”，等着后面的 `')'` 来匹配）
- 遇到 `')'`：弹出栈顶元素（表示和当前 `')'` 匹配），然后计算当前有效子串的长度

关键技巧：栈初始化时压入 `-1`，作为「无效边界」。比如匹配成功后，用当前索引减去栈顶元素，就是有效子串的长度（避免栈空时无法计算）。

### 分步拆解（小白跟着走）
以示例 `")()())"` 为例（索引 0-5）：
1. 初始化栈：压入 `-1`，栈内：`[-1]`
2. i=0（字符 `')'`）：
   - 弹出栈顶 `-1`，栈空了
   - 把当前索引 0 压入栈（更新无效边界），栈内：`[0]`
3. i=1（字符 `'('`）：压入索引 1，栈内：`[0,1]`
4. i=2（字符 `')'`）：
   - 弹出栈顶 1，栈内：`[0]`
   - 计算长度：2 - 0 = 2，maxLen=2
5. i=3（字符 `'('`）：压入索引 3，栈内：`[0,3]`
6. i=4（字符 `')'`）：
   - 弹出栈顶 3，栈内：`[0]`
   - 计算长度：4 - 0 = 4，maxLen=4
7. i=5（字符 `')'`）：
   - 弹出栈顶 0，栈空了
   - 把当前索引 5 压入栈，栈内：`[5]`
8. 最终 maxLen=4，正确。

### 小白能复制的代码
```java
import java.util.Stack;

public int longestValidParentheses(String s) {
    int n = s.length();
    if (n < 2) return 0;
    Stack<Integer> stack = new Stack<>();
    stack.push(-1); // 初始化无效边界，方便计算长度
    int maxLen = 0;
    
    for (int i = 0; i < n; i++) {
        if (s.charAt(i) == '(') {
            stack.push(i); // '('的索引入栈，等着匹配
        } else {
            stack.pop(); // 弹出栈顶，尝试匹配当前')'
            if (stack.isEmpty()) {
                stack.push(i); // 栈空了，更新无效边界
            } else {
                // 当前索引 - 栈顶元素 = 有效子串长度
                int currentLen = i - stack.peek();
                if (currentLen > maxLen) {
                    maxLen = currentLen;
                }
            }
        }
    }
    return maxLen;
}
```

### 复杂度分析
- 时间复杂度：O(n)，每个字符入栈、出栈各一次（总共 2n 次操作，还是 O(n)）
- 空间复杂度：O(n)，最坏情况栈里存所有索引（比如全是 `'('`，每个都入栈）


## 解法三：双指针（常数空间）- 小白能懂的「计数法」
### 核心思想（不用额外空间，靠两个计数器）
这是最优解，不用栈或数组，只靠两个变量 `left`（统计左括号数量）和 `right`（统计右括号数量），核心逻辑：
- 有效括号的关键是「左右括号数量相等」，且过程中右括号不能比左括号多（否则前面的无法匹配）
- 分两次遍历：
  1. 左→右遍历：处理「右括号过多」的情况（比如 `")()()"` 开头的 `')'`）
  2. 右→左遍历：处理「左括号过多」的情况（比如 `"((())"` 结尾的 `'('`）

### 分步拆解（小白跟着走）
以示例 `"((())"` 为例（索引 0-4）：
1. 左→右遍历：
   - left 一直增加（3 个 `'('`），right 最后才增加（2 个 `')'`）
   - 过程中 left > right，从未相等，所以 maxLen 还是 0
2. 右→左遍历：
   - 从索引 4 开始，right 先增加（2 个 `')'`），left 后增加（3 个 `'('`）
   - 当 i=1 时，left=2，right=2，相等，长度=4，maxLen=4
   - 最终返回 4，正确。

### 小白能复制的代码
```java
public int longestValidParentheses(String s) {
    int n = s.length();
    if (n < 2) return 0;
    int left = 0, right = 0, maxLen = 0;
    
    // 第一次：左→右遍历，处理右括号过多的情况
    for (int i = 0; i < n; i++) {
        if (s.charAt(i) == '(') {
            left++;
        } else {
            right++;
        }
        
        if (left == right) {
            // 左右相等，计算有效长度（2*left，因为一对括号占2个字符）
            maxLen = Math.max(maxLen, 2 * left);
        } else if (right > left) {
            // 右括号多了，前面的无法匹配，重置计数器
            left = 0;
            right = 0;
        }
    }
    
    // 第二次：右→左遍历，处理左括号过多的情况
    left = 0;
    right = 0;
    for (int i = n - 1; i >= 0; i--) {
        if (s.charAt(i) == '(') {
            left++;
        } else {
            right++;
        }
        
        if (left == right) {
            maxLen = Math.max(maxLen, 2 * right);
        } else if (left > right) {
            // 左括号多了，后面的无法匹配，重置计数器
            left = 0;
            right = 0;
        }
    }
    
    return maxLen;
}
```

### 复杂度分析
- 时间复杂度：O(n)，两次遍历字符串（总共 2n 次操作，还是 O(n)）
- 空间复杂度：O(1)，只用到 3 个变量（left、right、maxLen），没有额外空间


## 三种解法对比（小白快速选）
| 解法       | 时间复杂度 | 空间复杂度 | 优点                  | 缺点                  | 适合场景               |
|------------|------------|------------|-----------------------|-----------------------|------------------------|
| 动态规划   | O(n)       | O(n)       | 逻辑严谨，容易迁移    | 需要额外数组          | 想理解子问题的小白     |
| 栈         | O(n)       | O(n)       | 直观易懂，匹配过程清晰 | 需要栈空间            | 刚学栈的小白           |
| 双指针     | O(n)       | O(1)       | 空间最优，效率高      | 需两次遍历            | 追求最优性能的小白     |

**小白推荐顺序**：先学栈（最直观）→ 再学双指针（最优解）→ 最后学动态规划（锻炼逻辑）


## 常见扩展题（小白也能上手）
### 扩展题 1：最长有效括号子序列（非连续）
#### 题目描述：找最长的「有效括号子序列」（子序列可以不连续）
- 示例：输入 `"(()"` → 输出 2（子序列 `"()"`）；输入 `"((()))"` → 输出 6（整个字符串都是有效子序列）
#### 核心思路（动态规划）
- 定义 `dp[i][j]`：字符串从 i 到 j 区间内的最长有效子序列长度
- 若 `s[i] = '('` 且 `s[j] = ')'`，则 `dp[i][j] = dp[i+1][j-1] + 2`（中间的有效长度 + 当前匹配的 2）
- 否则，`dp[i][j] = max(dp[i+1][j], dp[i][j-1])`（取左右两个子区间的最大值）
#### 小白代码
```java
public int longestValidParenthesesSubseq(String s) {
    int n = s.length();
    int[][] dp = new int[n][n]; // dp[i][j]表示s[i..j]的最长有效子序列长度
    
    // 子区间长度从2开始（最短有效子序列是"()"，长度2）
    for (int len = 2; len <= n; len++) {
        for (int i = 0; i + len - 1 < n; i++) {
            int j = i + len - 1; // 区间结束位置
            if (s.charAt(i) == '(' && s.charAt(j) == ')') {
                dp[i][j] = dp[i+1][j-1] + 2;
            }
            // 比较左右子区间，取最大值
            dp[i][j] = Math.max(dp[i][j], Math.max(dp[i+1][j], dp[i][j-1]));
        }
    }
    return dp[0][n-1];
}
```

---

### 扩展题 2：最少添加使括号有效
#### 题目描述：最少添加多少个括号，让整个字符串有效
- 示例：输入 `"())"` → 输出 1（添加一个 `'('`）；输入 `"((("` → 输出 3（添加三个 `')'`）
#### 核心思路（双指针计数）
- 用 `left` 记需要添加的 `'('` 数量，`right` 记需要添加的 `')'` 数量
- 左→右遍历：遇到 `'('` 则 `right++`（需要一个 `')'` 匹配）；遇到 `')'` 若 `right>0` 则 `right--`（匹配成功），否则 `left++`（需要添加 `'('`）
- 最终答案：`left + right`（剩下的未匹配的括号都需要添加）
#### 小白代码
```java
public int minAddToMakeValid(String s) {
    int left = 0, right = 0;
    for (char c : s.toCharArray()) {
        if (c == '(') {
            right++; // 需要一个')'来匹配
        } else {
            if (right > 0) {
                right--; // 找到匹配的'(', 减少需要的')'数量
            } else {
                left++; // 没有对应的'(', 需要添加一个'('
            }
        }
    }
    return left + right; // 剩余未匹配的'('和')'都需要添加
}
```

---

### 扩展题 3：分割为最多的有效括号子串
#### 题目描述：将字符串分割为「尽可能多」的有效括号子串，返回分割数
- 示例：输入 `"(()())"` → 输出 3（分割为 `"()"、"()"、"()"`）；输入 `")()())"` → 输出 2（分割为 `"()"、"()"`，开头的 `")("` 无效）
#### 核心思路（贪心）
- 贪心原则：遇到「左右括号数量相等」时就分割（尽可能早地分割，才能得到最多子串）
- 用 `left` 和 `right` 统计当前区间的括号数量，相等时分割一次，重置计数器
#### 小白代码
```java
public int maxValidParenthesesSplit(String s) {
    int left = 0, right = 0, count = 0;
    for (char c : s.toCharArray()) {
        if (c == '(') {
            left++;
        } else {
            right++;
        }
        if (left == right) { // 左右相等，分割一次
            count++;
            left = 0; // 重置计数器，开始统计下一个区间
            right = 0;
        }
    }
    return count;
}
```

---

### 扩展题 4：验证括号字符串的有效性（基础铺垫）
#### 题目描述：判断给定的括号字符串是否有效（整个字符串是有效括号串）
- 示例：输入 `"()"` → 输出 `true`；输入 `"(()"` → 输出 `false`；输入 `"(())"` → 输出 `true`
#### 核心思路（栈/双指针）
- 方法 1（栈）：遇到 `'('` 入栈，遇到 `')'` 出栈（栈空则无效），最后栈空则有效
- 方法 2（双指针）：统计左右括号数量，过程中右括号不超过左括号，最终数量相等
#### 小白代码（双指针版，空间最优）
```java
public boolean isValid(String s) {
    int left = 0, right = 0;
    for (char c : s.toCharArray()) {
        if (c == '(') left++;
        else right++;
        if (right > left) return false; // 右括号过多，直接无效
    }
    return left == right; // 最终数量相等才有效
}
```


## 小白总结（必看）
1. 最长有效括号（子串）的核心是「连续+匹配平衡」，三种解法各有侧重：
   - 栈：最直观，适合刚入门的小白理解「匹配逻辑」
   - 双指针：空间最优（O(1)），面试高频，必须掌握
   - 动态规划：锻炼「子问题思维」，为复杂扩展题打基础
2. 扩展题都围绕「括号匹配平衡」展开，只要掌握「计数法」「贪心」「动态规划」，就能举一反三
3. 避坑提醒：
   - 区分「子串」（连续）和「子序列」（非连续），题目没说“连续”就是子序列
   - 双指针必须两次遍历（左→右+右→左），否则会漏掉左括号过多的情况
   - 栈初始化压入 `-1` 是关键技巧，避免匹配成功后无法计算长度

如果是面试，优先写双指针解法（空间最优），其次是栈（逻辑清晰）；如果是学习，建议先理解栈，再吃透双指针，最后挑战动态规划～
