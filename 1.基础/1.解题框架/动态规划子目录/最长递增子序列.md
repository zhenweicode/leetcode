

# 最长递增子序列（LIS）问题详解（Java实现）
最长递增子序列（Longest Increasing Subsequence，简称 LIS）是动态规划领域的经典问题，核心是在无序整数数组中找到「元素严格递增、不一定连续」的最长子序列长度。本文将重点拆解 **动态规划解法** 的逻辑细节，补充 Java 实现，并提供常见扩展问题的解决方案。

## 一、问题定义
### 1. 核心描述
给定整数数组 `nums`，返回其中最长递增子序列的长度。
- 递增要求：子序列中元素 **严格递增**（即 `nums[i] < nums[j]` 对于子序列中 `i < j` 成立）；
- 子序列特性：元素在原数组中无需连续，但顺序必须与原数组一致。

### 2. 示例
- 输入：`nums = [10, 9, 2, 5, 3, 7, 101, 18]`
- 输出：`4`
- 解释：最长递增子序列为 `[2, 3, 7, 101]` 或 `[2, 5, 7, 101]` 等，长度均为 4。

## 二、动态规划解法（清晰拆解）
动态规划（DP）解法的核心是「状态定义→转移方程→初始化→遍历顺序→结果提取」，每一步都有明确的逻辑支撑，适合理解问题本质。

### 1. 状态定义（关键）
定义 `dp[i]`：以 `nums[i]` 为 **最后一个元素** 的最长递增子序列的长度。
- 为什么要「以 `nums[i]` 结尾」？因为递增子序列的长度依赖于「前面比当前元素小的子序列」，固定结尾能明确子问题的边界。
- 例如：`nums = [2,5,3]`，`dp[1]`（以 5 结尾）= 2（子序列 `[2,5]`），`dp[2]`（以 3 结尾）= 2（子序列 `[2,3]`）。

### 2. 状态转移方程（逻辑推导）
对于每个索引 `i`（当前元素），需要遍历所有索引 `j < i`（前面的元素），分两种情况：
- 若 `nums[i] > nums[j]`：`nums[i]` 可接在 `nums[j]` 结尾的子序列后，形成更长的递增子序列，因此 `dp[i] = max(dp[i], dp[j] + 1)`；
- 若 `nums[i] <= nums[j]`：`nums[i]` 无法接在 `nums[j]` 结尾的子序列后，不改变 `dp[i]`。

转移方程简化为：
```java
for (int j = 0; j < i; j++) {
    if (nums[i] > nums[j]) {
        dp[i] = Math.max(dp[i], dp[j] + 1);
    }
}
```

### 3. 初始化
每个元素自身可构成长度为 1 的递增子序列（仅包含自己），因此初始化 `dp[i] = 1`（所有索引 `i`）。

### 4. 遍历顺序
- 外层循环：从 `i = 1` 到 `nums.length - 1`（遍历每个当前元素，`i=0` 时 `dp[0] = 1` 已初始化）；
- 内层循环：从 `j = 0` 到 `j = i-1`（遍历当前元素之前的所有元素，判断是否能形成更长子序列）。

### 5. 结果提取
`dp` 数组存储了「以每个元素结尾的最长递增子序列长度」，最终结果是 `dp` 数组中的最大值。

### 6. 完整 Java 代码
```java
import java.util.Arrays;

public class LIS {
    public int lengthOfLIS(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        
        int n = nums.length;
        int[] dp = new int[n];
        dp[0] = 1;
        int maxLen = 1; // 记录全局最长长度（至少为1）
        
        // 外层遍历当前元素（以nums[i]为结尾）
        for (int i = 1; i < n; i++) {
            dp[i] = 1;  // 每个元素自身长度为1
            // 内层遍历前面的元素（判断能否接在nums[j]后）
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            // 更新全局最长长度
            if (dp[i] > maxLen) {
                maxLen = dp[i];
            }
        }
        
        return maxLen;
    }

    // 测试
    public static void main(String[] args) {
        LIS solution = new LIS();
        int[] nums = {10, 9, 2, 5, 3, 7, 101, 18};
        System.out.println(solution.lengthOfLIS(nums)); // 输出 4
    }
}
```

### 7. 复杂度分析
- 时间复杂度：`O(n²)`。外层循环 `n` 次，内层循环平均 `n/2` 次，总操作数为 `n×n` 量级。
- 空间复杂度：`O(n)`。仅需存储长度为 `n` 的 `dp` 数组。

### 8. 关键细节说明
- 为什么不能省略「以 `nums[i]` 结尾」的定义？如果直接定义 `dp[i]` 为「前 `i` 个元素的 LIS 长度」，无法明确子序列的结尾元素，导致无法判断后续元素能否接入，转移方程无法推导。
- 严格递增 vs 非递减：若题目要求「非递减」（`nums[i] >= nums[j]`），只需将转移方程中的 `nums[i] > nums[j]` 改为 `nums[i] >= nums[j]` 即可。

## 三、常见扩展问题及解决方案
### 扩展 1：输出最长递增子序列的具体序列（而非长度）
#### 思路
1. 先用动态规划计算 `dp` 数组，记录「以每个元素结尾的 LIS 长度」；
2. 找到 `dp` 数组中的最大值 `maxLen` 及其对应的索引 `maxIndex`（LIS 的最后一个元素位置）；
3. 从 `maxIndex` 反向遍历数组，找到所有满足「`nums[j] < nums[curIndex]` 且 `dp[j] = dp[curIndex] - 1`」的元素，依次加入结果集；
4. 反转结果集，得到正序的 LIS。

#### Java 代码
```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.Arrays;
import java.util.List;

public class LISWithSequence {
    public List<Integer> getLISSequence(int[] nums) {
        if (nums == null || nums.length == 0) {
            return new ArrayList<>();
        }
        
        int n = nums.length;
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        int maxLen = 1;
        int maxIndex = 0; // 记录LIS最后一个元素的索引
        
        // 第一步：计算dp数组和maxLen、maxIndex
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            if (dp[i] > maxLen) {
                maxLen = dp[i];
                maxIndex = i;
            }
        }
        
        // 第二步：反向回溯构建LIS
        List<Integer> result = new ArrayList<>();
        result.add(nums[maxIndex]);
        int curLen = maxLen - 1; // 下一个元素的LIS长度应比当前小1
        int curIndex = maxIndex;
        
        for (int i = maxIndex - 1; i >= 0; i--) {
            if (nums[i] < nums[curIndex] && dp[i] == curLen) {
                result.add(nums[i]);
                curLen--;
                curIndex = i;
                if (curLen == 0) {
                    break; // 已收集完所有元素
                }
            }
        }
        
        // 反转得到正序
        Collections.reverse(result);
        return result;
    }

    // 测试
    public static void main(String[] args) {
        LISWithSequence solution = new LISWithSequence();
        int[] nums = {10, 9, 2, 5, 3, 7, 101, 18};
        System.out.println(solution.getLISSequence(nums)); // 输出 [2, 3, 7, 101] 或 [2,5,7,101]
    }
}
```

### 扩展 2：最长非递减子序列（允许元素相等）
#### 问题描述
子序列中元素可相等（非递减），其余要求与 LIS 一致。

#### 思路
仅修改转移方程的判断条件：从「`nums[i] > nums[j]`」改为「`nums[i] >= nums[j]`」，其余逻辑不变。

#### Java 代码
```java
import java.util.Arrays;

public class LongestNonDecreasingSubsequence {
    public int lengthOfLNDS(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        
        int n = nums.length;
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        int maxLen = 1;
        
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] >= nums[j]) { // 非递减：允许相等
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            maxLen = Math.max(maxLen, dp[i]);
        }
        
        return maxLen;
    }

    // 测试
    public static void main(String[] args) {
        LongestNonDecreasingSubsequence solution = new LongestNonDecreasingSubsequence();
        int[] nums = {2, 2, 3, 1, 4};
        System.out.println(solution.lengthOfLNDS(nums)); // 输出 4（子序列 [2,2,3,4]）
    }
}
```
