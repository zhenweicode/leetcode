https://leetcode.cn/problems/word-break/description/?envType=study-plan-v2&envId=top-100-liked


### 单词拆分问题：递归（记忆化搜索）与动态规划解法

#### 一、递归（记忆化搜索）解法（基于图中思路）
**思路**：
- 对于字符串 `s`，尝试从词库中找以 `s` 开头的单词，若找到，则递归判断剩余子串是否可拆分。
- 用 `Map<String, Boolean>` 缓存已计算的字符串，避免重复计算。

**代码实现**：
```java
import java.util.List;
import java.util.HashMap;
import java.util.Map;

class Solution {
    Map<String, Boolean> cache = new HashMap<>();

    public boolean wordBreak(String s, List<String> wordDict) {
        // 空字符串可拆分（递归终止条件）
        if (s.equals("")) {
            return true;
        }
        // 缓存命中，直接返回
        if (cache.containsKey(s)) {
            return cache.get(s);
        }
        // 遍历词库，尝试匹配前缀
        for (String word : wordDict) {
            if (s.startsWith(word)) {
                // 递归判断剩余子串
                boolean result = wordBreak(s.substring(word.length()), wordDict);
                cache.put(s, result);
                if (result) {
                    return true;
                }
            }
        }
        // 未找到可拆分的组合
        cache.put(s, false);
        return false;
    }
}
```


#### 二、动态规划解法
**思路**：
- 定义 `dp[i]` 表示字符串 `s` 的前 `i` 个字符是否可由词库拆分。
- 状态转移：对于每个位置 `i`，遍历词库中的单词 `word`，若 `i >= word.length()` 且 `dp[i - word.length()]` 为 `true`，且 `s.substring(i - word.length(), i).equals(word)`，则 `dp[i] = true`。
- 初始条件：`dp[0] = true`（空字符串可拆分）。

**代码实现**：
```java
import java.util.List;

class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        int n = s.length();
        boolean[] dp = new boolean[n + 1];
        dp[0] = true; // 空字符串可拆分
        // 遍历所有长度
        for (int i = 1; i <= n; i++) {
            // 遍历词库，尝试匹配
            for (String word : wordDict) {
                int len = word.length();
                if (i >= len && dp[i - len] && s.substring(i - len, i).equals(word)) {
                    dp[i] = true;
                    break; // 找到一种拆分方式即可
                }
            }
        }
        return dp[n];
    }
}
```


### 两种解法对比
| 维度         | 递归（记忆化搜索）| 动态规划               |
|--------------|-------------------|------------------------|
| 时间复杂度   | \(O(n \times m \times k)\)（\(n\) 为字符串长度，\(m\) 为词库大小，\(k\) 为单词平均长度） | \(O(n \times m \times k)\) |
| 空间复杂度   | \(O(n)\)（缓存 + 递归栈） | \(O(n)\)（DP数组）|
| 可读性       | 逻辑直观，贴近递归思维 | 需理解状态转移，工程中更高效 |
| 适用场景     | 小数据量或快速验证思路 | 大数据量，追求效率       |


两种解法均能解决单词拆分问题，递归解法思路更直接，动态规划解法在时间和空间效率上表现更优，可根据实际需求选择。
