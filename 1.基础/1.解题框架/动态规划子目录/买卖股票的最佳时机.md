

# 买卖股票的最佳时机（全解法+扩展问题）详解（Java）
买卖股票的最佳时机是数组类经典问题，核心是通过「低买高卖」最大化利润，不同约束条件（交易次数、冷冻期等）对应不同解法。本文将先讲解**基础版（最多买卖一次）的3种清晰解法**（暴力、贪心、动态规划），再拓展5种高频变种问题的解决方案，全程使用Java实现，逻辑分步拆解。

## 一、基础版问题定义
### 1. 核心描述
给定数组 `prices`，`prices[i]` 表示第 `i` 天的股票价格，**最多买卖一次**（买入后卖出，不可多次交易），返回最大利润；若无获利机会，返回 0。

### 2. 示例
- 输入：`prices = [7,1,5,3,6,4]` → 输出：`5`（第2天买，第5天卖，利润 `6-1=5`）；
- 输入：`prices = [7,6,4,3,1]` → 输出：`0`（价格持续下跌，无获利）。

## 二、基础版3种解法（清晰易懂）
### 解法1：暴力枚举（直观但低效）
#### 思路
枚举所有「买入日 `i` + 卖出日 `j`」（`j > i`），计算利润 `prices[j] - prices[i]`，取最大值。

#### Java代码
```java
public int maxProfit(int[] prices) {
    if (prices == null || prices.length <= 1) return 0;
    int maxProfit = 0;
    int n = prices.length;
    // 枚举买入日i
    for (int i = 0; i < n - 1; i++) {
        // 枚举卖出日j（j > i）
        for (int j = i + 1; j < n; j++) {
            int profit = prices[j] - prices[i];
            if (profit > maxProfit) {
                maxProfit = profit;
            }
        }
    }
    return maxProfit;
}
```

#### 复杂度分析
- 时间复杂度：`O(n²)`，两层循环遍历所有可能的交易对；
- 空间复杂度：`O(1)`，无额外空间消耗；
- 适用场景：仅用于理解问题本质，数组长度 `n ≤ 1000` 时可用，大规模数据会超时。

### 解法2：贪心算法（最优时间效率）
#### 思路
核心逻辑：**记录历史最低买入价，每天计算当前卖出的利润，更新最大利润**。
1. 遍历数组，维护一个变量 `minPrice`，记录截至当天的最低股票价格；
2. 对于每天的价格 `prices[i]`，计算「当前价格 - 历史最低价格」的利润；
3. 用该利润更新最大利润 `maxProfit`。

#### Java代码
```java
public int maxProfit(int[] prices) {
    if (prices == null || prices.length <= 1) return 0;
    int minPrice = prices[0]; // 历史最低买入价
    int maxProfit = 0; // 最大利润
    for (int i = 1; i < prices.length; i++) {
        // 计算当前卖出的利润，更新最大利润
        maxProfit = Math.max(maxProfit, prices[i] - minPrice);
        // 更新历史最低买入价（若当前价格更低）
        minPrice = Math.min(minPrice, prices[i]);
    }
    return maxProfit;
}
```

#### 关键说明
- 贪心的本质是「局部最优推导全局最优」：每天都做「以历史最低价买入、当前价卖出」的最优选择，最终得到全局最大利润；
- 遍历顺序：从左到右一次遍历，无需回溯，效率极高。

#### 复杂度分析
- 时间复杂度：`O(n)`，仅遍历数组一次；
- 空间复杂度：`O(1)`，仅用两个变量；
- 适用场景：基础版最优解法，适合所有规模数据。

### 解法3：动态规划（通用可扩展）
#### 思路
动态规划的核心是「定义状态→梳理转移逻辑」，适合后续扩展到复杂约束（如多次交易、冷冻期）。

#### 1. 状态定义
定义两个状态变量（无需数组，空间优化）：
- `notHold`：表示当前（第 `i` 天）不持有股票的最大利润；
- `hold`：表示当前（第 `i` 天）持有股票的最大利润。

#### 2. 状态转移逻辑
- **不持有股票（notHold）**：
  1. 前一天就不持有，当前无操作 → 利润继承 `notHold`；
  2. 前一天持有，当前卖出 → 利润 = `hold + 当前价格`；
  → 取两者最大值：`notHold = Math.max(notHold, hold + prices[i])`。
- **持有股票（hold）**：
  1. 前一天就持有，当前无操作 → 利润继承 `hold`；
  2. 前一天不持有，当前买入 → 利润 = `0 - 当前价格`（最多买一次，之前无交易，利润为0）；
  → 取两者最大值：`hold = Math.max(hold, -prices[i])`。

#### 3. 初始化
- 第 0 天不持有股票：`notHold = 0`（无操作，利润0）；
- 第 0 天持有股票：`hold = -prices[0]`（买入第0天股票，利润为负的买入价）。

#### 4. Java代码
```java
public int maxProfitDP(int[] prices) {
    if (prices == null || prices.length <= 1) return 0;
    int notHold = 0; // 不持有股票的最大利润
    int hold = -prices[0]; // 持有股票的最大利润
    for (int i = 1; i < prices.length; i++) {
        // 先保存前一天的不持有状态（避免被覆盖）
        int prevNotHold = notHold;
        // 更新不持有状态
        notHold = Math.max(prevNotHold, hold + prices[i]);
        // 更新持有状态（最多买一次，买入时利润为0 - 价格）
        hold = Math.max(hold, -prices[i]);
    }
    // 最终最大利润一定是不持有股票的状态（持有无意义）
    return Math.max(notHold, 0);
}
```

#### 复杂度分析
- 时间复杂度：`O(n)`，遍历数组一次；
- 空间复杂度：`O(1)`，仅用两个变量；
- 适用场景：基础版可用，且是后续复杂变种的基础框架。

## 三、常见扩展问题及解决方案
股票问题的核心变种是「交易次数限制」「冷冻期」「手续费」，以下基于基础版思路，拓展5种高频问题。

### 扩展1：买卖股票的最佳时机 II（无交易次数限制）
#### 问题描述
可多次买卖股票（买入后必须卖出才能再买入），求最大利润。

#### 核心变化
无交易次数限制 → 买入时的利润来源是「之前卖出后的利润」（而非基础版的0）。

#### 解法（贪心/动态规划）
##### 贪心解法（最简单）
思路：**只要当天价格比前一天高，就进行一次“低买高卖”**（相当于捕捉所有上涨区间的利润）。
```java
public int maxProfitII(int[] prices) {
    if (prices == null || prices.length <= 1) return 0;
    int maxProfit = 0;
    for (int i = 1; i < prices.length; i++) {
        // 当天价格 > 前一天价格，就赚差价
        if (prices[i] > prices[i-1]) {
            maxProfit += prices[i] - prices[i-1];
        }
    }
    return maxProfit;
}
```

##### 动态规划解法（通用）
状态转移调整：持有股票时，买入利润 =「前一天不持有的利润 - 当前价格」（而非基础版的 `0 - 价格`）。
```java
public int maxProfitIIDP(int[] prices) {
    if (prices == null || prices.length <= 1) return 0;
    int notHold = 0;
    int hold = -prices[0];
    for (int i = 1; i < prices.length; i++) {
        int prevNotHold = notHold;
        notHold = Math.max(prevNotHold, hold + prices[i]);
        // 可多次交易：买入时用之前卖出的利润
        hold = Math.max(hold, prevNotHold - prices[i]);
    }
    return notHold;
}
```

#### 示例
- 输入：`[7,1,5,3,6,4]` → 输出：`7`（1买5卖，3买6卖，利润 `4+3=7`）。

### 扩展2：买卖股票的最佳时机 III（最多买卖两次）
#### 问题描述
最多买卖两次（可只买卖一次），求最大利润。

#### 解法（动态规划）
状态需增加「交易次数」维度，定义 `dp[k][0/1]`：
- `k`：已完成的交易次数（`k=0,1,2`）；
- `0/1`：不持有/持有股票。

```java
public int maxProfitIII(int[] prices) {
    if (prices == null || prices.length <= 1) return 0;
    // dp[k][0]：交易k次，不持有股票的最大利润
    // dp[k][1]：交易k次，持有股票的最大利润
    int[][] dp = new int[3][2];
    // 初始化：交易0次时的状态
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    // 交易1/2次时，初始为负无穷（不可能状态）
    for (int k = 1; k <= 2; k++) {
        dp[k][0] = Integer.MIN_VALUE / 2; // 避免溢出
        dp[k][1] = Integer.MIN_VALUE / 2;
    }
    
    for (int price : prices) {
        // 从后往前更新（避免覆盖未使用的状态）
        for (int k = 2; k >= 1; k--) {
            dp[k][0] = Math.max(dp[k][0], dp[k-1][1] + price); // 卖出完成一次交易
            dp[k][1] = Math.max(dp[k][1], dp[k][0] - price);   // 买入不增加交易次数
        }
        // 更新交易0次的状态
        dp[0][1] = Math.max(dp[0][1], -price);
    }
    
    // 最大利润是交易0/1/2次后不持有的最大值
    return Math.max(0, Math.max(dp[1][0], dp[2][0]));
}
```

#### 示例
- 输入：`[3,3,5,0,0,3,1,4]` → 输出：`6`（0买3卖，1买4卖，利润 `3+3=6`）。

### 扩展3：买卖股票的最佳时机 IV（最多买卖 k 次）
#### 问题描述
最多买卖 `k` 次，求最大利润。

#### 核心优化
当 `k >= n/2` 时，等同于「无交易次数限制」（因为 `n` 天最多能完成 `n/2` 次交易，如6天最多3次），直接用扩展1的贪心解法。

#### Java代码
```java
public int maxProfitIV(int k, int[] prices) {
    if (prices == null || prices.length <= 1 || k == 0) return 0;
    int n = prices.length;
    // 当k >= n/2，无交易限制
    if (k >= n / 2) {
        int maxProfit = 0;
        for (int i = 1; i < n; i++) {
            if (prices[i] > prices[i-1]) {
                maxProfit += prices[i] - prices[i-1];
            }
        }
        return maxProfit;
    }
    
    // 动态规划：dp[k][0/1]
    int[][] dp = new int[k+1][2];
    // 初始化：交易0次
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    // 交易1~k次，初始为负无穷
    for (int t = 1; t <= k; t++) {
        dp[t][0] = Integer.MIN_VALUE / 2;
        dp[t][1] = Integer.MIN_VALUE / 2;
    }
    
    for (int price : prices) {
        // 从后往前更新，避免覆盖
        for (int t = k; t >= 1; t--) {
            dp[t][0] = Math.max(dp[t][0], dp[t-1][1] + price);
            dp[t][1] = Math.max(dp[t][1], dp[t][0] - price);
        }
        dp[0][1] = Math.max(dp[0][1], -price);
    }
    
    // 取交易0~k次的最大利润
    int maxProfit = 0;
    for (int t = 0; t <= k; t++) {
        maxProfit = Math.max(maxProfit, dp[t][0]);
    }
    return maxProfit;
}
```

### 扩展4：买卖股票的最佳时机含冷冻期
#### 问题描述
无交易次数限制，但卖出股票后，第2天不能买入（冷冻期1天）。

#### 解法（动态规划）
新增「冷冻期状态」，定义3个状态：
- `notHold`：不持有股票，且不在冷冻期；
- `hold`：持有股票；
- `cooldown`：不持有股票，且在冷冻期。

```java
public int maxProfitWithCooldown(int[] prices) {
    if (prices == null || prices.length <= 1) return 0;
    int n = prices.length;
    int notHold = 0;    // 不持有，非冷冻期
    int hold = -prices[0]; // 持有
    int cooldown = 0;   // 不持有，冷冻期
    
    for (int i = 1; i < n; i++) {
        int prevNotHold = notHold;
        // 更新不持有（非冷冻期）：继承前一天非冷冻期，或前一天冷冻期结束
        notHold = Math.max(notHold, cooldown);
        // 更新冷冻期：前一天持有，当天卖出
        cooldown = hold + prices[i];
        // 更新持有：继承前一天持有，或前一天非冷冻期买入
        hold = Math.max(hold, prevNotHold - prices[i]);
    }
    
    // 最终最大利润：非冷冻期不持有 或 冷冻期不持有
    return Math.max(notHold, cooldown);
}
```

#### 示例
- 输入：`[1,2,3,0,2]` → 输出：`3`（1买2卖，冷冻期后0买2卖，利润 `1+2=3`）。

### 扩展5：买卖股票的最佳时机含手续费
#### 问题描述
无交易次数限制，但每次卖出股票需支付固定手续费 `fee`，求最大利润。

#### 解法（动态规划）
状态转移调整：卖出股票时，利润 =「持有利润 + 当前价格 - 手续费」（扣除手续费）。

```java
public int maxProfitWithFee(int[] prices, int fee) {
    if (prices == null || prices.length <= 1) return 0;
    int notHold = 0; // 不持有
    int hold = -prices[0]; // 持有
    for (int price : prices) {
        int prevNotHold = notHold;
        // 卖出时扣除手续费
        notHold = Math.max(prevNotHold, hold + price - fee);
        hold = Math.max(hold, prevNotHold - price);
    }
    return notHold;
}
```

#### 示例
- 输入：`prices = [1,3,2,8,4,9], fee = 2` → 输出：`8`（1买8卖，4买9卖，利润 `(8-1-2)+(9-4-2)=5+3=8`）。

## 四、各解法及扩展问题对比
| 问题类型                | 推荐解法       | 时间复杂度 | 空间复杂度 | 核心特点                     |
|-------------------------|----------------|------------|------------|------------------------------|
| 基础版（最多1次）       | 贪心/动态规划  | O(n)       | O(1)       | 捕捉历史最低价，逻辑简单     |
| 无交易限制（多次）      | 贪心           | O(n)       | O(1)       | 捕捉所有上涨区间，效率最高   |
| 最多2次交易             | 动态规划       | O(n)       | O(1)       | 状态增加交易次数维度         |
| 最多k次交易             | 动态规划+贪心优化 | O(nk)      | O(k)       | k较大时转为无限制交易        |
| 含冷冻期                | 动态规划       | O(n)       | O(1)       | 新增冷冻期状态               |
| 含手续费                | 动态规划       | O(n)       | O(1)       | 卖出时扣除手续费             |

## 五、核心总结
1. 基础版优先用**贪心**（简单高效），需扩展到复杂约束时用**动态规划**（通用框架）；
2. 动态规划的核心是「状态定义」：根据约束条件（交易次数、冷冻期）增减状态维度，转移逻辑围绕「持有/不持有股票」展开；
3. 贪心算法适用于「无交易限制」或「最多1次交易」，核心是「捕捉局部最优」（如历史最低价、上涨区间）；
4. 所有扩展问题均可基于基础版的动态规划框架调整，只需修改「状态转移时的利润来源」（如扣除手续费、冷冻期限制买入）。

掌握以上内容后，可应对LeetCode上所有股票相关问题，关键是理解「约束条件如何转化为状态或转移逻辑」。
