# 买卖股票的最佳时机（非动态规划解法）详解（Java）

## 一、基础版问题定义（最多买卖一次）
### 1. 核心描述
给定数组 `prices`，`prices[i]` 表示第 `i` 天的股票价格，**最多买卖一次**（买入后卖出，不可多次交易），返回最大利润；若无获利机会，返回 0。

### 2. 示例
- 输入：`prices = [7,1,5,3,6,4]` → 输出：`5`（第2天买，第5天卖，利润 `6-1=5`）；
- 输入：`prices = [7,6,4,3,1]` → 输出：`0`（价格持续下跌，无获利）。

### 解法：贪心算法（最优）
#### 思路
核心逻辑：**记录历史最低买入价，每天计算当前卖出的最大利润**。
1. 维护 `minPrice` 变量，存储截至当天的最低股票价格；
2. 遍历数组，对于每天的价格 `prices[i]`，计算「当前价格 - 历史最低价格」的利润；
3. 用该利润更新最大利润 `maxProfit`。

#### Java 代码
```java
public int maxProfit(int[] prices) {
    if (prices == null || prices.length <= 1) return 0;
    int minPrice = prices[0]; // 历史最低买入价
    int maxProfit = 0; // 最大利润
    for (int i = 1; i < prices.length; i++) {
        // 更新历史最低买入价（若当前价格更低）
        minPrice = Math.min(minPrice, prices[i]);
        // 计算当前卖出的利润，更新最大利润
        maxProfit = Math.max(maxProfit, prices[i] - minPrice);
    }
    return maxProfit;
}
```

#### 复杂度分析
- 时间复杂度：`O(n)`，仅遍历数组一次；
- 空间复杂度：`O(1)`，仅用两个变量；
- 优势：逻辑直观，无额外空间消耗，适合所有规模数据。

## 二、扩展问题（非动态规划解法）
### 扩展 1：买卖股票的最佳时机 II（无交易次数限制）
#### 问题描述
可多次买卖股票（买入后必须卖出才能再买入），求最大利润。

#### 解法：贪心算法（捕捉所有上涨区间）
#### 思路
核心逻辑：**只要当天价格比前一天高，就进行一次“低买高卖”**，相当于捕捉所有上涨区间的利润总和。
- 例：`[1,2,3,4]` → 利润 `(2-1)+(3-2)+(4-3)=3`，等同于「1买4卖」；
- 本质：上涨区间的总利润等于首尾差价，贪心遍历可直接累加所有相邻上涨的差价。

#### Java 代码
```java
public int maxProfitII(int[] prices) {
    if (prices == null || prices.length <= 1) return 0;
    int maxProfit = 0;
    for (int i = 1; i < prices.length; i++) {
        // 当天价格 > 前一天价格，赚差价
        if (prices[i] > prices[i-1]) {
            maxProfit += prices[i] - prices[i-1];
        }
    }
    return maxProfit;
}
```

#### 示例
- 输入：`prices = [7,1,5,3,6,4]` → 输出：`7`（1买5卖，3买6卖，利润 `4+3=7`）；
- 复杂度：`O(n)` 时间，`O(1)` 空间。

### 扩展 2：买卖股票的最佳时机含冷冻期（无交易次数限制）
#### 问题描述
无交易次数限制，但卖出股票后，第 2 天不能买入（冷冻期 1 天），求最大利润。

#### 核心逻辑
用3个变量代表「当天结束后的状态」，每天只基于前一天的状态更新：
- `hold`：当天结束后 **持有股票** 的最大利润；
- `notHoldNoCool`：当天结束后 **不持有股票、且不在冷冻期** 的最大利润（第二天能买）；
- `notHoldCool`：当天结束后 **不持有股票、且在冷冻期** 的最大利润（第二天不能买）。

#### 状态更新规则（一句话记牢）
- 持有股票（hold）：要么昨天就持有，要么昨天“能买”（notHoldNoCool）今天买入（扣钱）；
- 不持有+不在冷冻期（notHoldNoCool）：要么昨天就“不在冷冻期”，要么昨天“在冷冻期”（今天解冻了）；
- 不持有+在冷冻期（notHoldCool）：只能是昨天持有股票，今天卖出（赚钱）。

#### Java代码（超短，注释详细）
```java
public int maxProfit(int[] prices) {
    if (prices == null || prices.length <= 1) {
        return 0; // 不够1天，没法交易
    }

    // 初始化第0天的状态
    int hold = -prices[0]; // 第0天买入股票，利润是 -买入价
    int notHoldNoCool = 0; // 第0天没买股票，不在冷冻期，利润0
    int notHoldCool = 0;   // 第0天没法卖出，所以不可能在冷冻期，利润0

    // 从第1天开始遍历
    for (int i = 1; i < prices.length; i++) {
        // 保存前一天的状态（避免更新时被覆盖）
        int prevHold = hold;
        int prevNotHoldNoCool = notHoldNoCool;
        int prevNotHoldCool = notHoldCool;

        // 1. 更新当天持有股票的利润
        hold = Math.max(prevHold, prevNotHoldNoCool - prices[i]);
        // 2. 更新当天不持有+不在冷冻期的利润
        notHoldNoCool = Math.max(prevNotHoldNoCool, prevNotHoldCool);
        // 3. 更新当天不持有+在冷冻期的利润（只能是昨天持有，今天卖出）
        notHoldCool = prevHold + prices[i];
    }

    // 最终最大利润：要么不在冷冻期，要么在冷冻期（都是卖出后的状态）
    return Math.max(notHoldNoCool, notHoldCool);
}
```

#### 示例
- 输入：`prices = [1,2,3,0,2]` → 输出：`3`（1买2卖，冷冻期后0买2卖，利润 `1+2=3`）；
- 复杂度：`O(n)` 时间，`O(1)` 空间；
- 优势：无需 DP 数组，用变量直接模拟状态流转，逻辑清晰且高效。

### 扩展 3：买卖股票的最佳时机含手续费（无交易次数限制）
#### 问题描述
无交易次数限制，但每次卖出股票需支付固定手续费 `fee`，求最大利润。

#### 解法：贪心算法（优化卖出时机）
#### 思路
核心逻辑：**将手续费计入买入成本**，仅当「当前价格 - （买入成本 + 手续费）> 0」时才卖出，避免频繁交易导致手续费损耗。
1. 维护 `minCost` 变量：记录「买入价 + 手续费」的最低值（相当于将手续费提前计入成本）；
2. 遍历数组，对于每天价格 `prices[i]`：
   - 若 `prices[i] > minCost`：卖出获利，利润累加 `prices[i] - minCost`，同时更新 `minCost` 为当前价格（模拟“当天卖出后立即买入”，避免错过后续更高价格）；
   - 若 `prices[i] + fee < minCost`：更新 `minCost` 为 `prices[i] + fee`（当前买入成本更低）。

#### Java 代码
```java
public int maxProfitWithFee(int[] prices, int fee) {
    if (prices == null || prices.length <= 1) return 0;
    int maxProfit = 0;
    int minCost = prices[0] + fee; // 初始成本：第0天买入价 + 手续费
    for (int i = 1; i < prices.length; i++) {
        // 情况1：当前价格 > 最低成本，卖出获利
        if (prices[i] > minCost) {
            maxProfit += prices[i] - minCost;
            // 更新成本为当前价格（模拟“卖出后立即买入”，后续若涨价可继续获利，实际不卖）
            minCost = prices[i];
        }
        // 情况2：当前买入成本（价格+手续费）更低，更新最低成本
        if (prices[i] + fee < minCost) {
            minCost = prices[i] + fee;
        }
    }
    return maxProfit;
}
```

#### 示例
- 输入：`prices = [1,3,2,8,4,9], fee = 2` → 输出：`8`（1买8卖，4买9卖，利润 `(8-1-2)+(9-4-2)=5+3=8`）；
- 复杂度：`O(n)` 时间，`O(1)` 空间；
- 优势：无需记录持仓状态，直接通过成本优化实现贪心决策，避免频繁交易。
