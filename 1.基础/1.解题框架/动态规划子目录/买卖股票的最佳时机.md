# 买卖股票的最佳时机（非动态规划解法）详解（Java）

## 一、基础版问题定义（最多买卖一次）
### 1. 核心描述
给定数组 `prices`，`prices[i]` 表示第 `i` 天的股票价格，**最多买卖一次**（买入后卖出，不可多次交易），返回最大利润；若无获利机会，返回 0。

### 2. 示例
- 输入：`prices = [7,1,5,3,6,4]` → 输出：`5`（第2天买，第5天卖，利润 `6-1=5`）；
- 输入：`prices = [7,6,4,3,1]` → 输出：`0`（价格持续下跌，无获利）。

### 解法：贪心算法（最优）
#### 思路
核心逻辑：**记录历史最低买入价，每天计算当前卖出的最大利润**。
1. 维护 `minPrice` 变量，存储截至当天的最低股票价格；
2. 遍历数组，对于每天的价格 `prices[i]`，计算「当前价格 - 历史最低价格」的利润；
3. 用该利润更新最大利润 `maxProfit`。

#### Java 代码
```java
public int maxProfit(int[] prices) {
    if (prices == null || prices.length <= 1) return 0;
    int minPrice = prices[0]; // 历史最低买入价
    int maxProfit = 0; // 最大利润
    for (int i = 1; i < prices.length; i++) {
        // 更新历史最低买入价（若当前价格更低）
        minPrice = Math.min(minPrice, prices[i]);
        // 计算当前卖出的利润，更新最大利润
        maxProfit = Math.max(maxProfit, prices[i] - minPrice);
    }
    return maxProfit;
}
```

#### 复杂度分析
- 时间复杂度：`O(n)`，仅遍历数组一次；
- 空间复杂度：`O(1)`，仅用两个变量；
- 优势：逻辑直观，无额外空间消耗，适合所有规模数据。

## 二、扩展问题（非动态规划解法）
### 扩展 1：买卖股票的最佳时机 II（无交易次数限制）
#### 问题描述
可多次买卖股票（买入后必须卖出才能再买入），求最大利润。

#### 解法：贪心算法（捕捉所有上涨区间）
#### 思路
核心逻辑：**只要当天价格比前一天高，就进行一次“低买高卖”**，相当于捕捉所有上涨区间的利润总和。
- 例：`[1,2,3,4]` → 利润 `(2-1)+(3-2)+(4-3)=3`，等同于「1买4卖」；
- 本质：上涨区间的总利润等于首尾差价，贪心遍历可直接累加所有相邻上涨的差价。

#### Java 代码
```java
public int maxProfitII(int[] prices) {
    if (prices == null || prices.length <= 1) return 0;
    int maxProfit = 0;
    for (int i = 1; i < prices.length; i++) {
        // 当天价格 > 前一天价格，赚差价
        if (prices[i] > prices[i-1]) {
            maxProfit += prices[i] - prices[i-1];
        }
    }
    return maxProfit;
}
```

#### 示例
- 输入：`prices = [7,1,5,3,6,4]` → 输出：`7`（1买5卖，3买6卖，利润 `4+3=7`）；
- 复杂度：`O(n)` 时间，`O(1)` 空间。

### 扩展 2：买卖股票的最佳时机含冷冻期（无交易次数限制）
#### 问题描述
无交易次数限制，但卖出股票后，第 2 天不能买入（冷冻期 1 天），求最大利润。

#### 解法：模拟状态转移（非 DP 数组，变量记录状态）
#### 思路
用三个变量记录每天的状态（无需 DP 数组，模拟状态流转）：
- `notHold`：不持有股票，且不在冷冻期；
- `hold`：持有股票；
- `cooldown`：不持有股票，且在冷冻期。

状态流转逻辑：
1. 当天 `notHold`：要么前一天就 `notHold`（无操作），要么前一天 `cooldown`（冷冻期结束）；
2. 当天 `hold`：要么前一天就 `hold`（无操作），要么前一天 `notHold`（当天买入，避开冷冻期）；
3. 当天 `cooldown`：只能是前一天 `hold`（当天卖出，进入冷冻期）。

#### Java 代码
```java
public int maxProfitWithCooldown(int[] prices) {
    if (prices == null || prices.length <= 1) return 0;
    int n = prices.length;
    int notHold = 0;    // 不持有，非冷冻期
    int hold = -prices[0]; // 持有（第0天买入）
    int cooldown = 0;   // 不持有，冷冻期（第0天无法卖出，初始为0）
    
    for (int i = 1; i < n; i++) {
        // 保存前一天的非冷冻期状态（避免被覆盖）
        int prevNotHold = notHold;
        // 更新非冷冻期：继承前一天非冷冻期，或前一天冷冻期结束
        notHold = Math.max(notHold, cooldown);
        // 更新冷冻期：前一天持有，当天卖出
        cooldown = hold + prices[i];
        // 更新持有：继承前一天持有，或前一天非冷冻期买入（避开冷冻期）
        hold = Math.max(hold, prevNotHold - prices[i]);
    }
    
    // 最终最大利润：非冷冻期不持有 或 冷冻期不持有（卖出后的状态）
    return Math.max(notHold, cooldown);
}
```

#### 示例
- 输入：`prices = [1,2,3,0,2]` → 输出：`3`（1买2卖，冷冻期后0买2卖，利润 `1+2=3`）；
- 复杂度：`O(n)` 时间，`O(1)` 空间；
- 优势：无需 DP 数组，用变量直接模拟状态流转，逻辑清晰且高效。

### 扩展 3：买卖股票的最佳时机含手续费（无交易次数限制）
#### 问题描述
无交易次数限制，但每次卖出股票需支付固定手续费 `fee`，求最大利润。

#### 解法：贪心算法（优化卖出时机）
#### 思路
核心逻辑：**将手续费计入买入成本**，仅当「当前价格 - （买入成本 + 手续费）> 0」时才卖出，避免频繁交易导致手续费损耗。
1. 维护 `minCost` 变量：记录「买入价 + 手续费」的最低值（相当于将手续费提前计入成本）；
2. 遍历数组，对于每天价格 `prices[i]`：
   - 若 `prices[i] > minCost`：卖出获利，利润累加 `prices[i] - minCost`，同时更新 `minCost` 为当前价格（模拟“当天卖出后立即买入”，避免错过后续更高价格）；
   - 若 `prices[i] + fee < minCost`：更新 `minCost` 为 `prices[i] + fee`（当前买入成本更低）。

#### Java 代码
```java
public int maxProfitWithFee(int[] prices, int fee) {
    if (prices == null || prices.length <= 1) return 0;
    int maxProfit = 0;
    int minCost = prices[0] + fee; // 初始成本：第0天买入价 + 手续费
    for (int i = 1; i < prices.length; i++) {
        // 情况1：当前价格 > 最低成本，卖出获利
        if (prices[i] > minCost) {
            maxProfit += prices[i] - minCost;
            // 更新成本为当前价格（模拟“卖出后立即买入”，后续若涨价可继续获利，实际不卖）
            minCost = prices[i];
        }
        // 情况2：当前买入成本（价格+手续费）更低，更新最低成本
        if (prices[i] + fee < minCost) {
            minCost = prices[i] + fee;
        }
    }
    return maxProfit;
}
```

#### 示例
- 输入：`prices = [1,3,2,8,4,9], fee = 2` → 输出：`8`（1买8卖，4买9卖，利润 `(8-1-2)+(9-4-2)=5+3=8`）；
- 复杂度：`O(n)` 时间，`O(1)` 空间；
- 优势：无需记录持仓状态，直接通过成本优化实现贪心决策，避免频繁交易。
