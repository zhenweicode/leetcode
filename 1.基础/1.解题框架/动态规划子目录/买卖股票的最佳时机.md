# 买卖股票的最佳时机（非动态规划解法）详解（Java）

## 一、基础版问题定义（最多买卖一次）
### 1. 核心描述
给定数组 `prices`，`prices[i]` 表示第 `i` 天的股票价格，**最多买卖一次**（买入后卖出，不可多次交易），返回最大利润；若无获利机会，返回 0。

### 2. 示例
- 输入：`prices = [7,1,5,3,6,4]` → 输出：`5`（第2天买，第5天卖，利润 `6-1=5`）；
- 输入：`prices = [7,6,4,3,1]` → 输出：`0`（价格持续下跌，无获利）。

### 解法：贪心算法（最优）
#### 思路
核心逻辑：**记录历史最低买入价，每天计算当前卖出的最大利润**。
1. 维护 `minPrice` 变量，存储截至当天的最低股票价格；
2. 遍历数组，对于每天的价格 `prices[i]`，计算「当前价格 - 历史最低价格」的利润；
3. 用该利润更新最大利润 `maxProfit`。

#### Java 代码
```java
public int maxProfit(int[] prices) {
    if (prices == null || prices.length <= 1) return 0;
    int minPrice = prices[0]; // 历史最低买入价
    int maxProfit = 0; // 最大利润
    for (int i = 1; i < prices.length; i++) {
        // 更新历史最低买入价（若当前价格更低）
        minPrice = Math.min(minPrice, prices[i]);
        // 计算当前卖出的利润，更新最大利润
        maxProfit = Math.max(maxProfit, prices[i] - minPrice);
    }
    return maxProfit;
}
```

#### 复杂度分析
- 时间复杂度：`O(n)`，仅遍历数组一次；
- 空间复杂度：`O(1)`，仅用两个变量；
- 优势：逻辑直观，无额外空间消耗，适合所有规模数据。

## 二、扩展问题（非动态规划解法）
### 扩展 1：买卖股票的最佳时机 II（无交易次数限制）
#### 问题描述
可多次买卖股票（买入后必须卖出才能再买入），求最大利润。

#### 解法：贪心算法（捕捉所有上涨区间）
#### 思路
核心逻辑：**只要当天价格比前一天高，就进行一次“低买高卖”**，相当于捕捉所有上涨区间的利润总和。
- 例：`[1,2,3,4]` → 利润 `(2-1)+(3-2)+(4-3)=3`，等同于「1买4卖」；
- 本质：上涨区间的总利润等于首尾差价，贪心遍历可直接累加所有相邻上涨的差价。

#### Java 代码
```java
public int maxProfitII(int[] prices) {
    if (prices == null || prices.length <= 1) return 0;
    int maxProfit = 0;
    for (int i = 1; i < prices.length; i++) {
        // 当天价格 > 前一天价格，赚差价
        if (prices[i] > prices[i-1]) {
            maxProfit += prices[i] - prices[i-1];
        }
    }
    return maxProfit;
}
```

#### 示例
- 输入：`prices = [7,1,5,3,6,4]` → 输出：`7`（1买5卖，3买6卖，利润 `4+3=7`）；
- 复杂度：`O(n)` 时间，`O(1)` 空间。

### 扩展 2：买卖股票的最佳时机含手续费（无交易次数限制）
#### 问题描述
无交易次数限制，但每次卖出股票需支付固定手续费 `fee`，求最大利润。

#### 解法：贪心算法（优化卖出时机）
#### 思路
核心逻辑：**将手续费计入买入成本**，仅当「当前价格 - （买入成本 + 手续费）> 0」时才卖出，避免频繁交易导致手续费损耗。
1. 维护 `minCost` 变量：记录「买入价 + 手续费」的最低值（相当于将手续费提前计入成本）；
2. 遍历数组，对于每天价格 `prices[i]`：
   - 若 `prices[i] > minCost`：卖出获利，利润累加 `prices[i] - minCost`，同时更新 `minCost` 为当前价格（模拟“当天卖出后立即买入”，避免错过后续更高价格）；
   - 若 `prices[i] + fee < minCost`：更新 `minCost` 为 `prices[i] + fee`（当前买入成本更低）。
  
在「买卖股票含手续费（无交易次数限制）」的贪心解法中，“卖出后立即以当前价格买入” 是核心技巧—— 它并非真的要执行 “卖出再买入” 的多余操作，而是通过「成本更新」的数学等价，实现 “锁定已有利润、捕捉后续上涨收益” 的目标。
用成本更新的方式，将 “多次上涨区间的利润合并为一次卖出”，避免重复支付手续费，同时不遗漏后续上涨收益。

#### Java 代码
```java
public int maxProfitWithFee(int[] prices, int fee) {
    if (prices == null || prices.length <= 1) return 0;
    int maxProfit = 0;
    int minCost = prices[0] + fee; // 初始成本：第0天买入价 + 手续费
    for (int i = 1; i < prices.length; i++) {
        // 情况1：当前价格 > 最低成本，卖出获利
        if (prices[i] > minCost) {
            maxProfit += prices[i] - minCost;
            // 更新成本为当前价格（模拟“卖出后立即买入”，后续若涨价可继续获利，实际不卖）
            minCost = prices[i];
        }
        // 情况2：当前买入成本（价格+手续费）更低，更新最低成本
        if (prices[i] + fee < minCost) {
            minCost = prices[i] + fee;
        }
    }
    return maxProfit;
}
```

#### 示例
- 输入：`prices = [1,3,2,8,4,9], fee = 2` → 输出：`8`（1买8卖，4买9卖，利润 `(8-1-2)+(9-4-2)=5+3=8`）；
- 复杂度：`O(n)` 时间，`O(1)` 空间；
- 优势：无需记录持仓状态，直接通过成本优化实现贪心决策，避免频繁交易。
