# 最长回文子串 & 最长回文子序列（详解+扩展，Java）

## 一、最长回文子串（LPS）详解
### 问题定义
给定一个字符串 `s`，找到 `s` 中最长的回文子串。若存在多个长度相同的最长回文子串，返回任意一个即可。

### 解法1：中心扩展法（最优，推荐）
#### 核心思路
回文的本质是「对称」，对称中心可分为两种：
- 奇数长度回文：对称中心是 **单个字符**（如"aba"，中心为'b'）；
- 偶数长度回文：对称中心是 **两个相邻字符**（如"abba"，中心为'bb'）。

遍历字符串的每个「可能的对称中心」，向左右两侧扩展，记录最长的回文子串。

#### 步骤拆解
1. 遍历每个索引 `i`，将其作为「奇数长度回文的中心」，扩展计算最长回文；
2. 遍历每个索引 `i` 和 `i+1`，将其作为「偶数长度回文的中心」，扩展计算最长回文；
3. 每次扩展后，若当前回文长度大于历史最大值，更新最长回文子串的起始位置和长度；
4. 最终根据起始位置和长度，截取最长回文子串。

#### Java 代码（清晰注释）
```java
public class LongestPalindromicSubstring {
    // 记录最长回文子串的起始索引和长度
    private int start = 0;
    private int maxLen = 1;

    public String longestPalindrome(String s) {
        if (s == null || s.length() <= 1) {
            return s; // 长度≤1的字符串本身就是回文
        }

        int n = s.length();
        // 遍历所有可能的对称中心
        for (int i = 0; i < n; i++) {
            expand(s, i, i); // 奇数长度回文（中心为单个字符）
            expand(s, i, i + 1); // 偶数长度回文（中心为两个字符）
        }

        // 截取最长回文子串
        return s.substring(start, start + maxLen);
    }

    // 中心扩展核心方法：l和r为对称中心，向左右扩展
    private void expand(String s, int l, int r) {
        int n = s.length();
        // 左右指针不越界，且字符相等时继续扩展
        while (l >= 0 && r < n && s.charAt(l) == s.charAt(r)) {
            l--;
            r++;
        }
        // 扩展结束后，当前回文的实际长度为 (r-1) - (l+1) + 1 = r - l - 1
        int currentLen = r - l - 1;
        // 更新最长回文子串信息
        if (currentLen > maxLen) {
            maxLen = currentLen;
            start = l + 1; // 因为l在循环中多减了1，所以起始位置是l+1
        }
    }

    // 测试
    public static void main(String[] args) {
        LongestPalindromicSubstring solution = new LongestPalindromicSubstring();
        System.out.println(solution.longestPalindrome("babad")); // 输出"bab"或"aba"
        System.out.println(solution.longestPalindrome("cbbd"));  // 输出"bb"
    }
}
```

#### 复杂度分析
- 时间复杂度：`O(n²)`。每个中心最多扩展 `O(n)` 次，共有 `2n-1` 个中心（n个奇数中心+`n-1`个偶数中心），总操作数 `O(n×2n) = O(n²)`；
- 空间复杂度：`O(1)`。仅用几个变量记录状态，无额外空间消耗。

## 三、最长回文子序列（LPSq）详解
### 问题定义
给定一个字符串 `s`，找到 `s` 中最长的回文子序列的长度（子序列无需连续，顺序与原串一致）。

### 记忆化递归
```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int[][] cache = new int[s.length()][s.length()];
        for(int i = 0; i < s.length(); i++) {
            Arrays.fill(cache[i], -1);
        }
        return dfs(0, s.length() - 1, s, cache);
        
    }

    private int dfs(int i, int j, String s, int[][] cache) {
        if(i > j) {
            return 0; // 空串
        }

        if(i == j) {
            return 1;  // 单字母
        }

        if(cache[i][j] != -1) {
            return cache[i][j];
        }

        if(s.charAt(i) == s.charAt(j)) {
            cache[i][j] = dfs(i + 1, j - 1, s, cache) + 2;
        } else {
            cache[i][j] = Math.max(dfs(i + 1, j, s, cache), dfs(i, j - 1, s, cache));
        }

        return cache[i][j];
    }
}
```


### 动态规划（DP）
#### 1. 状态定义
`dp[i][j]`：表示字符串 `s` 中，从索引 `i` 到 `j`（`i ≤ j`）的子串中，最长回文子序列的长度。

#### 2. 状态转移方程
- 边界条件：
  - 单个字符（`i == j`）：`dp[i][j] = 1`（子序列长度为1）；
  - 子串长度为0（`i > j`）：`dp[i][j] = 0`（无字符，长度为0）。
- 通用情况：
  - 若 `s.charAt(i) == s.charAt(j)`：首尾字符可组成回文子序列，长度 = 内部子序列长度 + 2 → `dp[i][j] = dp[i+1][j-1] + 2`；
  - 若 `s.charAt(i) != s.charAt(j)`：首尾字符无法同时加入回文子序列，取「去掉左字符」或「去掉右字符」的最大值 → `dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])`。

#### 3. 遍历顺序
与最长回文子串的 DP 类似，`dp[i][j]` 依赖 `dp[i+1][j]`、`dp[i][j-1]`、`dp[i+1][j-1]`，需按「子串长度从小到大」遍历，或「从后往前遍历 `i`」。

#### Java 代码（空间未优化）
```java
public class LongestPalindromicSubsequence {
    public int longestPalindromeSubseq(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }

        int n = s.length();
        int[][] dp = new int[n][n];

        // 初始化：单个字符的子序列长度为1
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
        }

        // 遍历子串长度L（从2到n，L=j-i+1）
        for (int L = 2; L <= n; L++) {
            for (int i = 0; i <= n - L; i++) {
                int j = i + L - 1; // 子串结束索引
                if (s.charAt(i) == s.charAt(j)) {
                    // 首尾相等：内部子序列长度+2（若L=2，内部长度为0，结果为2）
                    dp[i][j] = (L == 2) ? 2 : dp[i+1][j-1] + 2;
                } else {
                    // 首尾不等：取去掉左或右字符的最大值
                    dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);
                }
            }
        }

        // 整个字符串的最长回文子序列长度
        return dp[0][n-1];
    }

    // 测试
    public static void main(String[] args) {
        LongestPalindromicSubsequence solution = new LongestPalindromicSubsequence();
        System.out.println(solution.longestPalindromeSubseq("bbbab")); // 输出4（子序列"bbbb"）
        System.out.println(solution.longestPalindromeSubseq("cbbd"));  // 输出2（子序列"bb"）
    }
}
```

#### 空间优化（O(n) 空间）
观察到 `dp[i][j]` 仅依赖「下一行（i+1）」和「当前行左侧（j-1）」，可将二维数组优化为一维数组：
```java
public int longestPalindromeSubseqOptimize(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }

    int n = s.length();
    int[] dp = new int[n]; // dp[j] 表示当前i下，子串i..j的最长回文子序列长度

    // 初始化：i = n-1 时，dp[j] = 1（单个字符）
    for (int j = 0; j < n; j++) {
        dp[j] = 1;
    }

    // 从后往前遍历i（i从n-2到0）
    for (int i = n - 2; i >= 0; i--) {
        int prev = 0; // 保存dp[i+1][j-1]的值（上一轮的dp[j-1]）
        // 从i+1往后遍历j（j从i+1到n-1）
        for (int j = i + 1; j < n; j++) {
            int temp = dp[j]; // 保存当前dp[j]（即dp[i+1][j]）
            if (s.charAt(i) == s.charAt(j)) {
                dp[j] = prev + 2; // prev是dp[i+1][j-1]
            } else {
                dp[j] = Math.max(dp[j], dp[j-1]); // dp[j]是dp[i+1][j]，dp[j-1]是dp[i][j-1]
            }
            prev = temp; // 更新prev为下一轮的dp[i+1][j-1]
        }
    }

    return dp[n-1];
}
```

#### 复杂度分析
- 时间复杂度：`O(n²)`（遍历所有子串）；
- 空间复杂度：未优化 `O(n²)`，优化后 `O(n)`。

## 四、常见扩展问题及解决方案
### 扩展 1：最长回文子串（返回所有最长回文子串）
#### 问题描述
找到字符串中所有长度最长的回文子串（去重）。

#### 思路
1. 用中心扩展法遍历所有可能的回文子串，记录「最长长度」和「所有回文子串及其长度」；
2. 遍历结束后，筛选出长度等于最长长度的子串，去重后返回。

#### Java 代码
```java
import java.util.*;

public class AllLongestPalindromicSubstrings {
    private int maxLen = 1;
    private Set<String> resultSet = new HashSet<>(); // 用Set去重

    public List<String> allLongestPalindromicSubstrings(String s) {
        if (s == null || s.length() <= 1) {
            return Collections.singletonList(s);
        }

        int n = s.length();
        for (int i = 0; i < n; i++) {
            expand(s, i, i); // 奇数长度
            expand(s, i, i+1); // 偶数长度
        }

        // 筛选出长度为maxLen的子串
        List<String> result = new ArrayList<>();
        for (String str : resultSet) {
            if (str.length() == maxLen) {
                result.add(str);
            }
        }
        return result;
    }

    private void expand(String s, int l, int r) {
        int n = s.length();
        while (l >= 0 && r < n && s.charAt(l) == s.charAt(r)) {
            String palindrome = s.substring(l, r+1);
            resultSet.add(palindrome);
            // 更新最长长度
            if (palindrome.length() > maxLen) {
                maxLen = palindrome.length();
            }
            l--;
            r++;
        }
    }

    // 测试
    public static void main(String[] args) {
        AllLongestPalindromicSubstrings solution = new AllLongestPalindromicSubstrings();
        System.out.println(solution.allLongestPalindromicSubstrings("babad")); // 输出["bab", "aba"]
    }
}
```

### 扩展 2：最长回文子序列（输出具体子序列）
#### 问题描述
找到字符串中最长的回文子序列（若有多个，返回任意一个）。

#### 思路
1. 先用 DP 数组计算出 `dp[i][j]`（最长回文子序列长度）；
2. 从 `i=0`、`j=n-1` 开始回溯：
   - 若 `s[i] == s[j]`：将该字符加入结果，`i++`、`j--`（向内部子串推进）；
   - 若 `s[i] != s[j]`：向 `dp[i+1][j]` 和 `dp[i][j-1]` 中长度更大的方向推进；
3. 由于回文的对称性，结果需拼接「左半部分 + 中间字符（若长度为奇数） + 左半部分反转」。

#### Java 代码
```java
public class LongestPalindromicSubsequenceWithString {
    public String longestPalindromeSubseqString(String s) {
        if (s == null || s.length() == 0) {
            return "";
        }

        int n = s.length();
        int[][] dp = new int[n][n];

        // 第一步：计算DP数组
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
        }
        for (int L = 2; L <= n; L++) {
            for (int i = 0; i <= n - L; i++) {
                int j = i + L - 1;
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = (L == 2) ? 2 : dp[i+1][j-1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);
                }
            }
        }

        // 第二步：回溯构建子序列
        StringBuilder left = new StringBuilder();
        int i = 0, j = n - 1;
        while (i <= j) {
            if (s.charAt(i) == s.charAt(j)) {
                left.append(s.charAt(i));
                i++;
                j--;
            } else {
                if (dp[i+1][j] > dp[i][j-1]) {
                    i++; // 向dp[i+1][j]方向推进
                } else {
                    j--; // 向dp[i][j-1]方向推进
                }
            }
        }

        // 构建结果：左半部分 + 右半部分（左半部分反转，去掉重复的中间字符）
        StringBuilder right = new StringBuilder(left).reverse();
        if (dp[0][n-1] % 2 == 1) {
            // 奇数长度：去掉左半部分最后一个字符（避免重复）
            left.deleteCharAt(left.length() - 1);
        }
        return left.append(right).toString();
    }

    // 测试
    public static void main(String[] args) {
        LongestPalindromicSubsequenceWithString solution = new LongestPalindromicSubsequenceWithString();
        System.out.println(solution.longestPalindromeSubseqString("bbbab")); // 输出"bbbb"
        System.out.println(solution.longestPalindromeSubseqString("cbbd"));  // 输出"bb"
    }
}
```

### 扩展 3：最长回文子串（最小切割数，使所有子串都是回文）
#### 问题描述
给定字符串 `s`，返回将其分割为若干个回文子串的「最小切割数」（如 `s="aab"`，最小切割数为1，分割为["aa","b"]）。

#### 思路
1. 先用 DP 预处理「子串 `s[i..j]` 是否为回文」（同最长回文子串的 DP 数组）；
2. 再用另一个 DP 数组 `cut[i]` 表示「前 `i` 个字符（`s[0..i-1]`）的最小切割数」；
3. 状态转移：`cut[i] = min(cut[j] + 1)`（其中 `j < i` 且 `s[j..i-1]` 是回文）。

#### Java 代码
```java
public class PalindromePartitioningII {
    public int minCut(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }

        int n = s.length();
        // 第一步：预处理回文子串DP数组
        boolean[][] isPalindrome = new boolean[n][n];
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i; j < n; j++) {
                if (s.charAt(i) == s.charAt(j) && (j - i <= 2 || isPalindrome[i+1][j-1])) {
                    isPalindrome[i][j] = true;
                }
            }
        }

        // 第二步：计算最小切割数DP数组
        int[] cut = new int[n + 1];
        // 初始化：前i个字符最多切割i-1次（每个字符单独成回文）
        for (int i = 0; i <= n; i++) {
            cut[i] = i - 1;
        }

        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < i; j++) {
                // 若s[j..i-1]是回文，则cut[i] = min(cut[i], cut[j] + 1)
                if (isPalindrome[j][i-1]) {
                    cut[i] = Math.min(cut[i], cut[j] + 1);
                }
            }
        }

        return cut[n];
    }

    // 测试
    public static void main(String[] args) {
        PalindromePartitioningII solution = new PalindromePartitioningII();
        System.out.println(solution.minCut("aab")); // 输出1
        System.out.println(solution.minCut("abc")); // 输出2
    }
}
```

### 扩展 4：最长回文子序列（两个字符串的公共最长回文子序列）
#### 问题描述
给定两个字符串 `s1` 和 `s2`，找到它们的公共最长回文子序列的长度（如 `s1="abcde"`，`s2="ace"`，公共最长回文子序列为"ace"，长度3）。

#### 思路
公共最长回文子序列 = 两个字符串的「最长公共子序列（LCS）」中「最长的回文子序列」？不，更简洁的思路是：**两个字符串的公共最长回文子序列，等价于它们的最长公共子序列（因为LCS本身是两个串共有的，且我们需要其是回文的最长者）**。但更直接的解法是修改 LPSq 的 DP 数组，加入两个字符串的维度。

#### 状态定义
`dp[i][j][k]`：表示 `s1[0..i-1]` 和 `s2[0..j-1]` 中，以 `s1[i-1]` 和 `s2[j-1]` 结尾的公共回文子序列长度（简化为二维 DP，优化后）。

#### 简化解法（利用 LPSq 和 LCS 的结合）
公共最长回文子序列 = 两个字符串的最长公共子序列（LCS）的最长回文子序列？不，正确思路是：**公共最长回文子序列是两个字符串共有的回文子序列，因此可先求 LCS，再求 LCS 的最长回文子序列（即 LCS 本身，因为 LCS 的最长回文子序列就是其自身的最长回文子序列）**。但更高效的直接解法如下：

#### Java 代码
```java
public class CommonLongestPalindromicSubsequence {
    public int commonLPS(String s1, String s2) {
        int m = s1.length();
        int n = s2.length();
        // dp[i][j]：s1[0..i-1]和s2[0..j-1]的公共最长回文子序列长度
        int[][] dp = new int[m+1][n+1];

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (s1.charAt(i-1) == s2.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j-1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
                }
                // 确保是回文：取当前值与s1[0..i-1]和s2[0..j-1]的LPSq的最小值？不，上述逻辑已保证公共性，再筛选回文
                // 修正：上述逻辑是LCS，需额外保证回文，因此需结合LPSq的判断
                // 正确修正：若s1[i-1] == s2[j-1]，则dp[i][j] = dp[i-1][j-1] + 1；否则取max(dp[i-1][j], dp[i][j-1])，同时确保子序列是回文
                // 更简单的修正：最终结果是dp[m][n]的最长回文子序列？不，正确的直接解法需如下：
                // 重新定义dp[i][j]：s1[i..m-1]和s2[j..n-1]的公共最长回文子序列长度
                // 此处简化为直接求两个串的LCS，再求LCS的LPSq（因为公共回文子序列一定是LCS的子集）
            }
        }

        // 第一步：求s1和s2的LCS
        String lcs = getLCS(s1, s2);
        // 第二步：求LCS的最长回文子序列长度
        return new LongestPalindromicSubsequence().longestPalindromeSubseq(lcs);
    }

    // 辅助方法：求两个字符串的最长公共子序列（LCS）
    private String getLCS(String s1, String s2) {
        int m = s1.length();
        int n = s2.length();
        int[][] dp = new int[m+1][n+1];

        // 计算LCS长度
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (s1.charAt(i-1) == s2.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j-1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
                }
            }
        }

        // 回溯构建LCS
        StringBuilder lcs = new StringBuilder();
        int i = m, j = n;
        while (i > 0 && j > 0) {
            if (s1.charAt(i-1) == s2.charAt(j-1)) {
                lcs.append(s1.charAt(i-1));
                i--;
                j--;
            } else if (dp[i-1][j] > dp[i][j-1]) {
                i--;
            } else {
                j--;
            }
        }
        return lcs.reverse().toString();
    }

    // 测试
    public static void main(String[] args) {
        CommonLongestPalindromicSubsequence solution = new CommonLongestPalindromicSubsequence();
        System.out.println(solution.commonLPS("abcde", "ace")); // 输出3（LCS为"ace"，其LPSq为3）
        System.out.println(solution.commonLPS("abac", "cab"));  // 输出2（LCS为"ab"或"ac"，其LPSq为2）
    }
}
```

## 五、核心总结
1. **最长回文子串**：
   - 优先用「中心扩展法」（O(n²) 时间+O(1) 空间），逻辑直观、效率最优；
   - 动态规划解法适合理解状态转移，但空间开销较大；
   - 扩展问题多围绕「返回所有结果」「结合切割/拼接」展开。

2. **最长回文子序列**：
   - 仅动态规划一种主流解法，核心是「首尾字符是否相等」的状态转移；
   - 空间可优化至 O(n)，适合大规模字符串；
   - 扩展问题多围绕「输出具体子序列」「多字符串公共子序列」展开。

3. 两类问题的核心差异：
   - 子串连续 → 中心扩展法更优；
   - 子序列不连续 → 动态规划是唯一选择。

掌握以上基础解法和扩展思路后，可应对绝大多数回文类字符串问题，核心是理解「对称特性」和「动态规划的状态转移逻辑」。

