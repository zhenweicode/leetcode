# 最长回文子串 & 最长回文子序列（详解+扩展，Java）

## 一、最长回文子串（LPS）详解
### 问题定义
给定一个字符串 `s`，找到 `s` 中最长的回文子串。若存在多个长度相同的最长回文子串，返回任意一个即可。

### 解法1：中心扩展法（最优，推荐）
#### 核心思路
回文的本质是「对称」，对称中心可分为两种：
- 奇数长度回文：对称中心是 **单个字符**（如"aba"，中心为'b'）；
- 偶数长度回文：对称中心是 **两个相邻字符**（如"abba"，中心为'bb'）。

遍历字符串的每个「可能的对称中心」，向左右两侧扩展，记录最长的回文子串。

#### 步骤拆解
1. 遍历每个索引 `i`，将其作为「奇数长度回文的中心」，扩展计算最长回文；
2. 遍历每个索引 `i` 和 `i+1`，将其作为「偶数长度回文的中心」，扩展计算最长回文；
3. 每次扩展后，若当前回文长度大于历史最大值，更新最长回文子串的起始位置和长度；
4. 最终根据起始位置和长度，截取最长回文子串。

#### Java 代码（清晰注释）
```java
public class LongestPalindromicSubstring {
    // 记录最长回文子串的起始索引和长度
    private int start = 0;
    private int maxLen = 1;

    public String longestPalindrome(String s) {
        if (s == null || s.length() <= 1) {
            return s; // 长度≤1的字符串本身就是回文
        }

        int n = s.length();
        // 遍历所有可能的对称中心
        for (int i = 0; i < n; i++) {
            expand(s, i, i); // 奇数长度回文（中心为单个字符）
            expand(s, i, i + 1); // 偶数长度回文（中心为两个字符）
        }

        // 截取最长回文子串
        return s.substring(start, start + maxLen);
    }

    // 中心扩展核心方法：l和r为对称中心，向左右扩展
    private void expand(String s, int l, int r) {
        int n = s.length();
        // 左右指针不越界，且字符相等时继续扩展
        while (l >= 0 && r < n && s.charAt(l) == s.charAt(r)) {
            l--;
            r++;
        }
        // 扩展结束后，当前回文的实际长度为 (r-1) - (l+1) + 1 = r - l - 1
        int currentLen = r - l - 1;
        // 更新最长回文子串信息
        if (currentLen > maxLen) {
            maxLen = currentLen;
            start = l + 1; // 因为l在循环中多减了1，所以起始位置是l+1
        }
    }

    // 测试
    public static void main(String[] args) {
        LongestPalindromicSubstring solution = new LongestPalindromicSubstring();
        System.out.println(solution.longestPalindrome("babad")); // 输出"bab"或"aba"
        System.out.println(solution.longestPalindrome("cbbd"));  // 输出"bb"
    }
}
```

#### 复杂度分析
- 时间复杂度：`O(n²)`。每个中心最多扩展 `O(n)` 次，共有 `2n-1` 个中心（n个奇数中心+`n-1`个偶数中心），总操作数 `O(n×2n) = O(n²)`；
- 空间复杂度：`O(1)`。仅用几个变量记录状态，无额外空间消耗。

## 三、最长回文子序列（LPSq）详解
### 问题定义
给定一个字符串 `s`，找到 `s` 中最长的回文子序列的长度（子序列无需连续，顺序与原串一致）。

### 记忆化递归
```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int[][] cache = new int[s.length()][s.length()];
        for(int i = 0; i < s.length(); i++) {
            Arrays.fill(cache[i], -1);
        }
        return dfs(0, s.length() - 1, s, cache);
        
    }

    private int dfs(int i, int j, String s, int[][] cache) {
        if(i > j) {
            return 0; // 空串
        }

        if(i == j) {
            return 1;  // 单字母
        }

        if(cache[i][j] != -1) {
            return cache[i][j];
        }

        if(s.charAt(i) == s.charAt(j)) {
            cache[i][j] = dfs(i + 1, j - 1, s, cache) + 2;
        } else {
            cache[i][j] = Math.max(dfs(i + 1, j, s, cache), dfs(i, j - 1, s, cache));
        }

        return cache[i][j];
    }
}
```


### 动态规划（DP）
#### 1. 状态定义
`dp[i][j]`：表示字符串 `s` 中，从索引 `i` 到 `j`（`i ≤ j`）的子串中，最长回文子序列的长度。

#### 2. 状态转移方程
- 边界条件：
  - 单个字符（`i == j`）：`dp[i][j] = 1`（子序列长度为1）；
  - 子串长度为0（`i > j`）：`dp[i][j] = 0`（无字符，长度为0）。
- 通用情况：
  - 若 `s.charAt(i) == s.charAt(j)`：首尾字符可组成回文子序列，长度 = 内部子序列长度 + 2 → `dp[i][j] = dp[i+1][j-1] + 2`；
  - 若 `s.charAt(i) != s.charAt(j)`：首尾字符无法同时加入回文子序列，取「去掉左字符」或「去掉右字符」的最大值 → `dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])`。

#### 3. 遍历顺序
这段代码的循环顺序是 **`i` 从 `n-1` 倒序遍历到 `0`，`j` 从 `i+1` 正序遍历到 `n-1`**，其合理性源于**状态转移的依赖关系**：

- 为什么 `i` 要倒序？
计算 `f[i][j]` 时，需要用到 `f[i+1][j-1]` 和 `f[i+1][j]`（即**下一行 `i+1` 的状态**）。如果 `i` 正序遍历（从 `0` 到 `n-1`），那么 `i+1` 的状态还未计算，会导致依赖的状态无效。
因此，`i` 必须**倒序遍历**（从 `n-1` 到 `0`），确保计算 `f[i][j]` 时，`i+1` 对应的状态已经被计算过。


- 为什么 `j` 从 `i+1` 开始？
状态定义中 `f[i][j]` 要求 `i ≤ j`（子串的起始索引不能大于结束索引）。当 `i == j` 时，子串是单个字符，最长回文子序列长度为 `1`（已在代码中通过 `f[i][i] = 1` 初始化）。
因此，只有当 `i < j` 时才需要通过转移方程计算，所以 `j` 从 `i+1` 开始遍历，保证 `j > i`。


- 为什么 `j` 正序？
计算 `f[i][j]` 时，需要用到 `f[i][j-1]`（即**当前行 `j-1` 的状态**）。如果 `j` 倒序遍历，`j-1` 的状态还未计算，会导致依赖的状态无效。
因此，`j` 必须**正序遍历**（从 `i+1` 到 `n-1`），确保计算 `f[i][j]` 时，`j-1` 对应的状态已经被计算过。

```java
class Solution {
    public int longestPalindromeSubseq(String S) {
        char[] s = S.toCharArray();
        int n = s.length;
        int[][] f = new int[n][n]; // 状态数组，f[i][j]表示i到j子串的最长回文子序列长度
        
        // 外层循环：i从n-1倒序遍历到0
        for (int i = n - 1; i >= 0; i--) {
            f[i][i] = 1; // 初始化：单个字符的子序列长度为1
            // 内层循环：j从i+1正序遍历到n-1
            for (int j = i + 1; j < n; j++) {
                // 状态转移：根据首尾字符是否相等分情况
                if (s[i] == s[j]) {
                    f[i][j] = f[i + 1][j - 1] + 2;
                } else {
                    f[i][j] = Math.max(f[i + 1][j], f[i][j - 1]);
                }
            }
        }
        return f[0][n - 1]; // 整个字符串的最长回文子序列长度
    }
}
```

空间优化
把 f 数组的第一个维度去掉。相当于把 f[i] 和 f[i+1] 保存到同一个一维数组中。

但一个萝卜一个坑，f[j−1] 要么保存的是 f[i+1][j−1]，要么保存的是 f[i][j−1]，怎么妥当地处理新旧数据？对于本题来说，可以用变量 pre 记录 f[i+1][j−1] 的值。计算到 f[j] 时，f[j−1] 保存的是新数据 f[i][j−1]，旧数据 f[i+1][j−1] 可以从 pre 中取到。

```java
class Solution {
    public int longestPalindromeSubseq(String S) {
        char[] s = S.toCharArray();
        int n = s.length;
        int[] f = new int[n];
        for (int i = n - 1; i >= 0; i--) {
            f[i] = 1;
            int pre = 0; // 初始值为 f[i+1][i]
            for (int j = i + 1; j < n; j++) {
                int tmp = f[j];
                f[j] = s[i] == s[j] ? pre + 2 : Math.max(f[j], f[j - 1]);
                pre = tmp;
            }
        }
        return f[n - 1];
    }
}
```
