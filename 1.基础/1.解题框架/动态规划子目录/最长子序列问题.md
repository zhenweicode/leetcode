https://leetcode.cn/problems/longest-common-subsequence/description/?envType=study-plan-v2&envId=top-100-liked

# 最长公共子序列（LCS）问题详细解读：从递归到动态规划最优解
最长公共子序列（Longest Common Subsequence，简称 LCS）是动态规划领域的经典问题，核心是找到两个字符串中「顺序一致但不一定连续」的最长子序列长度。本文将从「问题定义→暴力递归→记忆化递归→二维DP→空间优化」逐步推导，同时补充「输出LCS具体序列」和「最长公共子串（连续）」的拓展解法。

## 一、问题定义
### 1. 核心概念
- **子序列**：从字符串中删除任意个字符（可删除0个），不改变剩余字符顺序得到的序列（如 `abc` 的子序列有 `a`、`ac`、`abc` 等）。
- **公共子序列**：两个字符串共有的子序列（如 `abcde` 和 `ace` 的公共子序列有 `a`、`c`、`e`、`ace` 等）。
- **最长公共子序列**：所有公共子序列中长度最大的那个（上例中 `ace` 是 LCS，长度为3）。

### 2. 输入输出示例
| 输入                          | 输出 | 说明                     |
|-------------------------------|------|--------------------------|
| `text1 = "abcde", text2 = "ace"` | 3    | LCS 为 `"ace"`           |
| `text1 = "abc", text2 = "abc"`   | 3    | LCS 为 `"abc"`           |
| `text1 = "abc", text2 = "def"`   | 0    | 无公共子序列             |

### 3. 问题本质
LCS 问题的关键是「子结构重叠」和「最优子结构」：
- 子结构重叠：求解大问题时，需要重复求解多个小问题（如求 `LCS(abcde, ace)` 需先求 `LCS(abcd, ac)` 等）。
- 最优子结构：大问题的最优解（最长长度）由小问题的最优解推导而来。

## 二、方法一：暴力递归（基础思路，超时）
### 1. 递归思路
从两个字符串的末尾开始，分两种情况讨论：
1. 若 `text1[i] == text2[j]`：当前字符是公共子序列的一部分，LCS 长度 = 1 + 子问题 `LCS(text1[0..i-1], text2[0..j-1])` 的长度。
2. 若 `text1[i] != text2[j]`：当前字符不同，LCS 长度 = 子问题 `LCS(text1[0..i-1], text2[0..j-1])`、`LCS(text1[0..i], text2[0..j-1])`、`LCS(text1[0..i-1], text2[0..j])` 中的最大值（后两者已包含前者，可简化为取后两者最大值）。

### 2. 递归边界
- 若 `i < 0` 或 `j < 0`（任一字符串为空），LCS 长度为 0。

### 3. 代码实现
```java
public int longestCommonSubsequence(String text1, String text2) {
    int m = text1.length();
    int n = text2.length();
    return dfs(text1, text2, m - 1, n - 1);
}

private int dfs(String text1, String text2, int i, int j) {
    if (i < 0 || j < 0) return 0;
    if (text1.charAt(i) == text2.charAt(j)) {
        return 1 + dfs(text1, text2, i - 1, j - 1);
    } else {
        return Math.max(dfs(text1, text2, i - 1, j), dfs(text1, text2, i, j - 1));
    }
}
```

### 4. 复杂度分析
- 时间复杂度：\( O(2^{m+n}) \)。每个递归调用产生 2 个分支，存在大量重复子问题。
- 空间复杂度：\( O(m+n) \)。递归栈深度为两个字符串长度之和。

### 5. 结论
暴力递归因重复子问题效率极低，仅适用于理解基础逻辑，无法处理长度超过 20 的字符串。

## 三、方法二：记忆化递归（优化重复子问题）
### 1. 优化思路
用「备忘录」存储已求解的子问题结果，避免重复计算。当再次遇到相同 `(i,j)` 时，直接返回备忘录中的值。

### 2. 备忘录设计
使用二维数组 `memo[i][j]` 存储 `text1[0..i]` 和 `text2[0..j]` 的 LCS 长度，初始值为 `-1`（表示未求解）。

### 3. 代码实现
```java
import java.util.Arrays;

public int longestCommonSubsequence(String text1, String text2) {
    int m = text1.length();
    int n = text2.length();
    int[][] memo = new int[m][n];
    for (int[] row : memo) Arrays.fill(row, -1);
    return dfsWithMemo(text1, text2, m - 1, n - 1, memo);
}

private int dfsWithMemo(String text1, String text2, int i, int j, int[][] memo) {
    if (i < 0 || j < 0) return 0;
    if (memo[i][j] != -1) return memo[i][j];
    if (text1.charAt(i) == text2.charAt(j)) {
        memo[i][j] = 1 + dfsWithMemo(text1, text2, i - 1, j - 1, memo);
    } else {
        memo[i][j] = Math.max(
            dfsWithMemo(text1, text2, i - 1, j, memo),
            dfsWithMemo(text1, text2, i, j - 1, memo)
        );
    }
    return memo[i][j];
}
```

### 4. 复杂度分析
- 时间复杂度：\( O(m \times n) \)。每个子问题 `(i,j)` 仅计算一次。
- 空间复杂度：\( O(m \times n + m + n) \)。备忘录占 \( O(m \times n) \)，递归栈占 \( O(m+n) \)。

### 5. 结论
解决了重复子问题，效率大幅提升，但仍存在递归栈溢出风险（如字符串长度超过 1000），需转化为迭代的动态规划。

## 四、方法三：二维动态规划（迭代版，最优解基础）
### 1. 状态定义（核心）
将递归子问题转化为 DP 数组状态：
- 定义 `dp[i][j]` 表示 `text1[0..i-1]`（前 `i` 个字符）和 `text2[0..j-1]`（前 `j` 个字符）的 LCS 长度。
- 设计初衷：`i=0` 或 `j=0` 表示任一字符串为空，LCS 长度为 0，简化边界处理。

### 2. 状态转移方程
基于递归逻辑推导：
1. 若 `text1[i-1] == text2[j-1]`（当前字符相同）：
   \[ dp[i][j] = dp[i-1][j-1] + 1 \]
   解释：当前字符是公共子序列的一部分，长度 = 前 `i-1` 和 `j-1` 个字符的 LCS 长度 + 1。
2. 若 `text1[i-1] != text2[j-1]`（当前字符不同）：
   \[ dp[i][j] = \max(dp[i-1][j], dp[i][j-1]) \]
   解释：取「前 `i-1` 个字符与前 `j` 个字符的 LCS」和「前 `i` 个字符与前 `j-1` 个字符的 LCS」中的最大值。

### 3. 初始化
- `dp[0][j] = 0`（`text1` 为空，LCS 长度为 0）。
- `dp[i][0] = 0`（`text2` 为空，LCS 长度为 0）。

### 4. 填表顺序
从 `i=1` 到 `m`，`j=1` 到 `n`（行优先或列优先均可），因为 `dp[i][j]` 依赖左上、上、左三个已计算状态。

### 5. 示例填表过程（`text1="abcde", text2="ace"`）
`m=5`，`n=3`，DP 表为 `6×4`（`i=0~5`，`j=0~3`）：

| `dp[i][j]` | `j=0`（空串） | `j=1`（"a"） | `j=2`（"ac"） | `j=3`（"ace"） |
|------------|---------------|--------------|---------------|----------------|
| `i=0`（空串） | 0             | 0            | 0             | 0              |
| `i=1`（"a"）  | 0             | 1（a==a）    | 1（max(1,0)） | 1（max(1,0)）  |
| `i=2`（"ab"） | 0             | 1（max(0,1)）| 1（a≠c）      | 1（max(1,1)）  |
| `i=3`（"abc"）| 0             | 1（max(0,1)）| 2（c==c）     | 2（max(2,1)）  |
| `i=4`（"abcd"）| 0             | 1            | 2             | 2（max(2,2)）  |
| `i=5`（"abcde"）| 0            | 1            | 2             | 3（e==e）      |

最终 `dp[5][3] = 3`，与预期一致。

### 6. 代码实现
```java
public int longestCommonSubsequence(String text1, String text2) {
    int m = text1.length();
    int n = text2.length();
    int[][] dp = new int[m + 1][n + 1];
    
    for (int i = 1; i <= m; i++) {
        char c1 = text1.charAt(i - 1);
        for (int j = 1; j <= n; j++) {
            char c2 = text2.charAt(j - 1);
            if (c1 == c2) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
}
```

### 7. 复杂度分析
- 时间复杂度：\( O(m \times n) \)。遍历 `(m+1)×(n+1)` 个状态，每个状态计算耗时 \( O(1) \)。
- 空间复杂度：\( O(m \times n) \)。DP 表占用 `(m+1)×(n+1)` 空间。

### 8. 结论
二维 DP 解决了递归栈溢出问题，效率稳定，是 LCS 问题的基础最优解。

## 五、方法四：空间优化（一维动态规划）
### 1. 优化思路
观察状态转移方程：`dp[i][j]` 仅依赖左上（`dp[i-1][j-1]`）、上（`dp[i-1][j]`）、左（`dp[i][j-1]`）三个状态。用一维数组 `dp[j]` 覆盖存储，需额外保存「左上」值避免被覆盖。

### 2. 一维 DP 状态定义
- `dp[j]` 表示当前处理到 `text1` 第 `i` 个字符时，`text1[0..i-1]` 与 `text2[0..j-1]` 的 LCS 长度。

### 3. 状态转移与变量保存
- 用 `prev` 保存 `dp[i-1][j-1]`（上一行的 `dp[j-1]`）。
- 遍历 `j` 从 1 到 `n` 时：
  1. 保存当前 `dp[j]` 到 `temp`（下一轮的 `prev`）。
  2. 若字符相同，`dp[j] = prev + 1`；否则，`dp[j] = max(dp[j], dp[j-1])`。
  3. 更新 `prev = temp`。

### 4. 代码实现
```java
import java.util.Arrays;

public int longestCommonSubsequence(String text1, String text2) {
    int m = text1.length();
    int n = text2.length();
    // 优化：用较短字符串长度作为一维数组长度
    if (m < n) return longestCommonSubsequence(text2, text1);
    int[] dp = new int[n + 1];   // 注意这里，是按照第二个字符串长度遍历，即按照列遍历
    
    for (int i = 1; i <= m; i++) {
        char c1 = text1.charAt(i - 1);
        int prev = 0; // 初始为 dp[i-1][0] = 0
        for (int j = 1; j <= n; j++) {
            char c2 = text2.charAt(j - 1);
            int temp = dp[j]; // 保存上一行的 dp[j]
            dp[j] = (c1 == c2) ? prev + 1 : Math.max(dp[j], dp[j - 1]);
            prev = temp; // 更新 prev 为下一轮的左上值
        }
    }
    return dp[n];
}
```

### 5. 复杂度分析
- 时间复杂度：\( O(m \times n) \)。与二维 DP 一致。
- 空间复杂度：\( O(\min(m, n)) \)。最优空间复杂度，适合超长字符串。

### 6. 结论
一维 DP 在不损失时间效率的前提下，大幅降低空间复杂度，是工业级最优解。

## 六、拓展一：输出 LCS 具体序列
上述方法仅求长度，若需输出具体序列，可通过二维 DP 表「回溯」推导：
1. 从 `dp[m][n]` 开始，`i = m`，`j = n`。
2. 若 `text1[i-1] == text2[j-1]`：当前字符是 LCS 的一部分，加入结果集，`i--` 且 `j--`。
3. 若不相等：
   - 若 `dp[i-1][j] > dp[i][j-1]`：向 `i--` 移动（上一行更优）。
   - 否则：向 `j--` 移动（左一列更优）。
4. 重复步骤 2-3，直到 `i == 0` 或 `j == 0`，反转结果集（因回溯是从后向前收集）。

### 代码实现
```java
public String getLCS(String text1, String text2) {
    int m = text1.length();
    int n = text2.length();
    int[][] dp = new int[m + 1][n + 1];
    
    // 先构建二维 DP 表
    for (int i = 1; i <= m; i++) {
        char c1 = text1.charAt(i - 1);
        for (int j = 1; j <= n; j++) {
            char c2 = text2.charAt(j - 1);
            dp[i][j] = (c1 == c2) ? dp[i-1][j-1] + 1 : Math.max(dp[i-1][j], dp[i][j-1]);
        }
    }
    
    // 回溯构建 LCS 序列
    StringBuilder sb = new StringBuilder();
    int i = m, j = n;
    while (i > 0 && j > 0) {
        if (text1.charAt(i-1) == text2.charAt(j-1)) {
            sb.append(text1.charAt(i-1));
            i--;
            j--;
        } else if (dp[i-1][j] > dp[i][j-1]) {
            i--;
        } else {
            j--;
        }
    }
    return sb.reverse().toString(); // 反转得到正序 LCS
}
```

## 七、拓展二：最长公共子串（连续）
### 1. 问题差异
最长公共子串要求「字符连续」，与 LCS（不连续）的核心区别：字符不同时，子串长度重置为 0。

### 2. 动态规划解法
#### 状态定义
`dp[i][j]` 表示以 `text1[i-1]` 和 `text2[j-1]` 为结尾的最长公共子串长度。

#### 状态转移方程
- 若 `text1[i-1] == text2[j-1]`：`dp[i][j] = dp[i-1][j-1] + 1`（延续前一个连续子串）。
- 否则：`dp[i][j] = 0`（子串中断，长度重置）。

#### 代码实现（简单版）
```java
public int longestCommonSubstring(String text1, String text2) {
    int m = text1.length();
    int n = text2.length();
    int[][] dp = new int[m + 1][n + 1];
    int maxLen = 0; // 记录最长子串长度
    
    for (int i = 1; i <= m; i++) {
        char c1 = text1.charAt(i - 1);
        for (int j = 1; j <= n; j++) {
            char c2 = text2.charAt(j - 1);
            if (c1 == c2) {
                dp[i][j] = dp[i-1][j-1] + 1;
                maxLen = Math.max(maxLen, dp[i][j]);
            } else {
                dp[i][j] = 0;
            }
        }
    }
    return maxLen;
}
```

### 3. 说明
- 时间复杂度：\( O(m \times n) \)，空间复杂度可优化至 \( O(\min(m, n)) \)（同 LCS 一维优化思路）。
- 若需输出具体子串，可记录 `maxLen` 对应的 `i` 或 `j`，反向截取字符串。

## 八、总结：各方法对比与适用场景
| 方法               | 时间复杂度 | 空间复杂度       | 适用场景                     | 核心优势                     |
|--------------------|------------|------------------|------------------------------|------------------------------|
| 暴力递归           | \( O(2^{m+n}) \) | \( O(m+n) \)     | 理解基础逻辑                 | 实现极简                     |
| 记忆化递归         | \( O(m \times n) \) | \( O(m \times n + m + n) \) | 中等规模数据                 | 思路连贯                     |
| 二维动态规划       | \( O(m \times n) \) | \( O(m \times n) \) | 需输出 LCS 序列、调试场景    | 逻辑直观，易于回溯           |
| 一维动态规划       | \( O(m \times n) \) | \( O(\min(m, n)) \) | 大规模数据、空间受限场景     | 空间最优                     |

## 九、核心要点回顾
1. LCS 问题的核心是「最优子结构」和「重复子问题」，动态规划是解决该类问题的通用思路。
2. 从递归到动态规划的演进：暴力递归→记忆化递归（解决重复子问题）→二维 DP（迭代化）→一维 DP（空间优化）。
3. 拓展场景：
   - 输出 LCS 序列：基于二维 DP 表回溯。
   - 最长公共子串：修改状态定义和转移方程（字符不同时重置长度）。

掌握 LCS 的推导逻辑，可举一反三解决各类子序列/子串相关的动态规划问题（如编辑距离、最长回文子序列等）。
