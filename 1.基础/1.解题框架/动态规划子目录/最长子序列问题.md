https://leetcode.cn/problems/longest-common-subsequence/description/?envType=study-plan-v2&envId=top-100-liked

# 最长公共子序列（LCS）问题详细解读：从递归到动态规划最优解
最长公共子序列（Longest Common Subsequence，简称 LCS）是动态规划领域的经典问题，核心是找到两个字符串中「顺序一致但不一定连续」的最长子序列长度。本文将从「问题定义→暴力递归→记忆化递归→二维DP→空间优化」逐步推导，同时补充「输出LCS具体序列」和「最长公共子串（连续）」的拓展解法。

## 一、问题定义
### 1. 核心概念
- **子序列**：从字符串中删除任意个字符（可删除0个），不改变剩余字符顺序得到的序列（如 `abc` 的子序列有 `a`、`ac`、`abc` 等）。
- **公共子序列**：两个字符串共有的子序列（如 `abcde` 和 `ace` 的公共子序列有 `a`、`c`、`e`、`ace` 等）。
- **最长公共子序列**：所有公共子序列中长度最大的那个（上例中 `ace` 是 LCS，长度为3）。

### 2. 输入输出示例
| 输入                          | 输出 | 说明                     |
|-------------------------------|------|--------------------------|
| `text1 = "abcde", text2 = "ace"` | 3    | LCS 为 `"ace"`           |
| `text1 = "abc", text2 = "abc"`   | 3    | LCS 为 `"abc"`           |
| `text1 = "abc", text2 = "def"`   | 0    | 无公共子序列             |

### 3. 问题本质
LCS 问题的关键是「子结构重叠」和「最优子结构」：
- 子结构重叠：求解大问题时，需要重复求解多个小问题（如求 `LCS(abcde, ace)` 需先求 `LCS(abcd, ac)` 等）。
- 最优子结构：大问题的最优解（最长长度）由小问题的最优解推导而来。

## 二、方法一：暴力递归（基础思路，超时）
### 1. 递归思路
从两个字符串的末尾开始，分两种情况讨论：
1. 若 `text1[i] == text2[j]`：当前字符是公共子序列的一部分，LCS 长度 = 1 + 子问题 `LCS(text1[0..i-1], text2[0..j-1])` 的长度。
2. 若 `text1[i] != text2[j]`：当前字符不同，LCS 长度 = 子问题 `LCS(text1[0..i-1], text2[0..j-1])`、`LCS(text1[0..i], text2[0..j-1])`、`LCS(text1[0..i-1], text2[0..j])` 中的最大值（后两者已包含前者，可简化为取后两者最大值）。

### 2. 递归边界
- 若 `i < 0` 或 `j < 0`（任一字符串为空），LCS 长度为 0。

### 3. 代码实现
```java
public int longestCommonSubsequence(String text1, String text2) {
    int m = text1.length();
    int n = text2.length();
    return dfs(text1, text2, m - 1, n - 1);
}

private int dfs(String text1, String text2, int i, int j) {
    if (i < 0 || j < 0) return 0;
    if (text1.charAt(i) == text2.charAt(j)) {
        return 1 + dfs(text1, text2, i - 1, j - 1);
    } else {
        return Math.max(dfs(text1, text2, i - 1, j), dfs(text1, text2, i, j - 1));
    }
}
```

### 4. 复杂度分析
- 时间复杂度：\( O(2^{m+n}) \)。每个递归调用产生 2 个分支，存在大量重复子问题。
- 空间复杂度：\( O(m+n) \)。递归栈深度为两个字符串长度之和。

### 5. 结论
暴力递归因重复子问题效率极低，仅适用于理解基础逻辑，无法处理长度超过 20 的字符串。

## 三、方法二：记忆化递归（优化重复子问题）
### 1. 优化思路
用「备忘录」存储已求解的子问题结果，避免重复计算。当再次遇到相同 `(i,j)` 时，直接返回备忘录中的值。

### 2. 备忘录设计
使用二维数组 `memo[i][j]` 存储 `text1[0..i]` 和 `text2[0..j]` 的 LCS 长度，初始值为 `-1`（表示未求解）。

### 3. 代码实现
```java
import java.util.Arrays;

public int longestCommonSubsequence(String text1, String text2) {
    int m = text1.length();
    int n = text2.length();
    int[][] memo = new int[m][n];
    for (int[] row : memo) Arrays.fill(row, -1);
    return dfsWithMemo(text1, text2, m - 1, n - 1, memo);
}

private int dfsWithMemo(String text1, String text2, int i, int j, int[][] memo) {
    if (i < 0 || j < 0) return 0;
    if (memo[i][j] != -1) return memo[i][j];
    if (text1.charAt(i) == text2.charAt(j)) {
        memo[i][j] = 1 + dfsWithMemo(text1, text2, i - 1, j - 1, memo);
    } else {
        memo[i][j] = Math.max(
            dfsWithMemo(text1, text2, i - 1, j, memo),
            dfsWithMemo(text1, text2, i, j - 1, memo)
        );
    }
    return memo[i][j];
}
```

### 4. 复杂度分析
- 时间复杂度：\( O(m \times n) \)。每个子问题 `(i,j)` 仅计算一次。
- 空间复杂度：\( O(m \times n + m + n) \)。备忘录占 \( O(m \times n) \)，递归栈占 \( O(m+n) \)。

### 5. 结论
解决了重复子问题，效率大幅提升，但仍存在递归栈溢出风险（如字符串长度超过 1000），需转化为迭代的动态规划。

## 四、方法三：二维动态规划（迭代版，最优解基础）
### 1. 状态定义（核心）
将递归子问题转化为 DP 数组状态：
- 定义 `dp[i][j]` 表示 `text1[0..i-1]`（前 `i` 个字符）和 `text2[0..j-1]`（前 `j` 个字符）的 LCS 长度。
- 设计初衷：`i=0` 或 `j=0` 表示任一字符串为空，LCS 长度为 0，简化边界处理。

### 2. 状态转移方程
基于递归逻辑推导：
1. 若 `text1[i-1] == text2[j-1]`（当前字符相同）：
   \[ dp[i][j] = dp[i-1][j-1] + 1 \]
   解释：当前字符是公共子序列的一部分，长度 = 前 `i-1` 和 `j-1` 个字符的 LCS 长度 + 1。
2. 若 `text1[i-1] != text2[j-1]`（当前字符不同）：
   \[ dp[i][j] = \max(dp[i-1][j], dp[i][j-1]) \]
   解释：取「前 `i-1` 个字符与前 `j` 个字符的 LCS」和「前 `i` 个字符与前 `j-1` 个字符的 LCS」中的最大值。

### 3. 初始化
- `dp[0][j] = 0`（`text1` 为空，LCS 长度为 0）。
- `dp[i][0] = 0`（`text2` 为空，LCS 长度为 0）。

### 4. 填表顺序
从 `i=1` 到 `m`，`j=1` 到 `n`（行优先或列优先均可），因为 `dp[i][j]` 依赖左上、上、左三个已计算状态。

### 5. 示例填表过程（`text1="abcde", text2="ace"`）
`m=5`，`n=3`，DP 表为 `6×4`（`i=0~5`，`j=0~3`）：

| `dp[i][j]` | `j=0`（空串） | `j=1`（"a"） | `j=2`（"ac"） | `j=3`（"ace"） |
|------------|---------------|--------------|---------------|----------------|
| `i=0`（空串） | 0             | 0            | 0             | 0              |
| `i=1`（"a"）  | 0             | 1（a==a）    | 1（max(1,0)） | 1（max(1,0)）  |
| `i=2`（"ab"） | 0             | 1（max(0,1)）| 1（a≠c）      | 1（max(1,1)）  |
| `i=3`（"abc"）| 0             | 1（max(0,1)）| 2（c==c）     | 2（max(2,1)）  |
| `i=4`（"abcd"）| 0             | 1            | 2             | 2（max(2,2)）  |
| `i=5`（"abcde"）| 0            | 1            | 2             | 3（e==e）      |

最终 `dp[5][3] = 3`，与预期一致。

### 6. 代码实现
```java
public int longestCommonSubsequence(String text1, String text2) {
    int m = text1.length();
    int n = text2.length();
    int[][] dp = new int[m + 1][n + 1];
    
    for (int i = 1; i <= m; i++) {
        char c1 = text1.charAt(i - 1);
        for (int j = 1; j <= n; j++) {
            char c2 = text2.charAt(j - 1);
            if (c1 == c2) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
}
```

### 7. 复杂度分析
- 时间复杂度：\( O(m \times n) \)。遍历 `(m+1)×(n+1)` 个状态，每个状态计算耗时 \( O(1) \)。
- 空间复杂度：\( O(m \times n) \)。DP 表占用 `(m+1)×(n+1)` 空间。

### 8. 结论
二维 DP 解决了递归栈溢出问题，效率稳定，是 LCS 问题的基础最优解。

## 五、方法四：空间优化（一维动态规划）
### 1. 优化思路
观察状态转移方程：`dp[i][j]` 仅依赖左上（`dp[i-1][j-1]`）、上（`dp[i-1][j]`）、左（`dp[i][j-1]`）三个状态。用一维数组 `dp[j]` 覆盖存储，需额外保存「左上」值避免被覆盖。

### 2. 一维 DP 状态定义
- `dp[j]` 表示当前处理到 `text1` 第 `i` 个字符时，`text1[0..i-1]` 与 `text2[0..j-1]` 的 LCS 长度。

### 3. 状态转移与变量保存
- 用 `prev` 保存 `dp[i-1][j-1]`（上一行的 `dp[j-1]`）。
- 遍历 `j` 从 1 到 `n` 时：
  1. 保存当前 `dp[j]` 到 `temp`（下一轮的 `prev`）。
  2. 若字符相同，`dp[j] = prev + 1`；否则，`dp[j] = max(dp[j], dp[j-1])`。
  3. 更新 `prev = temp`。

### 4. 代码实现
```java
import java.util.Arrays;

public int longestCommonSubsequence(String text1, String text2) {
    int m = text1.length();
    int n = text2.length();
    // 优化：用较短字符串长度作为一维数组长度
    if (m < n) return longestCommonSubsequence(text2, text1);
    int[] dp = new int[n + 1];   // 注意这里，是按照第二个字符串长度遍历，即按照列遍历
    
    for (int i = 1; i <= m; i++) {
        char c1 = text1.charAt(i - 1);
        int prev = dp[0]; // 初始为 dp[i-1][0] = 0
        for (int j = 1; j <= n; j++) {
            char c2 = text2.charAt(j - 1);
            int temp = dp[j]; // 保存上一行的 dp[j]
            dp[j] = (c1 == c2) ? prev + 1 : Math.max(dp[j], dp[j - 1]);
            prev = temp; // 更新 prev 为下一轮的左上值
        }
    }
    return dp[n];
}
```

### 5. 复杂度分析
- 时间复杂度：\( O(m \times n) \)。与二维 DP 一致。
- 空间复杂度：\( O(\min(m, n)) \)。最优空间复杂度，适合超长字符串。

### 6. 结论
一维 DP 在不损失时间效率的前提下，大幅降低空间复杂度，是工业级最优解。

## 六、拓展一：输出 LCS 具体序列
上述方法仅求长度，若需输出具体序列，可通过二维 DP 表「回溯」推导：
1. 从 `dp[m][n]` 开始，`i = m`，`j = n`。
2. 若 `text1[i-1] == text2[j-1]`：当前字符是 LCS 的一部分，加入结果集，`i--` 且 `j--`。
3. 若不相等：
   - 若 `dp[i-1][j] > dp[i][j-1]`：向 `i--` 移动（上一行更优）。
   - 否则：向 `j--` 移动（左一列更优）。
4. 重复步骤 2-3，直到 `i == 0` 或 `j == 0`，反转结果集（因回溯是从后向前收集）。

### 代码实现
```java
public String getLCS(String text1, String text2) {
    int m = text1.length();
    int n = text2.length();
    int[][] dp = new int[m + 1][n + 1];
    
    // 先构建二维 DP 表
    for (int i = 1; i <= m; i++) {
        char c1 = text1.charAt(i - 1);
        for (int j = 1; j <= n; j++) {
            char c2 = text2.charAt(j - 1);
            dp[i][j] = (c1 == c2) ? dp[i-1][j-1] + 1 : Math.max(dp[i-1][j], dp[i][j-1]);
        }
    }
    
    // 回溯构建 LCS 序列
    StringBuilder sb = new StringBuilder();
    int i = m, j = n;
    while (i > 0 && j > 0) {
        if (text1.charAt(i-1) == text2.charAt(j-1)) {
            sb.append(text1.charAt(i-1));
            i--;
            j--;
        } else if (dp[i-1][j] > dp[i][j-1]) {
            i--;
        } else {
            j--;
        }
    }
    return sb.reverse().toString(); // 反转得到正序 LCS
}
```

## 七、拓展二：最长公共子串（连续）
### 1. 问题差异
最长公共子串要求「字符连续」，与 LCS（不连续）的核心区别：字符不同时，子串长度重置为 0。

### 2. 动态规划解法
#### 状态定义
`dp[i][j]` 表示以 `text1[i-1]` 和 `text2[j-1]` 为结尾的最长公共子串长度。

#### 状态转移方程
- 若 `text1[i-1] == text2[j-1]`：`dp[i][j] = dp[i-1][j-1] + 1`（延续前一个连续子串）。
- 否则：`dp[i][j] = 0`（子串中断，长度重置）。

#### 代码实现（简单版）
```java
public int longestCommonSubstring(String text1, String text2) {
    int m = text1.length();
    int n = text2.length();
    int[][] dp = new int[m + 1][n + 1];
    int maxLen = 0; // 记录最长子串长度
    
    for (int i = 1; i <= m; i++) {
        char c1 = text1.charAt(i - 1);
        for (int j = 1; j <= n; j++) {
            char c2 = text2.charAt(j - 1);
            if (c1 == c2) {
                dp[i][j] = dp[i-1][j-1] + 1;
                maxLen = Math.max(maxLen, dp[i][j]);
            } else {
                dp[i][j] = 0;
            }
        }
    }
    return maxLen;
}
```

### 3. 说明
- 时间复杂度：\( O(m \times n) \)，空间复杂度可优化至 \( O(\min(m, n)) \)（同 LCS 一维优化思路）。
- 若需输出具体子串，可记录 `maxLen` 对应的 `i` 或 `j`，反向截取字符串。

## 八、拓展三：编辑距离（Levenshtein Distance）
### 1. 问题差异
编辑距离（又称莱文斯坦距离）是衡量**两个字符串相似度**的经典算法，核心定义为：将一个字符串转换成另一个字符串所需的**最小操作次数**，允许的基础操作仅3种（每种操作代价均为1）：
1. 插入（Insert）：在字符串中添加一个字符（例："abc" → "abdc"，插入 'd'）
2. 删除（Delete）：在字符串中移除一个字符（例："abc" → "ac"，删除 'b'）
3. 替换（Replace）：将字符串中一个字符替换为另一个（例："abc" → "adc"，替换 'b' 为 'd'）

### 2. 动态规划解法
#### 状态定义
设 `dp[i][j]` 表示：将 `word1` 的前 `i` 个字符（`word1[0..i-1]`）转换成 `word2` 的前 `j` 个字符（`word2[0..j-1]`）所需的最小操作数。
- 索引设计：`i=0` 对应 `word1` 空串，`j=0` 对应 `word2` 空串，方便处理边界场景。

#### 初始化边界条件
- 当 `i=0`（`word1` 为空串）：需插入 `j` 个字符才能得到 `word2` 前 `j` 个字符 → `dp[0][j] = j`
- 当 `j=0`（`word2` 为空串）：需删除 `i` 个字符才能得到空串 → `dp[i][0] = i`

示例初始化表（`word1="horse"` 长度5，`word2="ros"` 长度3）：
|       | 0（空串） | 1（r） | 2（ro） | 3（ros） |
|-------|-----------|--------|---------|----------|
| 0（空串） | 0         | 1      | 2       | 3        |
| 1（h）    | 1         | ?      | ?       | ?        |
| 2（ho）   | 2         | ?      | ?       | ?        |
| 3（hor）  | 3         | ?      | ?       | ?        |
| 4（hors） | 4         | ?      | ?       | ?        |
| 5（horse）| 5         | ?      | ?       | ?        |

#### 状态转移方程
核心逻辑：若 `word1` 的第 `i` 个字符（`word1[i-1]`）与 `word2` 的第 `j` 个字符（`word2[j-1]`）**相等**，则无需额外操作，直接继承子问题结果；若**不相等**，则在三种操作中选择代价最小的一种。

#### 分情况讨论：
- 字符相等（`word1[i-1] == word2[j-1]`）：
  `dp[i][j] = dp[i-1][j-1]`（子问题 `word1[0..i-1]→word2[0..j-1]` 已解决，无需额外操作）
- 字符不相等：
    1. 插入操作：`dp[i][j-1] + 1`（先将 `word1[0..i]` 转成 `word2[0..j-1]`，再插入 `word2[j-1]`）
    2. 删除操作：`dp[i-1][j] + 1`（先删除 `word1[i-1]`，再将 `word1[0..i-1]` 转成 `word2[0..j]`）
    3. 替换操作：`dp[i-1][j-1] + 1`（先将 `word1[0..i-1]` 转成 `word2[0..j-1]`，再替换字符）

综上，状态转移方程为：
```java
if (word1.charAt(i-1) == word2.charAt(j-1)) {
    dp[i][j] = dp[i-1][j-1];
} else {
    dp[i][j] = Math.min(Math.min(dp[i][j-1], dp[i-1][j]), dp[i-1][j-1]) + 1;
}
```

#### 代码实现（简单版）
```java
public class EditDistance {
    public static int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        
        // 初始化DP表：(m+1)行 × (n+1)列
        int[][] dp = new int[m + 1][n + 1];
        
        // 边界条件1：word1空串 → 插入j个字符
        for (int j = 0; j <= n; j++) {
            dp[0][j] = j;
        }
        
        // 边界条件2：word2空串 → 删除i个字符
        for (int i = 0; i <= m; i++) {
            dp[i][0] = i;
        }
        
        // 填充DP表
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    // 取三种操作的最小代价+1
                    dp[i][j] = Math.min(Math.min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;
                }
            }
        }
        
        return dp[m][n];
    }
}
```

#### 空间优化实现（O(min(m,n))空间）
观察到 `dp[i][j]` 仅依赖上一行（`dp[i-1][...]`）、左一列（`dp[i][j-1]`）和上一行左一列（`dp[i-1][j-1]`），可优化为一维数组存储状态，空间复杂度降至 `O(min(m,n))`：
```java
public class EditDistanceOptimized {
    public static int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        
        // 让n为较短字符串，减少数组长度
        if (m < n) {
            return minDistance(word2, word1);
        }
        
        // 一维DP数组：存储上一行状态
        int[] dp = new int[n + 1];
        
        // 初始化边界：word1空串 → 插入j个字符
        for (int j = 0; j <= n; j++) {
            dp[j] = j;
        }
        
        for (int i = 1; i <= m; i++) {
            int prev = dp[0]; // 保存dp[i-1][j-1]（初始为dp[i-1][0] = i-1）
            dp[0] = i; // 更新当前行j=0的边界（dp[i][0] = i）
            
            for (int j = 1; j <= n; j++) {
                int temp = dp[j]; // 暂存dp[i-1][j]，下一轮作为prev
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[j] = prev; // 直接继承上一行左一列的结果
                } else {
                    // 取三种操作的最小代价+1（dp[j]是上一行j列，dp[j-1]是当前行j-1列，prev是上一行j-1列）
                    dp[j] = Math.min(Math.min(dp[j], dp[j - 1]), prev) + 1;
                }
                prev = temp; // 更新prev为下一轮的dp[i-1][j-1]
            }
        }
        
        return dp[n];
    }
}
```