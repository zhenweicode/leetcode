https://leetcode.cn/problems/maximum-product-subarray/description/?envType=study-plan-v2&envId=top-100-liked

要解决“乘积最大子数组”问题，我们需要同时关注**最大值**和**最小值**的变化，因为负数的存在可能让最小值（负负得正）成为新的最大值。以下是对图中方法的详细解释，以及其他等价的优化思路。


### 一、图中方法：动态规划（同时维护最大和最小乘积）
#### 思路分析
- 定义两个变量 `imax` 和 `imin`，分别表示**以当前元素结尾的子数组的最大乘积**和**最小乘积**。
- 当遇到负数时，最大乘积和最小乘积会交换（因为负数乘以最大值会得到最小值，乘以最小值会得到最大值）。
- 遍历数组时，对每个元素 `nums[i]`，更新 `imax` 和 `imin`，并维护全局最大值 `max`。

#### 代码逐行解释
```java
public int maxProduct(int[] nums) {
    // 初始化全局最大值、当前最大乘积、当前最小乘积
    int max = Integer.MIN_VALUE, imax = 1, imin = 1;
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] < 0) {
            // 遇到负数，交换imax和imin（因为负负得正，最小值可能变最大值）
            int tmp = imax;
            imax = imin;
            imin = tmp;
        }
        // 更新当前最大乘积：要么当前元素自己，要么当前元素乘以前面的最大乘积
        imax = Math.max(imax * nums[i], nums[i]);
        // 更新当前最小乘积：要么当前元素自己，要么当前元素乘以前面的最小乘积
        imin = Math.min(imin * nums[i], nums[i]);
        // 维护全局最大值
        max = Math.max(max, imax);
    }
    return max;
}
```

#### 时间复杂度与空间复杂度
- 时间复杂度：\(O(n)\)（仅遍历数组一次）。
- 空间复杂度：\(O(1)\)（仅用常数级额外空间）。


### 二、等价优化方法：动态规划（显式状态转移）
我们也可以通过**显式的状态转移方程**来实现，逻辑与上述方法完全一致，只是将 `imax` 和 `imin` 用临时变量显式保存，避免交换时的逻辑混淆。

#### 代码实现
```java
public int maxProduct(int[] nums) {
    int max = Integer.MIN_VALUE, imax = 1, imin = 1;
    for (int num : nums) {
        // 临时保存上一轮的imax和imin，避免更新后被覆盖
        int tempMax = imax * num;
        int tempMin = imin * num;
        // 更新当前imax和imin
        imax = Math.max(num, Math.max(tempMax, tempMin));
        imin = Math.min(num, Math.min(tempMax, tempMin));
        // 维护全局最大值
        max = Math.max(max, imax);
    }
    return max;
}
```

#### 思路说明
- 先计算“当前元素与上一轮最大乘积的乘积”`tempMax` 和“当前元素与上一轮最小乘积的乘积”`tempMin`。
- 新的 `imax` 是 `num`、`tempMax`、`tempMin` 中的最大值；新的 `imin` 是其中的最小值。
- 此方法无需显式交换 `imax` 和 `imin`，逻辑更直观，与原方法等价。


### 三、两种方法的对比
| 方法                | 核心逻辑                     | 代码复杂度 | 可读性 |
|---------------------|------------------------------|------------|--------|
| 原方法（交换imax/imin） | 遇到负数时交换两个变量       | 低         | 中等   |
| 显式状态转移法       | 用临时变量保存中间结果       | 低         | 高     |

两种方法的**时间复杂度和空间复杂度完全相同**，均为最优解法。显式状态转移法的可读性略高，更推荐在工程中使用。


### 总结
“乘积最大子数组”的核心在于**同时维护最大和最小乘积**，因为负数的存在会让“最小乘积”有机会转化为“最大乘积”。上述两种方法均是该思路的最优实现，时间复杂度 \(O(n)\)、空间复杂度 \(O(1)\)，是解决该问题的标准答案。
