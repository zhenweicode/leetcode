
参考：
https://leetcode.cn/problems/coin-change/solutions/778891/yi-pian-wen-zhang-chi-tou-bei-bao-wen-ti-sq9n/?envType=study-plan-v2&envId=top-100-liked

https://www.doubao.com/chat/collection/27848640206633986?type=Thread


# 背包问题Java标准模板（含详细推导过程）
背包问题是动态规划的核心应用场景，主要分为 **01背包、完全背包、多重背包、分组背包** 四大类。本文将从「问题定义→二维DP推导→一维DP优化→遍历顺序原理→不同问题类型（最值/存在/组合）」展开，附完整Java模板和典型示例。


## 一、0-1背包（物品不可重复选择）
### 1. 问题描述
有 `n` 个物品，每个物品重量 `weight[i]`、价值 `value[i]`，背包容量 `C`。每个物品最多选1次，求背包能装下的最大价值。

### 2. 二维数组推导（基础版）
#### （1）状态定义
`dp[i][j]`：表示前 `i` 个物品（编号0~i-1）中任选若干个，放入容量为 `j` 的背包的最大价值。  
- 维度1（`i`）：物品数量（从0到n，`i=0` 表示选0个物品）；  
- 维度2（`j`）：背包容量（从0到C，`j=0` 表示容量为0）。

#### （2）状态转移方程推导
对于第 `i` 个物品（对应数组索引 `i-1`），有两种选择：
- **不选第i个物品**：背包价值 = 前 `i-1` 个物品在容量 `j` 下的最大价值 → `dp[i][j] = dp[i-1][j]`；  
- **选第i个物品**：需满足 `j ≥ weight[i-1]`（背包能装下），此时价值 = 前 `i-1` 个物品在容量 `j - weight[i-1]` 下的最大价值 + 第i个物品的价值 → `dp[i][j] = dp[i-1][j - weight[i-1]] + value[i-1]`；  
- 最终取两者最大值：  
  `dp[i][j] = Math.max(dp[i-1][j], (j >= weight[i-1]) ? dp[i-1][j - weight[i-1]] + value[i-1] : dp[i-1][j])`。

#### （3）初始化
- `dp[0][j] = 0`（选0个物品，无论容量多大，价值都是0）；  
- `dp[i][0] = 0`（容量为0，无论选多少物品，价值都是0）。

#### （4）二维数组代码示例
```java
public static int maxValue01TwoD(int[] weight, int[] value, int capacity) {
    int n = weight.length;
    int[][] dp = new int[n + 1][capacity + 1];

    // 遍历所有物品（i从1到n，代表前i个物品）
    for (int i = 1; i <= n; i++) {
        // 遍历所有容量（j从1到capacity）
        for (int j = 1; j <= capacity; j++) {
            if (j < weight[i-1]) {
                // 容量装不下第i个物品，只能不选
                dp[i][j] = dp[i-1][j];
            } else {
                // 选或不选，取最大值
                dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j - weight[i-1]] + value[i-1]);
            }
        }
    }
    return dp[n][capacity];
}
```

### 3. 二维→一维数组优化推导
#### （1）优化核心观察
观察状态转移方程 `dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j - w] + v)`（`w=weight[i-1], v=value[i-1]`）：  
- `dp[i][j]` 只依赖于 **上一行（i-1行）** 的数据，与更前面的行（i-2、i-3...）无关；  
- 无需保留整个二维数组，只需用一个一维数组 `dp[j]` 存储上一行的状态，即可递推出当前行。

#### （2）一维数组状态定义
`dp[j]`：表示当前遍历到的物品集合中，容量为 `j` 的背包的最大价值（替代二维数组的 `dp[i][j]`）。

#### （3）转移方程适配
将二维方程中的 `dp[i-1][j]` 直接替换为 `dp[j]`（因为 `dp[j]` 还未被当前行更新，存储的是上一行的结果），得到一维转移方程：  
`dp[j] = Math.max(dp[j], dp[j - w] + v)`。

### 4. 逆序遍历容量的推导（避免重复选择）
#### （1）问题：为什么不能正序遍历？
假设用一维数组且**正序遍历容量**（`j从w到C`）：  
- 遍历第 `i` 个物品时，`j` 从小到大更新：先更新 `dp[w]`，再更新 `dp[2w]`、`dp[3w]`...  
- 此时 `dp[j - w]` 已经被当前物品更新过（比如 `j=2w` 时，`j - w = w`，`dp[w]` 是选了第i个物品后的结果），导致第i个物品被**多次选择**（违背0-1背包“不可重复选”的规则）。

#### （2）逆序遍历的原理
为了保证 `dp[j - w]` 始终是**上一行（i-1行）** 的值（即未被当前物品更新过），需要**逆序遍历容量**（`j从C到w`）：  
- 遍历第 `i` 个物品时，`j` 从大到小更新：先更新 `dp[C]`，再更新 `dp[C-1]`...最后更新 `dp[w]`；  
- 此时 `dp[j - w]` 还未被当前物品更新（因为 `j - w < j`，逆序中 `j - w` 还没遍历到），存储的是上一行的结果，确保每个物品只被选一次。

#### （3）逆序遍历代码推导
```java
// 一维数组优化版（逆序遍历容量）
public static int maxValue01OneD(int[] weight, int[] value, int capacity) {
    int n = weight.length;
    int[] dp = new int[capacity + 1]; // 初始化为0，对应二维数组的dp[0][j] = 0

    // 遍历每个物品（不可重复选，外层固定物品）
    for (int i = 0; i < n; i++) {
        int w = weight[i];
        int v = value[i];
        // 逆序遍历容量：从大到小，避免重复选择当前物品
        for (int j = capacity; j >= w; j--) {
            dp[j] = Math.max(dp[j], dp[j - w] + v);
        }
    }
    return dp[capacity];
}
```

### 5. 0-1背包核心结论
- 二维→一维优化：利用“当前行只依赖上一行”的特性，压缩空间复杂度从 `O(n*C)` 到 `O(C)`；  
- 遍历顺序：**外层物品，内层逆序容量**，确保物品不可重复选择。


## 二、完全背包（物品可无限重复选择）
### 1. 问题描述
与0-1背包一致，但每个物品可选择**无限次**（只要背包容量允许）。

### 2. 二维数组推导（基础版）
#### （1）状态定义
与0-1背包完全相同：`dp[i][j]` 表示前 `i` 个物品中任选若干个（可重复），放入容量 `j` 的背包的最大价值。

#### （2）状态转移方程推导
与0-1背包的核心区别：**选第i个物品后，仍可继续选第i个物品**（无需跳到 `i-1` 个物品）。  
- 不选第i个物品：`dp[i][j] = dp[i-1][j]`（与0-1一致）；  
- 选第i个物品（`j ≥ w`）：`dp[i][j] = dp[i][j - w] + v`（注意是 `dp[i][j - w]`，而非 `dp[i-1][j - w]`，因为选了第i个后还能再选）；  
- 最终方程：  
  `dp[i][j] = Math.max(dp[i-1][j], (j >= w) ? dp[i][j - w] + v : dp[i-1][j])`。

#### （3）二维数组代码示例
```java
public static int maxValueUnboundedTwoD(int[] weight, int[] value, int capacity) {
    int n = weight.length;
    int[][] dp = new int[n + 1][capacity + 1];

    for (int i = 1; i <= n; i++) {
        int w = weight[i-1];
        int v = value[i-1];
        for (int j = 1; j <= capacity; j++) {
            if (j < w) {
                dp[i][j] = dp[i-1][j];
            } else {
                // 选第i个物品后仍可继续选，所以用dp[i][j - w]
                dp[i][j] = Math.max(dp[i-1][j], dp[i][j - w] + v);
            }
        }
    }
    return dp[n][capacity];
}
```

### 3. 二维→一维数组优化推导
#### （1）优化核心观察
完全背包的二维转移方程 `dp[i][j] = Math.max(dp[i-1][j], dp[i][j - w] + v)`：  
- `dp[i][j]` 依赖上一行的 `dp[i-1][j]` 和**当前行**的 `dp[i][j - w]`；  
- 同样可压缩为一维数组 `dp[j]`，但需要保证 `dp[j - w]` 是当前行更新后的值（与0-1背包相反）。

#### （2）一维数组转移方程
直接替换二维方程中的 `dp[i][j]` 为 `dp[j]`，`dp[i-1][j]` 为 `dp[j]`（未更新前的旧值），得到：  
`dp[j] = Math.max(dp[j], dp[j - w] + v)`（与0-1背包一维方程形式相同，但遍历顺序不同）。

### 4. 正序遍历容量的推导（允许重复选择）
#### （1）正序遍历的原理
完全背包需要允许物品重复选择，因此需要让 `dp[j - w]` 是**当前行更新后的值**：  
- 正序遍历容量（`j从w到C`）：先更新 `dp[w]`，再更新 `dp[2w]`、`dp[3w]`...  
- 当更新 `dp[2w]` 时，`dp[w]` 已经是选了1次第i个物品后的结果，因此 `dp[2w] = max(dp[2w], dp[w] + v)` 等价于“选2次第i个物品”，恰好满足“无限重复选”的需求。

#### （2）正序遍历代码推导
```java
// 一维数组优化版（正序遍历容量）
public static int maxValueUnboundedOneD(int[] weight, int[] value, int capacity) {
    int n = weight.length;
    int[] dp = new int[capacity + 1];

    // 遍历每个物品（可重复选，外层固定物品）
    for (int i = 0; i < n; i++) {
        int w = weight[i];
        int v = value[i];
        // 正序遍历容量：从小到大，允许重复选择当前物品
        for (int j = w; j <= capacity; j++) {
            dp[j] = Math.max(dp[j], dp[j - w] + v);
        }
    }
    return dp[capacity];
}
```

### 5. 完全背包核心结论
- 二维→一维优化：同样利用“状态依赖特性”压缩空间，空间复杂度 `O(C)`；  
- 遍历顺序：**外层物品，内层正序容量**，确保物品可无限重复选择。


## 三、多重背包（物品有限次选择）
### 1. 问题描述
有 `n` 个物品，每个物品重量 `weight[i]`、价值 `value[i]`，最多可选 `count[i]` 次，背包容量 `C`。求最大价值。

### 2. 核心思路推导（二进制优化）
#### （1）原始问题痛点
若直接遍历每个物品的可选次数（`k=0到count[i]`），时间复杂度为 `O(n*C*sum(count))`，当 `count[i]` 较大时（如1000），效率极低。

#### （2）二进制拆分原理
将“最多选 `k` 次”的物品，拆分为若干个“0-1背包物品”，用二进制组合覆盖 `0~k` 的所有选择次数：  
- 例：`k=5` → 拆分为 `1、2、2`（1+2+2=5），可组合出 0（不选）、1、2、1+2=3、2+2=4、1+2+2=5；  
- 例：`k=7` → 拆分为 `1、2、4`（1+2+4=7），可组合出 0~7 所有次数；  
- 拆分规则：将 `count[i]` 拆分为 `1、2、4、...、remain`（`remain=count[i] - (2^m - 1)`，确保总和为 `count[i]`）。

#### （3）优化逻辑
通过二进制拆分，将多重背包转化为 **0-1背包**（拆分后的每个“组合物品”最多选1次），时间复杂度降至 `O(C*sum(log count))`（因为每个 `count[i]` 拆分为 `log2(count[i])` 个物品）。

### 3. 完整推导与代码
#### （1）步骤1：二进制拆分物品
将每个原始物品拆分为若干个“组合物品”，存储新的重量和价值数组。

#### （2）步骤2：用0-1背包求解
拆分后问题转化为0-1背包，采用“一维数组+逆序遍历容量”的模板。

#### （3）代码推导
```java
import java.util.ArrayList;
import java.util.List;

public static int maxValueBounded(int[] weight, int[] value, int[] count, int capacity) {
    // 步骤1：二进制拆分物品
    List<Integer> newWeight = new ArrayList<>();
    List<Integer> newValue = new ArrayList<>();

    for (int i = 0; i < weight.length; i++) {
        int w = weight[i];
        int v = value[i];
        int cnt = count[i];

        // 二进制拆分：1,2,4,...remain
        for (int k = 1; k <= cnt; k *= 2) {
            newWeight.add(w * k);   // 组合物品的重量 = 原始重量 * 数量k
            newValue.add(v * k);    // 组合物品的价值 = 原始价值 * 数量k
            cnt -= k;
        }
        // 剩余部分（若cnt>0）
        if (cnt > 0) {
            newWeight.add(w * cnt);
            newValue.add(v * cnt);
        }
    }

    // 步骤2：转化为0-1背包求解（一维数组+逆序遍历）
    int[] dp = new int[capacity + 1];
    for (int i = 0; i < newWeight.size(); i++) {
        int w = newWeight.get(i);
        int v = newValue.get(i);
        // 逆序遍历容量，避免重复选择（0-1背包逻辑）
        for (int j = capacity; j >= w; j--) {
            dp[j] = Math.max(dp[j], dp[j - w] + v);
        }
    }

    return dp[capacity];
}
```

### 4. 多重背包核心结论
- 优化本质：将“有限次选择”转化为“0-1选择”，复用0-1背包的优化模板；  
- 遍历顺序：与0-1背包一致（外层物品，内层逆序容量），确保每个组合物品只选1次。

## 四、分组背包（物品分若干组，每组最多选1个）
https://github.com/zhenweicode/leetcode/blob/master/1.%E5%9F%BA%E7%A1%80/1.%E8%A7%A3%E9%A2%98%E6%A1%86%E6%9E%B6/%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3.md

## 五、不同问题类型的DP模板（最值/存在/组合）
背包问题的目标不仅是「最大价值」，还包括「能否装满」「组合数」等，核心区别在「状态转移方程」和「初始化」。

### 1. 最值问题（求最大/最小价值/数量）
#### 核心模板
- 初始化：`dp[0] = 0`（容量0时，最值为0），其余 `dp[j] = 负无穷（求最大）/ 正无穷（求最小）`（表示不可达）
- 状态转移：`dp[j] = max/min(dp[j], dp[j - w[i]] + val[i])`（01/完全/多重/分组仅遍历顺序不同）

#### 典型示例
##### 示例1：分割等和子集（01背包+最值变形）
**问题**：给定非空数组 `nums`，判断能否将其分割为两个和相等的子集（即是否存在子集和为 `sum/2`）。  
**转化**：01背包的「存在问题」，但可通过最值推导（目标和为 `target=sum/2`，物品重量=价值=nums[i]，求最大价值是否等于target）。
```java
public static boolean canPartition(int[] nums) {
    int sum = Arrays.stream(nums).sum();
    if (sum % 2 != 0) return false;
    int target = sum / 2;
    int[] dp = new int[target + 1]; // dp[j]表示容量j时的最大和
    
    for (int num : nums) { // 01背包：逆序遍历
        for (int j = target; j >= num; j--) {
            dp[j] = Math.max(dp[j], dp[j - num] + num);
        }
    }
    return dp[target] == target;
}
```

##### 示例2：零钱兑换（完全背包+最小数量）
**问题**：给定硬币数组 `coins`（可重复选）和金额 `amount`，求凑成金额的最少硬币数（无解返回-1）。
```java
public static int coinChange(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    // 初始化：最小数量→正无穷，dp[0]=0（金额0需0枚硬币）
    Arrays.fill(dp, Integer.MAX_VALUE);
    dp[0] = 0;
    
    for (int coin : coins) { // 完全背包：正序遍历
        for (int j = coin; j <= amount; j++) {
            if (dp[j - coin] != Integer.MAX_VALUE) { // 确保前态可达
                dp[j] = Math.min(dp[j], dp[j - coin] + 1);
            }
        }
    }
    return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
}
```

### 2. 存在问题（能否装满背包）
#### 核心模板
- 初始化：`dp[0] = true`（容量0时，能装满），其余 `dp[j] = false`（初始不可达）
- 状态转移：`dp[j] = dp[j] || dp[j - w[i]]`（只要有一条路径能装满j，就为true）

#### 典型示例：目标和（01背包+存在问题）
**问题**：给定数组 `nums` 和目标和 `target`，在每个元素前加 `+` 或 `-`，求能否得到目标和（转化为子集和问题：`sum(正) - sum(负) = target` → `sum(正) = (sum + target)/2`）。
```java
public static boolean findTargetSumWays(int[] nums, int target) {
    int sum = Arrays.stream(nums).sum();
    // 目标和必须为整数，且sum >= target
    if ((sum + target) % 2 != 0 || sum < Math.abs(target)) return false;
    int aim = (sum + target) / 2;
    boolean[] dp = new boolean[aim + 1];
    dp[0] = true; // 容量0能装满
    
    for (int num : nums) { // 01背包：逆序遍历
        for (int j = aim; j >= num; j--) {
            dp[j] = dp[j] || dp[j - num];
        }
    }
    return dp[aim];
}
```

### 3. 组合问题（求装满背包的组合数/排列数）
#### 核心模板
- 初始化：`dp[0] = 1`（容量0时，有1种组合：不选任何物品），其余 `dp[j] = 0`
- 状态转移：`dp[j] += dp[j - w[i]]`（累加所有能凑成j的前态组合数）
- 组合数 vs 排列数：
  - 组合数（不考虑顺序，如[1,2]和[2,1]算1种）：先遍历物品，再遍历容量（01/完全/多重）
  - 排列数（考虑顺序，如[1,2]和[2,1]算2种）：先遍历容量，再遍历物品（仅完全背包适用，如零钱兑换II的排列版）

#### 典型示例
##### 示例1：零钱兑换II（完全背包+组合数）
**问题**：给定硬币数组 `coins`（可重复选）和金额 `amount`，求凑成金额的组合数（不考虑硬币顺序）。
```java
public static int change(int amount, int[] coins) {
    int[] dp = new int[amount + 1];
    dp[0] = 1; // 容量0有1种组合
    
    for (int coin : coins) { // 先遍历物品（保证组合顺序唯一）
        for (int j = coin; j <= amount; j++) { // 完全背包：正序遍历
            dp[j] += dp[j - coin];
        }
    }
    return dp[amount];
}
```

##### 示例2：组合总和IV（完全背包+排列数）
**问题**：给定数组 `nums`（可重复选）和目标 `target`，求凑成目标的排列数（考虑顺序）。
```java
public static int combinationSum4(int[] nums, int target) {
    int[] dp = new int[target + 1];
    dp[0] = 1;
    
    for (int j = 1; j <= target; j++) { // 先遍历容量（允许不同顺序）
        for (int num : nums) { // 再遍历物品
            if (j >= num) {
                dp[j] += dp[j - num];
            }
        }
    }
    return dp[target];
}
```


## 六、关键总结
1. **二维→一维优化本质**：利用「当前层状态仅依赖上一层状态」，覆盖存储以节省空间。
2. **遍历顺序核心**：
   - 01背包/分组背包：逆序遍历容量（避免重复选取）
   - 完全背包：正序遍历容量（允许重复选取）
   - 组合数vs排列数：组合数「先物品后容量」，排列数「先容量后物品」
3. **问题类型区别**：
   - 最值：`max/min` 转移，初始化分正负无穷
   - 存在：`||` 转移，初始化 `dp[0]=true`
   - 组合：`+=` 转移，初始化 `dp[0]=1`

以上模板可直接应用于LeetCode相关背包问题，根据具体场景调整「物品属性（重量/价值）」和「遍历顺序」即可。
