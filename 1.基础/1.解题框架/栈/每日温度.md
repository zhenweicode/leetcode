https://leetcode.cn/problems/daily-temperatures/?envType=study-plan-v2&envId=top-100-liked

# 「每日温度」题解（单调栈解法）

这道题是经典的**单调栈**应用场景，核心是找到每个温度之后“下一个更高温度”的天数。下面从思路到代码逐行解释。


## 题目理解
给定一个整数数组 `temperatures`，对于每个元素，返回一个数组 `answer`，其中 `answer[i]` 是需要等待的天数，直到出现比 `temperatures[i]` 更高的温度。如果不存在这样的温度，`answer[i]` 为 `0`。

示例：
输入：`temperatures = [73,74,75,71,69,72,76,73]`
输出：`[1,1,4,2,1,1,0,0]`


## 解法思路：单调栈（从后往前遍历）
我们维护一个**单调递减栈**（栈中存储的是温度的**索引**），从后往前遍历数组：
- 对于当前温度 `temperatures[i]`，弹出栈中所有“小于等于当前温度”的索引（这些索引对应的温度无法成为当前温度的“下一个更高温度”）。
- 栈顶剩余的索引就是“下一个更高温度”的位置，两者索引差即为等待天数。
- 将当前索引压入栈，供前面的温度判断使用。


## 代码逐行解释
```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        // 步骤1：初始化栈和结果数组
        Stack<Integer> stack = new Stack<>(); // 存储温度的索引，维持单调递减
        int[] answer = new int[temperatures.length]; // 存储每个位置的结果
        
        // 步骤2：先将最后一个元素的索引压入栈（最后一个元素的结果一定是0）
        stack.push(temperatures.length - 1); 
        
        // 步骤3：从倒数第二个元素开始，从后往前遍历
        for(int i = temperatures.length - 2; i >= 0; i--) {
            // 步骤4：弹出栈中所有“小于等于当前温度”的索引（这些索引的温度无法作为当前的“下一个更高温度”）
            while(!stack.isEmpty()) {
                if(temperatures[i] >= temperatures[stack.peek()]) { 
                    stack.pop(); // 弹出无效的索引
                } else {
                    // 找到“下一个更高温度”的索引，计算天数差
                    answer[i] = stack.peek() - i;
                    break; // 找到后退出循环
                }
            }
            // 步骤5：将当前索引压入栈，供前面的元素判断
            stack.push(i); 
        }
        
        return answer; // 返回结果数组
    }
}
```


## 核心逻辑拆解
以示例 `temperatures = [73,74,75,71,69,72,76,73]` 为例，逐步分析：

- 初始栈：`[7]`（索引7，温度73）。
- 遍历 `i=6`（温度76）：
  - 栈顶是7（温度73），`76 >= 73`，弹出栈顶，栈空。
  - `answer[6] = 0`，压入6，栈变为`[6]`。
- 遍历 `i=5`（温度72）：
  - 栈顶是6（温度76），`72 < 76`，`answer[5] = 6-5=1`，压入5，栈变为`[6,5]`。
- 遍历 `i=4`（温度69）：
  - 栈顶是5（温度72），`69 < 72`，`answer[4] = 5-4=1`，压入4，栈变为`[6,5,4]`。
- 遍历 `i=3`（温度71）：
  - 栈顶是4（温度69），`71 >= 69`，弹出4；
  - 栈顶是5（温度72），`71 < 72`，`answer[3] = 5-3=2`，压入3，栈变为`[6,5,3]`。
- 以此类推，最终得到结果数组 `[1,1,4,2,1,1,0,0]`。


## 复杂度分析
- **时间复杂度**：O(n)。每个元素最多入栈、出栈各一次，总操作次数为O(n)。
- **空间复杂度**：O(n)。最坏情况下（温度严格递减），栈需要存储所有元素的索引。


这种单调栈的思路高效解决了“下一个更大元素”类问题，是算法面试中的高频考点，建议熟练掌握~
