https://leetcode.cn/problems/largest-rectangle-in-histogram/description/


# 柱状图中的最大矩形（Largest Rectangle in Histogram）- Java 详细题解
柱状图中的最大矩形是算法面试中的经典难题，核心考察「单调栈」的灵活应用。本文将从问题分析、暴力解法（铺垫思路）、优化解法（单调栈，面试重点）逐步拆解，用通俗的语言和实例帮助理解，最终给出完整的 Java 实现。


## 一、题目描述（明确问题边界）
给定 `n` 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1。求在该柱状图中，能够勾勒出来的矩形的最大面积。

### 示例：
- 输入：`heights = [2,1,5,6,2,3]`
- 输出：`10`（对应矩形：高度 5+6 区域的 2 个柱子，高度 2、宽度 5；或高度 5 的柱子宽度 2，高度 6 的柱子宽度 1，最大为 `2*5=10`）
- 图示：
  ```
  6  |     ▇
  5  |  ▇  ▇
  4  |  ▇  ▇
  3  |  ▇  ▇     ▇
  2  |  ▇  ▇  ▇  ▇
  1  | ▇ ▇ ▇ ▇ ▇ ▇
     ------------------
       0 1 2 3 4 5
  ```
  最大矩形是索引 2-3（高度 5、6）为基础，向左右扩展到索引 1-4，高度 2，宽度 5，面积 `2*5=10`。


## 二、核心思路分析
### 关键观察：
每个矩形的面积 = 「高度」×「宽度」，其中「高度」由某一根柱子的高度决定（矩形的高度不能超过任何一根柱子的高度，因此以第 `i` 根柱子为高度的矩形，高度固定为 `heights[i]`）。

因此，问题可转化为：**对于每一根柱子 `i`，找到其左侧第一个比它矮的柱子 `left`，右侧第一个比它矮的柱子 `right`，则以 `heights[i]` 为高度的矩形宽度为 `right - left - 1`，面积为 `heights[i] * (right - left - 1)`**。遍历所有柱子，取面积最大值即可。

### 举个例子：
以 `heights = [2,1,5,6,2,3]` 中索引 2 的柱子（高度 5）为例：
- 左侧第一个比 5 矮的柱子：索引 1（高度 1）
- 右侧第一个比 5 矮的柱子：索引 4（高度 2）
- 宽度 = 4 - 1 - 1 = 2 → 面积 = 5×2=10
- 再看索引 4 的柱子（高度 2）：
  - 左侧第一个比 2 矮的柱子：索引 1（高度 1）
  - 右侧第一个比 2 矮的柱子：索引 6（虚拟边界，高度 0）
  - 宽度 = 6 - 1 - 1 = 4 → 面积 = 2×4=8（不是最大）

### 核心难点：
如何高效找到每根柱子的「左侧第一个更矮元素」和「右侧第一个更矮元素」？
- 暴力法：对每根柱子，向左、向右遍历查找，时间复杂度 O(n²)（不适合大数据）
- 优化法：用「单调栈」在 O(n) 时间内批量找到所有柱子的左右边界（面试重点）


## 三、解法一：暴力解法（思路铺垫）
### 思路：
1. 遍历每根柱子 `i`，以 `heights[i]` 为矩形高度
2. 向左遍历，找到第一个比 `heights[i]` 矮的柱子 `left`（若没有则为 -1）
3. 向右遍历，找到第一个比 `heights[i]` 矮的柱子 `right`（若没有则为 n）
4. 计算面积 `heights[i] * (right - left - 1)`，更新最大值

### Java 代码实现：
```java
public int largestRectangleArea(int[] heights) {
    int n = heights.length;
    int maxArea = 0;
    for (int i = 0; i < n; i++) {
        int height = heights[i];
        // 找左侧第一个更矮的柱子
        int left = i;
        while (left > 0 && heights[left - 1] >= height) {
            left--;
        }
        // 找右侧第一个更矮的柱子
        int right = i;
        while (right < n - 1 && heights[right + 1] >= height) {
            right++;
        }
        // 宽度 = right - left + 1（因为 left 和 right 是当前高度能覆盖的左右边界）
        int width = right - left + 1;
        maxArea = Math.max(maxArea, height * width);
    }
    return maxArea;
}
```

### 复杂度分析：
- 时间复杂度：O(n²)，最坏情况（柱子高度递增，如 `[1,2,3,4,5]`），每根柱子需遍历左右所有元素
- 空间复杂度：O(1)，仅用常数变量

### 缺点：
效率过低，无法通过 LeetCode 上的大数据测试（n 可达 10⁵），仅作为思路铺垫。


## 四、解法二：单调栈（最优解，O(n) 时间）
### 核心思路：
利用「单调递增栈」维护柱子的索引，栈中元素的高度严格递增。当遇到比栈顶元素更矮的柱子时，栈顶元素的「右侧第一个更矮元素」就是当前柱子，而「左侧第一个更矮元素」是新的栈顶元素（因为栈是递增的）。

### 单调栈的作用：
- 栈内元素递增 → 保证栈顶元素的左侧第一个更矮元素是栈顶下一个元素
- 遇到更矮元素时触发弹出 → 弹出时可确定栈顶元素的右侧第一个更矮元素

### 关键技巧：
- 为了避免处理边界情况（如栈空、柱子在数组两端），在 `heights` 数组前后各添加一个「虚拟柱子」，高度为 0（左侧虚拟柱索引 -1，右侧虚拟柱索引 n）。
  - 左侧虚拟柱：确保所有真实柱子都有左侧边界（即使是最左边的柱子，左侧第一个更矮元素也是 -1）
  - 右侧虚拟柱：确保所有真实柱子都能被弹出栈（即使是最右边的柱子，右侧第一个更矮元素也是 n）

### 步骤拆解（小白必懂）：
1. 初始化：创建单调递增栈，压入左侧虚拟柱索引 -1；定义 `maxArea` 记录最大面积。
2. 遍历 `heights` 数组（包含右侧虚拟柱）：
   a. 当当前柱子高度 < 栈顶元素对应的高度时：
      - 弹出栈顶元素 `top`（当前要计算面积的柱子索引）
      - 计算高度：`h = heights[top]`（以 `top` 柱子为高度的矩形高度）
      - 计算宽度：`w = 当前索引 i - 新栈顶元素索引 - 1`（左侧边界是新栈顶，右侧边界是 i）
      - 计算面积 `h * w`，更新 `maxArea`
   b. 否则：将当前索引 `i` 压入栈（维持栈的递增特性）
3. 遍历结束，返回 `maxArea`

### 形象比喻：
单调栈就像「排队的柱子」，要求队伍里的柱子越来越高。当来了一个更矮的柱子时，前面比它高的柱子都无法再向右扩展（因为这根矮柱子是它们的右侧边界），所以需要依次弹出这些高柱子，计算它们能构成的最大矩形面积，然后让新柱子入队。

### Java 代码实现：
```java
import java.util.Stack;

public int largestRectangleArea(int[] heights) {
    int n = heights.length;
    // 步骤1：创建扩展数组，前后添加虚拟柱子（高度0），避免边界处理
    int[] extendedHeights = new int[n + 2];
    for (int i = 0; i < n; i++) {
        extendedHeights[i + 1] = heights[i]; // 中间是原数组
    }

    Stack<Integer> stack = new Stack<>(); // 单调递增栈，存储索引
    stack.push(0); // 先压入左侧虚拟柱索引
    int maxArea = 0;

    // 步骤2：遍历扩展数组（从1到n+1）
    for (int i = 1; i < extendedHeights.length; i++) {
        // 当当前柱子高度 < 栈顶索引对应的高度，弹出栈顶并计算面积
        while (extendedHeights[i] < extendedHeights[stack.peek()]) {
            int top = stack.pop(); // 弹出要计算面积的柱子索引
            int height = extendedHeights[top]; // 矩形高度（栈顶柱子的高度）
            int width = i - stack.peek() - 1; // 宽度 = 右边界i - 左边界（新栈顶） - 1
            maxArea = Math.max(maxArea, height * width);
        }
        // 否则，压入当前索引，维持栈递增
        stack.push(i);
    }

    return maxArea;
}
```

### 逐行代码解析：
1. **扩展数组初始化**：
   - 原数组长度 n，扩展后长度 n+2，前后各加一个 0（虚拟柱）
   - 目的：让所有真实柱子都有左右边界，无需单独处理「栈空」或「最后一根柱子」的情况

2. **栈初始化**：
   - 压入左侧虚拟柱索引 0（高度 0），确保栈不为空，且所有真实柱子的左侧都有参考

3. **遍历扩展数组**：
   - 循环条件 `extendedHeights[i] < extendedHeights[stack.peek()]`：当前柱子比栈顶柱子矮，触发弹出
   - 弹出栈顶 `top`：这根柱子的右侧边界是 `i`，左侧边界是新栈顶（因为栈是递增的，新栈顶柱子一定比 `top` 矮）
   - 计算宽度：`i - stack.peek() - 1`（比如 `top` 左侧是 `left`，右侧是 `i`，中间的宽度是 `i - left - 1`）
   - 更新最大面积：每次计算后与 `maxArea` 比较，保留最大值

4. **压入当前索引**：当当前柱子 >= 栈顶柱子时，压入栈，维持递增特性

### 执行流程模拟（以 `heights = [2,1,5,6,2,3]` 为例）：
扩展数组 `extendedHeights = [0,2,1,5,6,2,3,0]`，遍历过程如下：

| 步骤 | i | extendedHeights[i] | 栈状态（索引） | 操作 | 计算过程 | maxArea |
|------|----|--------------------|----------------|------|----------|---------|
| 1 | 0 | 0 | [0] | 初始化压入 | - | 0 |
| 2 | 1 | 2 | [0,1] | 2 >= 0，压入 | - | 0 |
| 3 | 2 | 1 | [0,1] | 1 < 2，弹出 1 | height=2，width=2-0-1=1 → 面积=2×1=2 | 2 |
| 4 | 2 | 1 | [0] | 1 >= 0，压入 | - | 2 |
| 5 | 3 | 5 | [0,2,3] | 5 >=1，压入 | - | 2 |
| 6 | 4 | 6 | [0,2,3,4] | 6 >=5，压入 | - | 2 |
| 7 | 5 | 2 | [0,2,3,4] | 2 <6，弹出4 | height=6，width=5-3-1=1 → 6×1=6 | 6 |
| 8 | 5 | 2 | [0,2,3] | 2 <5，弹出3 | height=5，width=5-2-1=2 →5×2=10 | 10 |
| 9 | 5 | 2 | [0,2] | 2 >=1，压入 | - | 10 |
| 10 | 6 |3 | [0,2,5,6] |3 >=2，压入 | - |10 |
| 11 |7 |0 | [0,2,5,6] |0 <3，弹出6 |height=3，width=7-5-1=1 →3×1=3 |10 |
| 12 |7 |0 | [0,2,5] |0 <2，弹出5 |height=2，width=7-2-1=4 →2×4=8 |10 |
| 13 |7 |0 | [0,2] |0 <1，弹出2 |height=1，width=7-0-1=6 →1×6=6 |10 |
| 14 |7 |0 | [0] |0 >=0，压入 | - |10 |

最终 `maxArea=10`，与示例结果一致！


## 五、复杂度分析（面试必问）
- **时间复杂度**：O(n)
  - 每个元素（包括扩展后的虚拟柱）最多入栈、出栈各一次，总操作次数为 O(n+2) = O(n)
  - 遍历扩展数组的时间为 O(n)，整体时间复杂度 O(n)

- **空间复杂度**：O(n)
  - 栈的最大长度为 O(n)（最坏情况：扩展数组严格递增，如 `[0,1,2,3,0]`，栈内会存储 0,1,2,3）
  - 扩展数组占用 O(n) 空间，整体空间复杂度 O(n)


## 六、常见面试扩展题
### 扩展题 1：最大矩形（LeetCode 85）
#### 题目描述：
给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。
#### 思路：
将二维矩阵转化为柱状图问题：
- 每一行作为柱状图的底，该行及上方连续的 1 的数量作为柱子高度
- 例如矩阵：
  ```
  1 0 1 0 0
  1 0 1 1 1
  1 1 1 1 1
  1 0 0 1 0
  ```
  第 0 行柱状图：`[1,0,1,0,0]`
  第 1 行柱状图：`[2,0,2,1,1]`
  第 2 行柱状图：`[3,1,3,2,2]`
  第 3 行柱状图：`[4,0,0,3,0]`
- 对每一行的柱状图，调用本文的「最大矩形面积」方法，取最大值即可。

### 扩展题 2：接雨水（LeetCode 42）
#### 题目描述：
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
#### 关联：
与本题同为「单调栈」的经典应用，核心都是「找左右边界」：
- 接雨水是找每根柱子左右两侧的「第一个更高元素」，计算能存储的雨水量
- 本题是找每根柱子左右两侧的「第一个更矮元素」，计算能构成的矩形面积


## 七、总结（小白必记）
1. 柱状图最大矩形的核心思路：**以每根柱子为高度，找左右第一个更矮元素，计算面积取最大**。
2. 单调栈是最优解法的核心：
   - 栈特性：单调递增，维护柱子索引
   - 边界处理：前后加虚拟柱（高度 0），避免栈空和末尾元素无法弹出
   - 计算逻辑：弹出栈顶时，右侧边界是当前索引，左侧边界是新栈顶
3. 时间复杂度 O(n)，空间复杂度 O(n)，适合大数据场景（n 可达 10⁵）。
4. 拓展性强：可迁移到二维矩阵最大矩形、接雨水等问题，是面试高频考点。

建议多动手模拟单调栈的执行流程（如示例中的步骤），理解「弹出即计算」的核心逻辑，就能熟练掌握这类「找左右边界」的单调栈问题～
