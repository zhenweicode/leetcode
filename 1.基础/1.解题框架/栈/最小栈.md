https://leetcode.cn/problems/min-stack/description/?envType=study-plan-v2&envId=top-100-liked

# 最小栈（Min Stack）实现详解（单栈元组版 - Java）

这是一种**简洁高效**的最小栈实现方式，核心思路是**在单个栈中存储“值 + 当前最小值”的元组**，从而在 O(1) 时间内完成 `push`、`pop`、`top` 和 `getMin` 操作。下面从代码结构到逻辑细节逐一解析。


## 代码整体结构

```java
class MinStack {
    private Stack<int[]> stack = new Stack<>();

    public MinStack() {}

    public void push(int val) {
        stack.push(new int[]{val, Math.min(getMin(), val)});
    }

    public void pop() {
        stack.pop();
    }

    public int top() {
        return stack.peek()[0];
    }

    public int getMin() {
        if(stack.isEmpty()) {
            return Integer.MAX_VALUE;
        }
        return stack.peek()[1];
    }
}
```


## 核心思路解析

该实现的关键是**将“当前值”和“以该值为栈顶时的全局最小值”绑定为一个数组元组**，存储在同一个栈中。这样，每次操作时只需访问栈顶元组，就能同时获取值和当前最小值。


## 方法逐行详解

### 1. 成员变量 - 存储元组的栈
```java
private Stack<int[]> stack = new Stack<>();
```
- 栈中每个元素是一个 `int[2]` 数组：
  - `int[0]` 存储**当前入栈的值**；
  - `int[1]` 存储**以该值为栈顶时的全局最小值**。


### 2. 构造方法
```java
public MinStack() {}
```
- 无特殊初始化操作，栈默认为空。


### 3. `push` 方法 - 压入元素并维护最小值
```java
public void push(int val) {
    stack.push(new int[]{val, Math.min(getMin(), val)});
}
```
- 每次压入新值时，需要计算**新的全局最小值**：
  - 新最小值 = `Math.min(当前栈的最小值, 新值val)`；
  - 将“新值 `val`”和“新最小值”封装成元组，压入栈中。


### 4. `pop` 方法 - 弹出栈顶元素
```java
public void pop() {
    stack.pop();
}
```
- 直接弹出栈顶的元组，同时“当前最小值”的记录也会被同步移除（因为元组包含了对应状态的最小值）。


### 5. `top` 方法 - 获取栈顶值
```java
public int top() {
    return stack.peek()[0];
}
```
- 访问栈顶元组的第 0 位（存储的是“当前值”）。


### 6. `getMin` 方法 - 获取当前最小值
```java
public int getMin() {
    if(stack.isEmpty()) {
        return Integer.MAX_VALUE;
    }
    return stack.peek()[1];
}
```
- 若栈为空，返回 `Integer.MAX_VALUE`（作为初始哨兵，避免空栈异常）；
- 否则，访问栈顶元组的第 1 位（存储的是“当前最小值”）。
