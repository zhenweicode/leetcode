https://leetcode.cn/problems/decode-string/description/?envType=study-plan-v2&envId=top-100-liked


# 字符串解码问题（Decode String）- Java 详细解法

字符串解码是算法面试中的经典栈应用问题，核心是处理「数字 + [字符串]」的嵌套结构（如 `3[a2[bc]]` → `abcbcabcbcabcbc`）。本文将提供两种主流解法（栈、递归），从思路拆解到代码实现，逐步讲解，小白也能看懂。


## 一、题目描述（明确边界）
给定一个经过编码的字符串，返回它解码后的字符串。
编码规则：`k[encoded_string]`，表示其中 `encoded_string` 正好重复 `k` 次（`k` 为正整数）。
- 约束：
  1. `k` 是正整数（可以是多位数，如 `10[a]` → `aaaaaaaaaa`）
  2. 编码字符串可以嵌套（如 `2[3[a]b]` → `aaabaaab`）
  3. 原始字符串仅包含小写字母、数字、`[` 和 `]`
  4. 保证输入字符串有效（无需处理非法情况）

示例：
- 输入：`"3[a]"` → 输出：`"aaa"`
- 输入：`"3[a2[bc]]"` → 输出：`"abcbcabcbcabcbc"`
- 输入：`"2[abc]3[cd]ef"` → 输出：`"abcabccdcdcdef"`
- 输入：`"10[a]"` → 输出：`"aaaaaaaaaa"`


## 二、核心思路分析
编码字符串的关键特征是「数字 + [子串]」的嵌套/并列结构，解码的核心是：
1. 识别「数字」（可能是多位数）和「待重复子串」
2. 处理嵌套结构（内层子串先解码，再参与外层重复）

适合的数据结构/算法：
- **栈**：天然适合处理嵌套问题（先进后出，内层处理完弹出，外层再利用）
- **递归**：嵌套结构可拆分为「外层数字 + 内层子问题」，递归求解内层再拼接

下面重点讲解面试高频的「栈解法」，再补充「递归解法」作为拓展。


## 三、解法一：栈解法（面试首选）
### 思路拆解（小白必懂）
用两个栈分别存储「待乘的数字」和「待拼接的字符串」，遍历字符串时按字符类型处理：
1. **遇到数字**：累积计算多位数（如 `123[a]` 需先计算 `1*10 + 2 = 12`，再 `12*10 +3=123`）
2. **遇到 `[`**：
   - 将当前累积的数字压入「数字栈」，并重置数字累积器
   - 将当前已拼接的字符串压入「字符串栈」，并重置当前字符串（准备接收 `[` 后的子串）
3. **遇到 `]`**：
   - 弹出「数字栈」顶的数字 `k`（当前子串的重复次数）
   - 弹出「字符串栈」顶的字符串 `prevStr`（`[` 之前已拼接的字符串）
   - 将当前子串 `currStr` 重复 `k` 次，与 `prevStr` 拼接，更新为新的 `currStr`
4. **遇到小写字母**：直接追加到当前字符串 `currStr` 中

### 形象比喻
栈就像「临时储物柜」：
- 遇到 `[` 时，把之前的数字和字符串「存起来」，专心处理括号内的子串
- 遇到 `]` 时，把「存起来」的数字和字符串「取出来」，将处理好的子串重复后拼接回去

### 代码实现（Java）
```java
import java.util.Stack;

public class DecodeString {
    public String decodeString(String s) {
        // 栈1：存储待乘的数字（处理多位数和嵌套）
        Stack<Integer> numStack = new Stack<>();
        // 栈2：存储待拼接的字符串（处理嵌套时的前缀）
        Stack<StringBuilder> strStack = new Stack<>();
        // 当前正在拼接的字符串（括号内或括号外的普通子串）
        StringBuilder currStr = new StringBuilder();
        // 当前累积的数字（处理多位数，如 123[a] 中的 123）
        int currNum = 0;

        for (char c : s.toCharArray()) {
            if (Character.isDigit(c)) {
                // 情况1：遇到数字，累积计算（多位数处理）
                currNum = currNum * 10 + (c - '0'); // 字符转数字：'0'的ASCII是48，c-'0'得到实际数值
            } else if (c == '[') {
                // 情况2：遇到'['，将当前数字和字符串入栈，重置临时变量
                numStack.push(currNum);
                strStack.push(currStr);
                currNum = 0; // 重置数字累积器
                currStr = new StringBuilder(); // 重置当前字符串，准备接收括号内的子串
            } else if (c == ']') {
                // 情况3：遇到']'，弹出栈中数据，拼接字符串
                int k = numStack.pop(); // 子串重复次数
                StringBuilder prevStr = strStack.pop(); // 括号前的前缀字符串

                // 将当前子串 currStr 重复 k 次，追加到 prevStr 后
                for (int i = 0; i < k; i++) {
                    prevStr.append(currStr);
                }

                // 更新 currStr 为拼接后的结果（作为下一层的前缀或最终结果）
                currStr = prevStr;
            } else {
                // 情况4：遇到小写字母，直接追加到当前字符串
                currStr.append(c);
            }
        }

        return currStr.toString();
    }

    // 测试代码
    public static void main(String[] args) {
        DecodeString solution = new DecodeString();
        System.out.println(solution.decodeString("3[a]")); // 输出 "aaa"
        System.out.println(solution.decodeString("3[a2[bc]]")); // 输出 "abcbcabcbcabcbc"
        System.out.println(solution.decodeString("2[abc]3[cd]ef")); // 输出 "abcabccdcdcdef"
        System.out.println(solution.decodeString("10[a]")); // 输出 "aaaaaaaaaa"
    }
}
```

### 逐行代码解析
1. **栈和临时变量初始化**：
   - `numStack`：存数字（如 `3`、`2`）
   - `strStack`：存字符串（如 `""`、`"a"`）
   - `currStr`：存当前正在处理的子串（如 `bc`、`abcbc`）
   - `currNum`：存当前累积的数字（处理多位数）

2. **数字处理（`Character.isDigit(c)`）**：
   - 例如 `'1'` 转数字：`c - '0' = 49 - 48 = 1`
   - 多位数处理：`currNum * 10 + (c - '0')`（如 `123`：`0*10+1=1` → `1*10+2=12` → `12*10+3=123`）

3. **`[` 处理**：
   - 把之前累积的 `currNum`（如 `3`）和 `currStr`（如 `""`）入栈
   - 重置 `currNum` 和 `currStr`，准备接收括号内的子串（如 `a` 或 `bc`）

4. **`]` 处理（核心）**：
   - 弹出 `k`（如 `2`）和 `prevStr`（如 `a`）
   - 把 `currStr`（如 `bc`）重复 `k` 次（`bcbc`），追加到 `prevStr` 后（`abcbc`）
   - 更新 `currStr` 为 `prevStr`，供后续拼接（如外层的 `3` 次重复）

5. **字母处理**：直接追加到 `currStr`（如 `ef` 直接加到 `abcabccdcdcd` 后）

### 执行流程模拟（以 `3[a2[bc]]` 为例）
| 字符 | 操作 | currNum | currStr | numStack | strStack | 备注 |
|------|------|---------|---------|----------|----------|------|
| '3' | 数字累积 | 3 | "" | [] | [] | 累积数字 3 |
| '[' | 入栈 | 0 | "" | [3] | [""] | 重置 currNum 和 currStr |
| 'a' | 追加 | 0 | "a" | [3] | [""] | currStr 变为 "a" |
| '2' | 数字累积 | 2 | "a" | [3] | [""] | 累积数字 2 |
| '[' | 入栈 | 0 | "" | [3,2] | ["", "a"] | 重置 currNum 和 currStr |
| 'b' | 追加 | 0 | "b" | [3,2] | ["", "a"] | currStr 变为 "b" |
| 'c' | 追加 | 0 | "bc" | [3,2] | ["", "a"] | currStr 变为 "bc" |
| ']' | 弹出拼接 | 0 | "abcbc" | [3] | [""] | k=2，prevStr="a" → "a"+"bc"+"bc"="abcbc" |
| ']' | 弹出拼接 | 0 | "abcbcabcbcabcbc" | [] | [] | k=3，prevStr="" → 3次"abcbc"拼接 |
| 结束 | 返回结果 | - | "abcbcabcbcabcbc" | [] | [] | 最终解码结果 |

### 复杂度分析
- **时间复杂度**：O(n)，其中 `n` 是解码后字符串的长度。每个字符入栈、出栈、拼接操作的总次数与解码后长度线性相关（重复部分的拼接次数已计入 `n`）。
- **空间复杂度**：O(m)，其中 `m` 是嵌套层数 + 多位数的最大长度。栈存储的数字和字符串长度与嵌套深度成正比（最坏情况如 `1[1[1[...[a]...]]]`，栈深度等于嵌套层数）。


## 四、解法二：递归解法（拓展思路）
### 思路拆解
递归的核心是「把嵌套问题拆分为子问题」：
1. 遍历字符串，遇到数字累积计算 `k`
2. 遇到 `[` 时，递归求解 `[` 到 `]` 之间的子串（子问题）
3. 遇到 `]` 时，返回当前子串（递归终止条件）
4. 遇到字母直接追加到结果中
5. 子问题求解完成后，将结果重复 `k` 次，与前面的字符串拼接

### 代码实现（Java）
```java
public class DecodeStringRecursive {
    // 全局索引，用于记录递归过程中当前遍历到的位置（避免传参繁琐）
    private int index = 0;

    public String decodeString(String s) {
        StringBuilder result = new StringBuilder();
        int currNum = 0;

        while (index < s.length()) {
            char c = s.charAt(index);
            if (Character.isDigit(c)) {
                // 情况1：遇到数字，累积计算
                currNum = currNum * 10 + (c - '0');
                index++; // 移动到下一个字符
            } else if (c == '[') {
                // 情况2：遇到'['，递归处理括号内的子串
                index++; // 跳过'['，进入子串
                String subStr = decodeString(s); // 递归求解子问题
                // 将子串重复 currNum 次，追加到结果中
                for (int i = 0; i < currNum; i++) {
                    result.append(subStr);
                }
                currNum = 0; // 重置数字累积器
            } else if (c == ']') {
                // 情况3：遇到']'，递归终止，返回当前结果
                index++; // 跳过']'，回到上一层
                return result.toString();
            } else {
                // 情况4：遇到字母，直接追加
                result.append(c);
                index++; // 移动到下一个字符
            }
        }

        return result.toString();
    }

    // 测试代码
    public static void main(String[] args) {
        DecodeStringRecursive solution = new DecodeStringRecursive();
        System.out.println(solution.decodeString("3[a]")); // "aaa"
        System.out.println(solution.decodeString("3[a2[bc]]")); // "abcbcabcbcabcbc"
        System.out.println(solution.decodeString("2[abc]3[cd]ef")); // "abcabccdcdcdef"
    }
}
```

### 核心逻辑解析
- **全局索引 `index`**：递归过程中需要共享遍历位置，避免每次递归都重新开始（如处理完内层 `]` 后，外层需从 `]` 的下一个字符继续遍历）。
- **递归终止条件**：遇到 `]` 时，返回当前拼接的子串，供上层重复使用。
- **子问题拆分**：`3[a2[bc]]` 拆分为：
  1. 外层 `k=3`，子问题是 `a2[bc]`
  2. 子问题 `a2[bc]` 拆分为 `a` + 内层 `k=2`，子问题 `bc`
  3. 内层子问题返回 `bc`，重复 2 次得 `bcbc`，与 `a` 拼接得 `abcbc`
  4. 外层重复 3 次 `abcbc`，得最终结果

### 复杂度分析
- **时间复杂度**：O(n)，同栈解法，解码后字符串长度为 `n`。
- **空间复杂度**：O(m)，`m` 是嵌套层数（递归调用栈的深度等于嵌套层数，最坏情况如 `1[1[1[...[a]...]]]`）。


## 五、两种解法对比
| 解法 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| 栈解法 | 直观易懂，无递归栈溢出风险 | 需维护两个栈，代码稍长 | 面试首选（大部分面试官期待栈解法） |
| 递归解法 | 代码简洁，逻辑清晰 | 嵌套过深时可能栈溢出（Java 默认递归深度约 1000） | 拓展思路，适合嵌套不深的场景 |

**面试建议**：优先掌握栈解法，递归解法作为补充，可在面试官问「是否有其他解法」时提及。


## 六、常见面试扩展题
### 扩展题 1：包含大写字母的解码
题目：编码字符串包含大写字母（如 `2[A3[B]]` → `ABBBABBB`），其余规则不变。
解法：无需修改核心逻辑，只需将「小写字母判断」改为「字母判断」（`Character.isLetter(c)`），因为大写字母同样直接追加到 `currStr`。

### 扩展题 2：支持字母和数字混合的原始字符串
题目：原始字符串可包含数字（非编码数字，如 `3[a10[b]]` → `abbbbbbbbbbabbbbbbbbbbabbbbbbbbbb`），编码数字仅出现在 `[` 前。
解法：核心是区分「编码数字」和「原始数字」：编码数字一定在 `[` 前，原始数字直接作为字符追加。栈解法无需修改，因为只有 `[` 前的数字会被累积到 `currNum`，其他位置的数字会被当作普通字符处理。

### 扩展题 3：解码并返回最长子串
题目：解码字符串后，返回最长的连续相同字符子串长度（如 `3[a2[bc]]` 解码后是 `abcbcabcbcabcbc`，最长子串是 `bc`（长度 2），返回 2；`10[a]` 返回 10）。
解法：先解码字符串，再遍历解码后的字符串，统计最长连续相同字符长度。


## 七、总结
1. 字符串解码的核心是「处理嵌套结构和多位数」，栈是最适合的工具（先进后出匹配嵌套）。
2. 栈解法的关键是「双栈分工」：数字栈存重复次数，字符串栈存前缀，`[` 入栈、`]` 出栈拼接。
3. 递归解法的关键是「全局索引 + 子问题拆分」，代码简洁但需注意栈溢出风险。
4. 拓展题均围绕「核心逻辑不变，仅调整字符处理范围」，掌握基础解法后可举一反三。

建议多动手模拟栈的执行流程（如 `3[a2[bc]]`），加深对嵌套处理的理解，面试时就能快速写出代码～
