https://leetcode.cn/problems/sliding-window-maximum/description/?envType=study-plan-v2&envId=top-100-liked


# 滑动窗口最大值（Sliding Window Maximum）- Java 详细题解
滑动窗口最大值是算法面试中的高频题目，核心考察「如何在滑动窗口移动过程中，高效维护最大值」。本文将从暴力解法（思路铺垫）、最优解法（单调队列，面试重点）逐步拆解，结合实例和代码逐行解释，并补充常见扩展场景，小白也能轻松理解。


## 一、题目描述（明确边界）
给定一个整数数组 `nums` 和一个滑动窗口大小 `k`，请找出所有滑动窗口里的最大值。

### 示例：
- 输入：`nums = [1,3,-1,-3,5,3,6,7]`, `k = 3`
- 输出：`[3,3,5,5,6,7]`
- 滑动窗口过程：
  ```
  窗口1：[1,3,-1] → 最大值 3
  窗口2：[3,-1,-3] → 最大值 3
  窗口3：[-1,-3,5] → 最大值 5
  窗口4：[-3,5,3] → 最大值 5
  窗口5：[5,3,6] → 最大值 6
  窗口6：[3,6,7] → 最大值 7
  ```


## 二、核心思路分析
滑动窗口的特点是「窗口右移时，移除左侧元素，加入右侧新元素」。核心痛点是：**如何避免每次窗口移动后都遍历窗口找最大值（O(k) 时间），从而优化整体效率**。

关键观察：
- 窗口内的「较小元素」永远不可能成为后续窗口的最大值（比如窗口 `[1,3,-1]` 中，1 比 3 小，即使窗口右移到 `[3,-1,-3]`，1 已被移除，且 3 始终是更大值）。
- 因此，可维护一个「单调递减队列」，队列中只保留「可能成为最大值的元素索引」，确保队列头部始终是当前窗口的最大值索引。


## 三、解法一：暴力解法（思路铺垫）
### 思路：
1. 遍历所有可能的滑动窗口（窗口数量 = `nums.length - k + 1`）。
2. 对每个窗口，遍历其中 `k` 个元素，找到最大值。
3. 收集所有窗口的最大值，返回结果。

### Java 代码实现：
```java
public int[] maxSlidingWindow(int[] nums, int k) {
    int n = nums.length;
    if (n == 0 || k == 0) return new int[0];
    int resultLength = n - k + 1;
    int[] result = new int[resultLength];
    
    // 遍历每个滑动窗口
    for (int i = 0; i < resultLength; i++) {
        int max = nums[i];
        // 遍历窗口内的元素，找最大值
        for (int j = i; j < i + k; j++) {
            max = Math.max(max, nums[j]);
        }
        result[i] = max;
    }
    return result;
}
```

### 复杂度分析：
- 时间复杂度：O(nk)，`n` 是数组长度，每个窗口遍历 `k` 个元素，最坏情况（k= n/2）效率极低。
- 空间复杂度：O(n - k + 1)，存储结果数组，无额外空间开销。

### 缺点：
无法通过大数据测试（如 `n=10^5` 时，O(nk) 会超时），仅作为思路铺垫。


## 四、解法二：单调队列（最优解，O(n) 时间）
### 核心思路：
维护一个「单调递减队列」（队列存储元素索引，对应的元素值严格递减），窗口滑动时做三件事：
1. **移除过期元素**：队列头部元素若超出当前窗口左边界（索引 ≤ 当前窗口左边界 - 1），则移除（因为已不在窗口内）。
2. **移除无效元素**：新元素加入窗口时，移除队列尾部所有「值 ≤ 新元素」的索引（这些元素不可能成为后续窗口的最大值，因为新元素更大且更靠后）。
3. **加入新元素**：将新元素的索引加入队列尾部。
4. **记录最大值**：当前窗口的最大值就是队列头部元素对应的数值（窗口完全形成后开始记录）。

### 单调队列的「神奇之处」：
- 队列始终保持「递减顺序」，头部是窗口最大值索引，无需遍历窗口。
- 每个元素最多入队、出队各一次，整体时间复杂度 O(n)。

### 形象比喻：
单调队列就像「窗口内的精英榜」，只留「有能力竞争最大值」的元素：
- 过期的（超出窗口）直接淘汰；
- 比新元素弱的（值更小）也淘汰（新元素更年轻、更强）；
- 精英榜的榜首就是当前窗口的最大值。

### Java 代码实现（用 Deque 实现单调队列）
```java
import java.util.Deque;
import java.util.LinkedList;

public int[] maxSlidingWindow(int[] nums, int k) {
    int n = nums.length;
    if (n == 0 || k == 0) return new int[0];
    
    Deque<Integer> deque = new LinkedList<>(); // 单调递减队列，存储索引
    int[] result = new int[n - k + 1];
    int resultIndex = 0;

    for (int i = 0; i < n; i++) {
        // 1. 移除过期元素：队列头部元素超出当前窗口左边界（i - k 是窗口左边界）
        if (!deque.isEmpty() && deque.peekFirst() <= i - k) {
            deque.pollFirst();
        }

        // 2. 移除无效元素：队列尾部元素值 <= 当前元素，这些元素不可能成为最大值
        while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {
            deque.pollLast();
        }

        // 3. 加入当前元素索引
        deque.offerLast(i);

        // 4. 窗口完全形成（i >= k-1）后，记录最大值（队列头部）
        if (i >= k - 1) {
            result[resultIndex++] = nums[deque.peekFirst()];
        }
    }

    return result;
}
```

### 逐行代码解析：
1. **初始化**：
   - `deque`：用 `LinkedList` 实现 `Deque`（双端队列，支持头部和尾部操作），存储元素索引。
   - `result`：存储每个窗口的最大值，长度 = `n - k + 1`。
   - `resultIndex`：结果数组的填充索引。

2. **遍历数组（i 是当前元素索引）**：
   - **步骤1：移除过期元素**：
     - 窗口左边界 = `i - k`（比如 k=3，i=3 时，窗口左边界是 0，索引 ≤ -1 的元素过期）。
     - 队列头部元素若 ≤ 左边界 - 1（即 `i - k`），说明已不在窗口内，移除。
   - **步骤2：移除无效元素**：
     - 循环判断队列尾部元素对应的数值是否 ≤ 当前元素 `nums[i]`。
     - 若是，这些元素比当前元素小，且当前元素更靠后，后续窗口中它们不可能成为最大值，直接移除。
     - 这一步确保队列是「单调递减」的。
   - **步骤3：加入当前元素索引**：
     - 经过前两步，队列尾部元素对应的数值一定 > 当前元素，加入后仍保持递减。
   - **步骤4：记录最大值**：
     - 当 `i >= k-1` 时，窗口首次完全形成（比如 k=3，i=2 时窗口是 [0,1,2]），之后每次 i 递增，窗口右移。
     - 队列头部元素是当前窗口的最大值索引，将对应数值存入结果数组。

### 执行流程模拟（以 `nums = [1,3,-1,-3,5,3,6,7]`, `k=3` 为例）：
| i（当前索引） | nums[i] | 队列操作（元素为索引） | 队列状态（索引→值） | 窗口范围 | 最大值（结果） |
|---------------|---------|------------------------|---------------------|----------|----------------|
| 0             | 1       | 队列为空，加入 0       | [0→1]               | 未形成   | -              |
| 1             | 3       | 3>1，移除 0，加入 1    | [1→3]               | 未形成   | -              |
| 2             | -1      | -1≤3，加入 2           | [1→3, 2→-1]         | [0,1,2]  | 3（result[0]） |
| 3             | -3      | 1 > 3-3=0（不过期），-3≤-1，加入3 | [1→3,2→-1,3→-3] | [1,2,3]  | 3（result[1]） |
| 4             | 5       | 1 ≤4-3=1（过期，移除1）；-1≤5（移除2）；-3≤5（移除3）；加入4 | [4→5] | [2,3,4]  |5（result[2]）|
| 5             | 3       | 4>5-3=2（不过期），3≤5，加入5 | [4→5,5→3]         | [3,4,5]  |5（result[3]）|
| 6             | 6       |4 ≤6-3=3（过期，移除4）；3≤6（移除5）；加入6 | [6→6]         | [4,5,6]  |6（result[4]）|
| 7             |7        |6>7-3=4（不过期）；7>6（移除6）；加入7 | [7→7]         | [5,6,7]  |7（result[5]）|

最终结果数组 `[3,3,5,5,6,7]`，与示例一致！


## 五、复杂度分析（面试必问）
- **时间复杂度**：O(n)
  - 每个元素最多入队、出队各一次，总操作次数 O(n)。
  - 遍历数组的时间 O(n)，无嵌套循环。
- **空间复杂度**：O(k)
  - 队列的最大长度为 k（窗口大小），最坏情况（数组严格递减）队列存储 k 个元素。
  - 结果数组空间 O(n - k + 1)，不计入额外空间（题目要求输出结果）。


## 六、常见面试扩展题
### 扩展题 1：滑动窗口最小值
- 题目：给定数组和窗口大小 k，找出所有滑动窗口的最小值。
- 思路：将「单调递减队列」改为「单调递增队列」，队列头部始终是窗口最小值索引。
- 核心修改：
  - 移除无效元素时，改为「移除队列尾部所有值 ≥ 当前元素的索引」。
  - 窗口最大值改为队列头部对应的数值。

### 扩展题 2：固定窗口大小，允许窗口内最多 m 个不同元素，求最大窗口和
- 题目：给定数组（含正负数）、窗口大小 k、最多 m 个不同元素，找出满足条件的窗口的最大和。
- 思路：
  - 用哈希表维护窗口内不同元素的计数。
  - 用前缀和快速计算窗口和。
  - 结合滑动窗口，当不同元素数量超过 m 时，左边界右移，直到满足条件。

### 扩展题 3：无固定窗口大小，找出和 ≤ target 的最长窗口长度
- 题目：给定非负整数数组和 target，找出和 ≤ target 的最长连续子数组长度（窗口大小不固定）。
- 思路：
  - 双指针（滑动窗口）维护窗口左边界，右边界递增。
  - 当窗口和 > target 时，左边界右移，更新窗口和。
  - 记录最长窗口长度（无需单调队列，因为数组非负，窗口和随左边界右移递减）。

### 扩展题 4：滑动窗口最大值的进阶优化（空间 O(1)）
- 题目：在不使用额外队列的情况下，实现滑动窗口最大值（要求空间 O(1)）。
- 思路：分块法（Block Method）。
  - 将数组分成若干块，每块大小为 k（最后一块可能不足 k）。
  - 预处理两个数组：
    - `leftMax[i]`：从块的起始到 i 的最大值（块内从左到右）。
    - `rightMax[i]`：从 i 到块的结束的最大值（块内从右到左）。
  - 对于窗口 `[L, R]`，最大值 = `max(rightMax[L], leftMax[R])`（窗口可能跨两个块）。
- 复杂度：时间 O(n)，空间 O(n)（虽不是严格 O(1)，但无额外队列，是常见优化思路）。


## 七、小白常见问题（避坑指南）
1. 为什么队列存储「索引」而不是「数值」？
   - 因为需要判断元素是否超出窗口（通过索引计算边界），存储数值无法判断过期。
2. 为什么用 `Deque` 而不是 `Stack`？
   - `Stack` 是单向栈，只能操作栈顶；`Deque` 是双端队列，支持头部（移除过期元素）和尾部（移除无效元素）操作，更灵活。
3. 窗口什么时候开始记录最大值？
   - 当 `i >= k-1` 时，窗口首次完全形成（比如 k=3，i=2 时窗口包含 0、1、2 三个元素），之后每次 i 递增，窗口右移，都要记录最大值。
4. 单调队列的「递减」是严格递减吗？
   - 可以是「非递增」（允许相等元素），但本文用「严格递减」（移除 `nums[deque.peekLast()] <= nums[i]` 中的等号），两者都正确，核心是确保无效元素被移除。


## 八、总结（小白必记）
1. 滑动窗口最大值的核心是「单调递减队列」，维护可能成为最大值的元素索引。
2. 队列操作三步骤：移除过期元素 → 移除无效元素 → 加入新元素，窗口形成后记录头部最大值。
3. 时间复杂度 O(n)，空间复杂度 O(k)，是面试中的最优解法。
4. 扩展题的核心是「灵活调整单调队列的增减性」或「结合哈希表、前缀和等工具」，解决不同约束条件的滑动窗口问题。

建议多动手模拟队列的执行流程（如示例中的 8 步），理解「过期元素」和「无效元素」的移除逻辑，就能熟练掌握这类问题～
