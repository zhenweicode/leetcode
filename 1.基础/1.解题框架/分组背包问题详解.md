


# 分组背包问题（详细解析+推导+示例+变种）
分组背包是背包问题的四大核心类型之一（01背包、完全背包、多重背包、分组背包），核心特征是「物品按组划分，每组最多选1个物品」。本文将从**问题本质→状态推导→优化逻辑→遍历顺序→实战示例→常见变种**全方位拆解，帮你彻底掌握分组背包。


## 一、分组背包核心定义
### 1. 问题要素
- **物品**：共 `m` 组，第 `i` 组包含 `k_i` 个物品（组内物品相互排斥，选了组内A就不能选组内B）。
- **物品属性**：第 `i` 组的第 `j` 个物品，重量（或体积）为 `w[i][j]`，价值为 `val[i][j]`（若不考虑价值，仅关注能否装满/组合数，可简化属性）。
- **背包**：最大容量为 `C`（承载的重量/体积上限）。
- **目标**：在不超过背包容量的前提下，选择若干组（每组最多1个物品），求「最大价值、能否装满、组合数」等（和其他背包目标一致，仅状态转移适配分组规则）。

### 2. 与其他背包的区别
| 背包类型       | 核心规则                  | 关键差异点                  |
|----------------|---------------------------|-----------------------------|
| 01背包         | 每个物品最多选1个         | 无分组，物品独立            |
| 完全背包       | 每个物品可选无限次        | 无分组，物品可重复选        |
| 多重背包       | 每个物品最多选k次         | 无分组，物品有限次重复选    |
| 分组背包       | 每组最多选1个物品         | 有分组，组内互斥、组间独立  |

### 3. 生活场景类比
- 旅游打包：衣服分「上衣组」（T恤、衬衫、卫衣）、「裤子组」（牛仔裤、运动裤）、「鞋子组」（运动鞋、皮鞋），每组选1件，背包容量有限，求穿搭总价值最高。
- 考试选课：课程分「数学组」（高数、线代）、「英语组」（四六级、雅思），每组选1门课备考，备考时间（容量）有限，求得分最高。


## 二、分组背包的DP推导（从二维到一维）
分组背包的推导逻辑**基于01背包**，但需适配「组内互斥」的规则，核心是「先遍历组，再处理组内物品」。

### 1. 第一步：二维DP推导（基础版）
#### 状态定义
`dp[i][j]`：考虑前 `i` 组物品，背包容量为 `j` 时，能获得的最大价值（目标为最大价值时）。

#### 状态转移方程（核心逻辑）
对第 `i` 组，有两种选择：「不选该组任何物品」或「选该组某一个物品」，取两者最大值：
1. **不选第 `i` 组**：价值延续前 `i-1` 组的结果 → `dp[i][j] = dp[i-1][j]`。
2. **选第 `i` 组的第 `k` 个物品**（`k` 从0到 `k_i-1`）：
   - 前提：背包容量 `j >= w[i][k]`（装得下该物品）。
   - 价值 = 前 `i-1` 组在容量 `j - w[i][k]` 时的最大价值 + 当前物品价值 → `dp[i-1][j - w[i][k]] + val[i][k]`。
3. 最终状态转移：
```
dp[i][j] = max( dp[i-1][j],  max{ dp[i-1][j - w[i][k]] + val[i][k] | 0<=k<k_i, j>=w[i][k] } )
```
→ 先取组内所有可选物品的最大值，再和「不选该组」的结果比较。

#### 初始化
- `dp[0][j] = 0`（前0组物品，无论容量多大，价值都是0）。
- `dp[i][0] = 0`（背包容量为0，无法装任何物品，价值0）。

#### 二维DP示例代码（直观版）
假设物品分组为 `w = {{2,3}, {1,4}}`（2组：第1组2个物品，重量2、3；第2组2个物品，重量1、4），价值 `val = {{3,4}, {2,5}}`，背包容量 `C=5`：
```java
public static int groupPack2D(int[][] w, int[][] val, int C) {
    int m = w.length; // 组数
    int[][] dp = new int[m+1][C+1]; // 前i组、容量j的最大价值
    
    // 遍历前i组（i从1到m，对应原数组0~m-1组）
    for (int i = 1; i <= m; i++) {
        // 遍历背包容量（j从1到C）
        for (int j = 1; j <= C; j++) {
            // 初始值：不选第i组，价值=前i-1组的dp[i-1][j]
            dp[i][j] = dp[i-1][j];
            
            // 遍历第i组的所有物品（原数组第i-1组）
            int[] groupW = w[i-1];
            int[] groupV = val[i-1];
            for (int k = 0; k < groupW.length; k++) {
                // 若容量足够，尝试选第k个物品，更新最大价值
                if (j >= groupW[k]) {
                    dp[i][j] = Math.max(dp[i][j], dp[i-1][j - groupW[k]] + groupV[k]);
                }
            }
        }
    }
    return dp[m][C]; // 前m组、容量C的最大价值
}

// 测试：w={{2,3},{1,4}}, val={{3,4},{2,5}}, C=5 → 输出6（选第1组的2（价值3）+第2组的1（价值2）？不，最优是第2组的4（价值5）+第1组的2（价值3）？不对，容量5：4+2=6>5，正确最优是第1组的3（价值4）+第2组的1（价值2）=6，或第2组的4（价值5）+ 无第1组？5<6，所以结果6）
```

### 2. 第二步：二维→一维DP优化（实用版）
#### 优化思路（同01背包）
观察二维DP的状态转移：`dp[i][j]` 仅依赖于 `dp[i-1][...]`（上一行的状态，即前 `i-1` 组的结果），与当前 `i` 组的其他容量状态无关。因此可将二维数组压缩为一维数组 `dp[j]`，**覆盖存储上一行的状态**，节省空间。

#### 一维DP状态定义
`dp[j]`：背包容量为 `j` 时，能获得的最大价值（等价于二维的 `dp[i][j]`，通过遍历顺序保证正确性）。

#### 关键：遍历顺序的推导（为什么要「组→逆序容量→组内物品」？）
核心目标：**避免同一组内多个物品被同时选中**（组内互斥）。
- 若按「正序遍历容量」：遍历组内物品时，`j - w[i][k]` 已被本轮更新（包含当前组的物品），可能导致同一组选多个物品（违背规则）。
- 若按「逆序遍历容量」：遍历组内物品时，`j - w[i][k]` 未被本轮更新（仍为前 `i-1` 组的状态），确保每组最多选1个物品（和01背包逆序遍历的逻辑一致）。

#### 一维DP状态转移方程
```
// 遍历每组
for (int i = 0; i < m; i++) {
    // 逆序遍历容量（从C到0，避免组内多选）
    for (int j = C; j >= 0; j--) {
        // 遍历组内每个物品
        for (int k = 0; k < groupW.length; k++) {
            if (j >= groupW[k]) {
                dp[j] = max(dp[j], dp[j - groupW[k]] + groupV[k]);
            }
        }
    }
}
```
→ 先固定组，逆序容量保证「组内互斥」，再遍历组内物品尝试替换，取最大值。

#### 一维DP示例代码（最终模板）
```java
public static int groupPack1D(int[][] w, int[][] val, int C) {
    int m = w.length; // 组数
    int[] dp = new int[C+1]; // 初始化为0，dp[0]=0（容量0价值0）
    
    // 1. 遍历每一组（组间独立，顺序可换）
    for (int i = 0; i < m; i++) {
        int[] groupW = w[i]; // 第i组的物品重量
        int[] groupV = val[i]; // 第i组的物品价值
        
        // 2. 逆序遍历背包容量（关键！避免同一组选多个物品）
        // 注意：也可优化为j从C到groupW[k]的最大值，但直接从C到0更简洁
        for (int j = C; j >= 0; j--) {
            // 3. 遍历组内每个物品（尝试选该物品替换当前状态）
            for (int k = 0; k < groupW.length; k++) {
                if (j >= groupW[k]) { // 容量足够
                    dp[j] = Math.max(dp[j], dp[j - groupW[k]] + groupV[k]);
                }
            }
        }
    }
    return dp[C];
}

// 测试同上：w={{2,3},{1,4}}, val={{3,4},{2,5}}, C=5 → 输出6
```

### 3. 优化细节：容量遍历的边界压缩
上面的代码中，容量 `j` 从 `C` 逆序到 `0`，但实际上当 `j < groupW[k]` 时，无法选该物品，可优化为「`j` 从 `C` 逆序到当前组的最小重量」，减少无效循环：
```java
// 遍历组时，先计算该组的最小重量
int minW = Arrays.stream(groupW).min().getAsInt();
// 容量从C逆序到minW（小于minW的容量无需遍历）
for (int j = C; j >= minW; j--) {
    // 遍历组内物品
}
```


## 三、分组背包的三种常见目标（最值/存在/组合）
分组背包的目标不仅是「最大价值」，还可适配「能否装满」「组合数」，核心区别在「初始化」和「状态转移方程」，遍历顺序仍遵循「组→逆序容量→组内物品」。

### 1. 目标1：最值问题（最大/最小价值/数量）
#### 核心模板
- 初始化：`dp[0] = 0`（容量0时最值为0），其余 `dp[j] = 负无穷（求最大）/ 正无穷（求最小）`（表示不可达）。
- 状态转移：`dp[j] = max/min(dp[j], dp[j - w[i][k]] + val[i][k])`。

#### 示例：最低成本购买物品（分组背包+最小价值）
**问题**：有3组物品，每组代表一类工具（组1：锤子{重量2，成本3}、斧头{重量3，成本4}；组2：螺丝刀{重量1，成本2}、扳手{重量4，成本5}；组3：卷尺{重量2，成本1}），背包容量5，每组选1件，求最低总成本。
```java
public static int minCostGroupPack(int[][] w, int[][] cost, int C) {
    int m = w.length;
    int[] dp = new int[C+1];
    // 求最小成本→初始化正无穷，dp[0]=0
    Arrays.fill(dp, Integer.MAX_VALUE);
    dp[0] = 0;
    
    for (int i = 0; i < m; i++) {
        int[] groupW = w[i];
        int[] groupC = cost[i];
        // 逆序遍历容量
        for (int j = C; j >= 0; j--) {
            for (int k = 0; k < groupW.length; k++) {
                if (j >= groupW[k] && dp[j - groupW[k]] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - groupW[k]] + groupC[k]);
                }
            }
        }
    }
    return dp[C] == Integer.MAX_VALUE ? -1 : dp[C];
}

// 测试：w={{2,3},{1,4},{2}}, cost={{3,4},{2,5},{1}}, C=5 → 输出3（组1选锤子2（3）+组2选螺丝刀1（2）+组3选卷尺2（1）？总重量2+1+2=5，成本3+2+1=6？不对，最优是组1选锤子2（3）+组2选螺丝刀1（2）+组3不选？不，每组必须选1个！哦，题目若要求「每组必须选1个」，需调整初始化和容量计算，这里假设「每组可选或不选」，最优是组3选卷尺2（1）+组2选螺丝刀1（2）+组1不选，总重量3≤5，成本3）
```

### 2. 目标2：存在问题（能否装满背包）
#### 核心模板
- 初始化：`dp[0] = true`（容量0能装满），其余 `dp[j] = false`（初始不可达）。
- 状态转移：`dp[j] = dp[j] || dp[j - w[i][k]]`（只要有一条路径能装满j，就为true）。

#### 示例：能否用每组1个物品装满容量
**问题**：3组物品，组1：{2,3}，组2：{1,4}，组3：{2}，背包容量6，每组最多选1个，能否装满？
```java
public static boolean canFillGroupPack(int[][] w, int C) {
    boolean[] dp = new boolean[C+1];
    dp[0] = true; // 容量0能装满
    
    for (int i = 0; i < w.length; i++) {
        int[] groupW = w[i];
        // 逆序遍历容量（避免组内多选）
        for (int j = C; j >= 0; j--) {
            for (int k = 0; k < groupW.length; k++) {
                if (j >= groupW[k]) {
                    dp[j] = dp[j] || dp[j - groupW[k]];
                }
            }
        }
    }
    return dp[C];
}

// 测试：w={{2,3},{1,4},{2}}, C=6 → 能（组1选3+组2选1+组3选2 → 3+1+2=6）
```

### 3. 目标3：组合问题（求装满背包的组合数）
#### 核心模板
- 初始化：`dp[0] = 1`（容量0有1种组合：不选任何物品），其余 `dp[j] = 0`。
- 状态转移：`dp[j] += dp[j - w[i][k]]`（累加所有能凑成j的前态组合数）。
- 注意：组合数不考虑「组的顺序」（因为组是固定分类，顺序无意义），遍历顺序仍为「组→逆序容量→组内物品」。

#### 示例：装满容量的组合数
**问题**：2组物品，组1：{2,3}，组2：{1,4}，背包容量5，每组最多选1个，求组合数。
```java
public static int countGroupPack(int[][] w, int C) {
    int[] dp = new int[C+1];
    dp[0] = 1; // 容量0有1种组合
    
    for (int i = 0; i < w.length; i++) {
        int[] groupW = w[i];
        // 逆序遍历容量
        for (int j = C; j >= 0; j--) {
            for (int k = 0; k < groupW.length; k++) {
                if (j >= groupW[k]) {
                    dp[j] += dp[j - groupW[k]];
                }
            }
        }
    }
    return dp[C];
}

// 测试：w={{2,3},{1,4}}, C=5 → 组合数2：
// 1. 组1选2 + 组2选1 → 2+1=5
// 2. 组1选3 + 组2选1 → 3+1=5？不，3+1=4≠5，正确组合是：
// 组1选2 + 组2选3？不对，组2的物品是1和4：
// 正确组合：组1选2 + 组2选3（无）→ 实际是：
// 1. 组1选2 + 组2选3（不存在）→ 正确组合是：
// 组1选2 + 组2选3（错），重新算：
// 组1的物品：2、3；组2的物品：1、4。
// 容量5的组合：
// - 组1选2 + 组2选3（无）→ 组2选1：2+1=3≠5；组2选4：2+4=6>5 → 不行。
// - 组1选3 + 组2选1：3+1=4≠5；组2选4：3+4=7>5 → 不行。
// - 只选组2的4 + 组1不选：4≠5；只选组1的3：3≠5 → 哦，测试用例错了，换C=4：
// 组合数2：组1选2+组2选1（3≠4），组1选3+组2选1（4），组2选4（4）→ 组合数2，代码输出2，正确。
```

## 四、LeetCode实战真题（分组背包应用）
### 真题1：LeetCode 1155. 掷骰子的N种方法（分组背包+组合数）
**问题**：有 `d` 个骰子，每个骰子有 `f` 个面（点数1~f），求掷出点数和为 `target` 的方法数（每个骰子是一组，组内有f个物品，重量=点数，价值无意义，求组合数）。

**转化**：
- 每组：每个骰子是一组（组内有f个物品，点数1~f，最多选1个）。
- 容量：target（点数和）。
- 目标：组合数（初始化dp[0]=1，转移dp[j] += dp[j - k]）。

**代码**：
```java
class Solution {
    public int numRollsToTarget(int n, int k, int target) {
        int MOD = 1000000007;
        int[] values = new int[k];  // 每个组可选值

        int[] dp = new int[target + 1];
        dp[0] = 1;  // 初始状态：0个骰子和为0，1种方法
        for(int i = 1; i <= n; i++) {
            for(int j = target; j >= 0; j--) {
                // 这是分组背包「一维 DP 组合数统计」的通用技巧 —— 只要是「每组最多选 1 个物品」的组合数问题，一维 DP 中都需要先清零当前容量的旧状态，再进行转移。
                dp[j] = 0; // 重置当前组的状态（避免继承上一组的无效值）
                for(int m = 1; m <= k; m++) {
                    if(j >= m) {
                        dp[j] = (dp[j] + dp[j - m]) % MOD; 
                    }
                }
            }
        }

        return dp[target];

    }
}
```


## 五、关键总结
1. **核心逻辑**：分组背包的本质是「组间独立、组内互斥」，遍历顺序必须遵循「组→逆序容量→组内物品」，避免组内多选。
2. **优化核心**：二维→一维的关键是「逆序遍历容量」，复用01背包的空间优化逻辑。
3. **目标适配**：
   - 最值：`max/min` 转移，初始化分正负无穷；
   - 存在：`||` 转移，初始化 `dp[0]=true`；
   - 组合：`+=` 转移，初始化 `dp[0]=1`。

掌握以上内容后，所有分组背包相关问题都可通过「转化模型→适配模板→调整细节」解决，核心是理解「分组」带来的「组内互斥」约束，以及遍历顺序对约束的保证。
