https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-100-liked

# 最大子数组和（动态规划 + 前缀和解法，Java 实现）
## 一、问题描述
给定一个整数数组 `nums`，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

### 核心要求：
1. 子数组必须是**连续**的；
2. 子数组至少包含一个元素；
3. 目标是最大化子数组的元素和。

### 示例：
- 输入：`nums = [-2,1,-3,4,-1,2,1,-5,4]`
- 输出：`6`（解释：连续子数组 `[4,-1,2,1]` 的和为 6，是最大和）
- 输入：`nums = [1]`
- 输出：`1`
- 输入：`nums = [5,4,-1,7,8]`
- 输出：`23`（整个数组的和为 23，是最大和）
- 输入：`nums = [-1,-2,-3]`
- 输出：`-1`（最小的负数即为最大和）

## 二、动态规划解法（最优解）
### 1. 算法核心思想
动态规划（DP）的核心是**状态定义**和**状态转移方程**，通过“局部最优推导全局最优”：
- 状态定义：`dp[i]` 表示以 `nums[i]` 为结尾的连续子数组的最大和（必须包含 `nums[i]`）；
- 状态转移：对于每个元素 `nums[i]`，有两种选择——
  1. 将 `nums[i]` 加入前面的连续子数组（即 `dp[i-1] + nums[i]`）；
  2. 从 `nums[i]` 开始重新组建连续子数组（即 `nums[i]`）；
  因此，`dp[i] = Math.max(dp[i-1] + nums[i], nums[i])`；
- 全局最优：遍历所有 `dp[i]`，取最大值即为结果。

### 2. 优化空间复杂度
原始 DP 需额外维护一个长度为 `n` 的 `dp` 数组（空间复杂度 O(n)）。但观察状态转移方程可知，`dp[i]` 仅依赖 `dp[i-1]`，因此可**用单个变量替代数组**（空间复杂度优化至 O(1)）。

### 3. Java 代码实现
```java
public class MaximumSubarray {
    // 动态规划解法（空间优化版）
    public int maxSubArrayDP(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0; // 按题目要求，nums 至少含一个元素，此处仅处理边界
        }

        int currentMax = nums[0]; // 以当前元素为结尾的子数组最大和（替代 dp[i]）
        int globalMax = nums[0]; // 全局最大子数组和

        // 从第二个元素开始遍历
        for (int i = 1; i < nums.length; i++) {
            // 状态转移：选择加入前序子数组 或 重新开始
            currentMax = Math.max(currentMax + nums[i], nums[i]);
            // 更新全局最大值
            globalMax = Math.max(globalMax, currentMax);
        }

        return globalMax;
    }
}
```

### 复杂度分析：
- 时间复杂度：O(n)，仅遍历数组一次；
- 空间复杂度：O(1)，仅用两个变量维护状态，无额外空间开销。

## 三、前缀和解法
### 1. 算法核心思想
前缀和的核心是**将“子数组和”转化为“两个前缀和的差值”**：
- 定义前缀和数组 `prefixSum`，其中 `prefixSum[0] = 0`，`prefixSum[i] = nums[0] + nums[1] + ... + nums[i-1]`（即前 `i` 个元素的和）；
- 任意连续子数组 `nums[j..k]`（0 ≤ j ≤ k < n）的和为：`prefixSum[k+1] - prefixSum[j]`；
- 目标：找到 `k` 和 `j`（j < k+1），使得 `prefixSum[k+1] - prefixSum[j]` 最大；
- 关键优化：遍历前缀和时，**实时维护当前遇到的最小前缀和**（`minPrefix`），则当前最大子数组和为 `prefixSum[i] - minPrefix`（因为要最大化差值，需用当前前缀和减去最小的前缀和）。

### 2. 为什么不能直接找最大/最小前缀和？
若直接取 `max(prefixSum) - min(prefixSum)`，可能出现 `min(prefixSum)` 的索引 ≥ `max(prefixSum)` 的索引（子数组不连续），因此必须“遍历到当前前缀和时，仅考虑之前的最小前缀和”。

### 3. Java 代码实现
```java
public class MaximumSubarray {
    // 前缀和解法
    public int maxSubArrayPrefix(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int n = nums.length;
        int prefixSum = 0; // 前缀和（无需存储整个数组，实时计算）
        int minPrefix = 0; // 遍历过程中遇到的最小前缀和（初始为 prefixSum[0] = 0）
        int maxSum = nums[0]; // 全局最大和（初始为第一个元素，避免全负情况）

        for (int num : nums) {
            prefixSum += num; // 计算当前前缀和（即 prefixSum[i+1]）
            
            // 当前最大子数组和 = 当前前缀和 - 之前的最小前缀和
            maxSum = Math.max(maxSum, prefixSum - minPrefix);
            
            // 更新最小前缀和（若当前前缀和更小，则后续可用该值计算差值）
            minPrefix = Math.min(minPrefix, prefixSum);
        }

        return maxSum;
    }
}
```

### 复杂度分析：
- 时间复杂度：O(n)，仅遍历数组一次，前缀和、最小前缀和均实时计算；
- 空间复杂度：O(1)，无需存储完整前缀和数组，仅用三个变量维护状态。

## 四、两种解法对比与总结
| 解法         | 时间复杂度 | 空间复杂度 | 核心优势                     | 适用场景                     |
|--------------|------------|------------|------------------------------|------------------------------|
| 动态规划     | O(n)       | O(1)       | 逻辑直观，状态转移清晰       | 优先选择，代码简洁易维护     |
| 前缀和       | O(n)       | O(1)       | 从“差值”角度理解子数组和     | 辅助理解子数组和的数学本质   |

### 关键总结：
1. 动态规划是该问题的**最优实践**，空间和时间效率均拉满，且逻辑符合“局部最优推全局最优”的直觉；
2. 前缀和解法的核心是“转化子数组和为前缀和差值”，需注意“最小前缀和必须是当前前缀和之前的数值”，避免子数组不连续；
3. 两种解法均能处理全负数组（如 `[-1,-2,-3]`），因为初始值均考虑了数组首个元素，不会遗漏仅含单个元素的子数组。

### 扩展思考：
若题目要求返回“最大子数组的起始和结束索引”，两种解法均可扩展：
- 动态规划：记录 `currentMax` 对应的起始索引，当 `currentMax` 重新赋值为 `nums[i]` 时，更新起始索引为 `i`；
- 前缀和：记录最小前缀和对应的索引，当 `prefixSum - minPrefix` 达到最大值时，起始索引为 `minPrefixIndex + 1`，结束索引为当前遍历的索引。
