
https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked


# 和为 K 的子数组（Subarray Sum Equals K）- 详细解法（Java）
和为 K 的子数组是算法面试中的经典前缀和问题，核心考察「如何高效统计满足条件的连续子数组数量」。本文将从暴力解法到最优解法（前缀和+哈希表）逐步拆解，结合实例和代码逐行解释，小白也能轻松理解。


## 一、题目描述（明确边界）
给定一个整数数组 `nums` 和一个整数 `k`，请你统计并返回该数组中和为 `k` 的连续子数组的个数。

### 示例：
- 输入：`nums = [1,1,1]`, `k = 2` → 输出：`2`（子数组 `[1,1]`（索引0-1）和 `[1,1]`（索引1-2））
- 输入：`nums = [1,2,3]`, `k = 3` → 输出：`2`（子数组 `[3]`（索引2）和 `[1,2]`（索引0-1））
- 输入：`nums = [1,-1,0]`, `k = 0` → 输出：`3`（子数组 `[1,-1]`（0-1）、`[0]`（2）、`[1,-1,0]`（0-2））

### 关键约束：
- 子数组是「连续的」（必须是数组中一段连续的元素）；
- 数组中可以包含负数和 0（这是前缀和+哈希表解法的核心原因，负数会导致前缀和不单调，无法用双指针）；
- 子数组可以是单个元素（如 `[3]` 满足和为 3）。


## 二、核心思路分析
子数组的和本质是「区间和」，设子数组的左边界为 `i`、右边界为 `j`（`i ≤ j`），则区间和为：  
`sum(nums[i..j]) = nums[i] + nums[i+1] + ... + nums[j]`

### 关键公式：前缀和转化区间和
定义「前缀和」`preSum[j]` 表示从数组起始到索引 `j` 的元素和：  
`preSum[j] = nums[0] + nums[1] + ... + nums[j]`

则区间和 `sum(nums[i..j])` 可以转化为：  
`sum(nums[i..j]) = preSum[j] - preSum[i-1]`（当 `i > 0` 时）  
`sum(nums[0..j]) = preSum[j]`（当 `i = 0` 时）

我们的目标是找到所有 `i ≤ j`，使得 `preSum[j] - preSum[i-1] = k`（`i=0` 时 `preSum[-1] = 0`）。  
变形可得：`preSum[i-1] = preSum[j] - k`

因此，问题转化为：**对于每个 `j`，统计前缀和 `preSum[j] - k` 出现的次数，所有次数之和即为答案**。


## 三、解法一：暴力解法（思路铺垫）
### 思路：
枚举所有可能的子数组（遍历所有左边界 `i` 和右边界 `j`），计算子数组和，判断是否等于 `k`，统计次数。

### Java 代码实现：
```java
public int subarraySum(int[] nums, int k) {
    int count = 0;
    int n = nums.length;
    // 枚举左边界 i
    for (int i = 0; i < n; i++) {
        int sum = 0;
        // 枚举右边界 j（从 i 到 n-1，子数组 [i..j]）
        for (int j = i; j < n; j++) {
            sum += nums[j]; // 累加子数组和
            if (sum == k) {
                count++;
            }
        }
    }
    return count;
}
```

### 复杂度分析：
- 时间复杂度：O(n²)，`n` 是数组长度，嵌套循环枚举所有子数组。
- 空间复杂度：O(1)，仅用常数变量存储和与计数。

### 缺点：
效率过低，无法通过大数据测试（如 `n=10^5` 时，O(n²) 会超时），仅作为思路铺垫。


## 四、解法二：前缀和 + 哈希表（最优解，O(n) 时间）
### 核心思路：
利用「前缀和公式」和「哈希表存储前缀和出现次数」，将统计过程优化为 O(n) 时间：
1. 维护一个变量 `currentPreSum`，记录当前遍历到索引 `j` 时的前缀和（`preSum[j]`）。
2. 维护一个哈希表 `preSumCount`，key 是「前缀和的值」，value 是「该前缀和出现的次数」（初始时存入 `preSum[-1] = 0`，次数为 1，对应 `i=0` 的情况）。
3. 遍历数组时，对每个 `j`：
   a. 计算 `currentPreSum += nums[j]`（更新当前前缀和）。
   b. 计算目标前缀和 `target = currentPreSum - k`（即 `preSum[i-1]`）。
   c. 若哈希表中存在 `target`，则将其对应的次数累加到答案 `count`（这些次数对应所有满足条件的 `i`）。
   d. 将当前前缀和 `currentPreSum` 存入哈希表（若已存在则次数+1，否则初始化为 1）。

### 哈希表的「神奇之处」：
- 哈希表记录了「之前所有前缀和的出现次数」，对于当前前缀和 `currentPreSum`，只需 O(1) 时间即可查询 `target` 出现的次数，避免了枚举 `i` 的过程。
- 每个元素仅遍历一次，整体时间复杂度 O(n)。

### 形象比喻：
把前缀和想象成「路程表」，`currentPreSum` 是走到 `j` 点的总路程，`k` 是目标区间的路程。我们要找的是「之前走到 `currentPreSum - k` 点的次数」，因为从该点到 `j` 点的路程就是 `k`（对应子数组和为 `k`）。

### Java 代码实现：
```java
import java.util.HashMap;
import java.util.Map;

public int subarraySum(int[] nums, int k) {
    int count = 0;
    int currentPreSum = 0; // 当前前缀和（preSum[j]）
    // 哈希表：key=前缀和，value=该前缀和出现的次数
    Map<Integer, Integer> preSumCount = new HashMap<>();
    // 初始化：preSum[-1] = 0，出现次数 1（对应 i=0 时的子数组 [0..j]）
    preSumCount.put(0, 1);

    for (int num : nums) {
        // 1. 更新当前前缀和（累加当前元素）
        currentPreSum += num;

        // 2. 若目标前缀和存在，累加其出现次数（这些都是满足条件的子数组）
        if (preSumCount.containsKey(currentPreSum - k)) {
            count += preSumCount.get(currentPreSum - k);
        }

        // 3. 将当前前缀和存入哈希表（次数+1 或初始化为 1）
        preSumCount.put(currentPreSum, preSumCount.getOrDefault(currentPreSum, 0) + 1);
    }

    return count;
}
```

### 逐行代码解析：
1. **初始化**：
   - `count`：记录满足条件的子数组个数。
   - `currentPreSum`：记录当前遍历到的前缀和（从数组起始到当前元素的和）。
   - `preSumCount`：哈希表，存储前缀和及其出现次数。初始存入 `(0, 1)`，因为当 `i=0` 时，子数组 `[0..j]` 的和为 `preSum[j] - preSum[-1] = preSum[j] - 0 = preSum[j]`，若等于 `k` 则需统计。

2. **遍历数组**：
   - **步骤1：更新当前前缀和**：`currentPreSum += num`，即 `preSum[j] = preSum[j-1] + nums[j]`。
   - **步骤2：计算目标前缀和**：`target = currentPreSum - k`，对应公式 `preSum[i-1] = preSum[j] - k`。
   - **步骤3：统计满足条件的子数组**：若哈希表中存在 `target`，说明之前有 `preSumCount.get(target)` 个 `i` 满足 `preSum[i-1] = target`，即有这么多个子数组 `[i..j]` 的和为 `k`，累加到 `count`。
   - **步骤4：更新哈希表**：将当前前缀和 `currentPreSum` 存入哈希表，若已存在则次数+1（`getOrDefault` 方法：若 key 存在则返回 value，否则返回默认值 0），否则初始化为 1。

### 执行流程模拟（以 `nums = [1,1,1]`, `k=2` 为例）：
| 遍历元素 | currentPreSum（preSum[j]） | target = currentPreSum - k | 哈希表 preSumCount（初始：{0:1}） | count 变化 |
|----------|-----------------------------|-----------------------------|----------------------------------|------------|
| 第一个 1 | 0 + 1 = 1                   | 1 - 2 = -1                  | 无 -1 → 存入 1:1 → {0:1, 1:1}    | 0（无变化）|
| 第二个 1 | 1 + 1 = 2                   | 2 - 2 = 0                   | 0 存在（次数 1）→ count +=1 → 1  | 存入 2:1 → {0:1,1:1,2:1} |
| 第三个 1 | 2 + 1 = 3                   | 3 - 2 = 1                   | 1 存在（次数 1）→ count +=1 → 2  | 存入 3:1 → {0:1,1:1,2:1,3:1} |

最终 `count=2`，与示例一致！

再模拟 `nums = [1,-1,0]`, `k=0`：
| 遍历元素 | currentPreSum | target = currentPreSum - 0 | 哈希表（初始：{0:1}） | count 变化 |
|----------|---------------|-----------------------------|------------------------|------------|
| 1        | 1             | 1                           | 无 1 → 存入 1:1 → {0:1,1:1} | 0 |
| -1       | 1 + (-1) = 0  | 0                           | 0 存在（次数1）→ count=1 | 存入 0:2 → {0:2,1:1} |
| 0        | 0 + 0 = 0     | 0                           | 0 存在（次数2）→ count=1+2=3 | 存入 0:3 → {0:3,1:1} |

最终 `count=3`，与示例一致！


## 五、复杂度分析（面试必问）
- **时间复杂度**：O(n)，`n` 是数组长度，仅遍历数组一次，哈希表的插入和查询操作均为 O(1)。
- **空间复杂度**：O(n)，最坏情况（数组中所有元素为 0，`k=0`），哈希表需存储 `n+1` 个前缀和（0,0,0,...），空间与数组长度线性相关。


## 六、常见面试扩展题
### 扩展题 1：和为 K 的子数组（数组元素非负，双指针优化）
- 题目：给定非负整数数组和 `k`，统计和为 `k` 的连续子数组个数（元素非负）。
- 思路：利用双指针（滑动窗口），因为元素非负，前缀和单调递增。
  - 左指针 `left`、右指针 `right` 初始为 0，维护窗口和 `windowSum`。
  - 右指针右移，`windowSum += nums[right]`。
  - 当 `windowSum > k` 时，左指针右移，`windowSum -= nums[left]`。
  - 当 `windowSum == k` 时，`count++`，并继续移动左指针（可能存在多个子数组，如 `[1,2,3]`，`k=3` 时，`[3]` 和 `[1,2]`）。
- 复杂度：时间 O(n)，空间 O(1)（比哈希表更优，但仅适用于元素非负）。

### 扩展题 2：和为 K 的最长子数组长度
- 题目：给定整数数组和 `k`，找出和为 `k` 的最长连续子数组长度（若不存在返回 0）。
- 思路：哈希表存储「前缀和第一次出现的索引」，而非次数。
  - 对于每个 `j`，计算 `target = currentPreSum - k`。
  - 若 `target` 存在于哈希表中，长度为 `j - 第一次出现的索引`，更新最大长度。
  - 若 `currentPreSum` 已存在，不更新哈希表（保留第一次出现的索引，保证长度最长）。

### 扩展题 3：和为 K 的子矩阵个数（LeetCode 363）
- 题目：给定二维矩阵和 `k`，统计和为 `k` 的非空连续子矩阵个数。
- 思路：将二维转化为一维（固定上下边界，计算列的前缀和，转化为「和为 K 的子数组」问题）。
  - 枚举上边界 `top` 和下边界 `bottom`。
  - 计算每列从 `top` 到 `bottom` 的和，得到一维数组 `colSum`。
  - 对 `colSum` 调用「和为 K 的子数组」的哈希表解法，累加次数。


## 七、小白常见问题（避坑指南）
1. 为什么要初始化哈希表为 `{0:1}`？
sum(0..j) = preSum[j] - preSum[-1] = preSum[j] - 0 = preSum[j]
当 preSum[j] = k 时，需要统计 preSum[-1] = 0 的出现次数，而 preSum[-1] = 0 是我们定义的 “虚拟前缀和”，它的出现次数为 1（仅存在一次）。
如果不初始化 {0:1}，当 preSum[j] = k 时，哈希表中没有 0 这个 key，就会漏掉「子数组从索引 0 开始」的情况，导致统计结果错误。

2. 数组包含负数时，为什么不能用双指针？
   - 双指针的前提是「前缀和单调递增」，负数会导致前缀和波动（如 `[1,-2,3]`，前缀和为 1,-1,2），无法通过移动左指针保证窗口和的单调性，因此必须用哈希表。

3. 哈希表中为什么要存储「前缀和出现的次数」，而不是「索引」？
   - 因为可能存在多个 `i` 对应同一个 `preSum[i-1]`，例如 `nums = [0,0,0]`, `k=0`，每个 `j` 对应的 `target=currentPreSum`，哈希表中 `0` 的次数会不断增加，从而统计所有满足条件的子数组（共 6 个）。

4. 前缀和可能溢出吗？
   - 可能！若数组元素较大或长度较长，`currentPreSum` 可能超出 `int` 范围，此时需用 `long` 类型存储（Java 中）。


## 八、总结（小白必记）
1. 和为 K 的子数组的核心是「前缀和公式」：`sum(i..j) = preSum[j] - preSum[i-1]`。
2. 最优解法是「前缀和 + 哈希表」，将统计过程优化为 O(n) 时间，核心是用哈希表记录前缀和的出现次数。
3. 初始化哈希表为 `{0:1}` 是关键，对应 `i=0` 时的子数组情况。
4. 扩展题的核心是「将复杂问题转化为一维的子数组和问题」，或「调整哈希表存储的 value（次数→索引）」。

建议多模拟不同示例的执行流程（尤其是包含负数和 0 的情况），理解哈希表如何统计满足条件的子数组，就能熟练掌握这类问题～
