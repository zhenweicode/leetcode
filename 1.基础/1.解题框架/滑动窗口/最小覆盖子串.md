https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-100-liked



# 最小覆盖子串问题（Java 实现 + 滑动窗口详解）
## 一、问题描述
给定两个字符串 `s`（目标字符串）和 `t`（模式字符串），找出 `s` 中**包含 `t` 所有字符的最小长度子串**，如果不存在则返回空字符串 `""`。

### 核心要求：
1. 子串必须包含 `t` 中所有字符（包括重复字符，如 `t="AAB"` 则子串需包含至少两个 `A` 和一个 `B`）；
2. 子串是 `s` 的连续片段；
3. 优先选择长度最小的子串，若有多个则返回最左侧的。

### 示例：
- 输入：`s = "ADOBECODEBANC", t = "ABC"`
- 输出：`"BANC"`（长度 4，是包含 A、B、C 的最小子串）
- 输入：`s = "a", t = "a"`
- 输出：`"a"`
- 输入：`s = "a", t = "aa"`
- 输出：`""`（s 中只有 1 个 a，无法满足 t 的需求）

## 二、解题思路：滑动窗口（Sliding Window）
### 1. 算法核心思想
滑动窗口是处理**子串/子数组问题**的高效算法，核心是通过两个指针（`left` 左边界、`right` 右边界）维护一个动态窗口，遍历一次字符串即可完成求解，时间复杂度优化至 O(n)（n 为 `s` 的长度）。

### 2. 具体步骤
#### （1）预处理：统计 t 中字符频率
用哈希表（或数组）记录 `t` 中每个字符的出现次数，明确窗口需要满足的“字符需求”。
- 例如 `t="ABC"`，需求为：`A:1, B:1, C:1`。

#### （2）滑动窗口扩张（right 右移）
- 用另一个哈希表记录当前窗口中字符的出现次数；
- 右移 `right` 指针，将当前字符加入窗口，更新窗口字符频率；
- 当窗口中**满足所有 t 的字符需求**（即窗口中每个字符的出现次数 ≥ t 中对应字符的次数）时，进入下一步。

#### （3）滑动窗口收缩（left 右移）
- 此时窗口是一个“有效窗口”，尝试左移 `left` 指针缩小窗口范围，寻找更小的有效窗口；
- 左移前记录当前窗口的起始位置和长度（更新最小子串信息）；
- 左移时，移除窗口左侧字符，更新窗口字符频率；若移除后某字符的频率不满足需求，则退出收缩，回到步骤（2）继续扩张。

#### （4）结果处理
遍历结束后，若找到有效窗口则返回最小子串，否则返回空字符串。

### 3. 关键优化点
- 用数组代替哈希表：由于字符是 ASCII 编码（共 128 个），可用大小为 128 的数组存储频率，效率高于哈希表；
- 维护“匹配计数”：用一个变量 `matchCount` 记录窗口中已满足需求的字符种类数（如 t 有 3 种字符，当 `matchCount=3` 时表示窗口有效），避免每次判断窗口是否有效时遍历整个频率数组。

## 三、Java 代码实现
```java
import java.util.Arrays;

public class MinimumWindowSubstring {
    public String minWindow(String s, String t) {
        // 边界条件：t 为空或 s 长度小于 t，直接返回空串
        if (t.isEmpty() || s.length() < t.length()) {
            return "";
        }

        // 1. 初始化 t 的字符频率需求数组（ASCII 128 个字符）
        int[] tFreq = new int[128];
        for (char c : t.toCharArray()) {
            tFreq[c]++;
        }

        // 2. 初始化窗口相关变量
        int[] windowFreq = new int[128]; // 窗口中字符频率
        int left = 0; // 窗口左边界
        int minLen = Integer.MAX_VALUE; // 最小子串长度
        int start = 0; // 最小子串起始索引
        int matchCount = 0; // 已满足需求的字符种类数
        int validCharCount = getValidCharCount(tFreq);

        // 3. 扩张窗口（right 右移）
        for (int right = 0; right < s.length(); right++) {
            char currChar = s.charAt(right);
            windowFreq[currChar]++;

            // 若当前字符的窗口频率刚满足 t 的需求，匹配计数+1
            if (windowFreq[currChar] == tFreq[currChar]) {
                matchCount++;
            }

            // 4. 收缩窗口（当窗口有效时，left 右移）
            while (matchCount == validCharCount) {
                // 更新最小子串信息
                int currWindowLen = right - left + 1;
                if (currWindowLen < minLen) {
                    minLen = currWindowLen;
                    start = left;
                }

                // 移除窗口左边界字符
                char leftChar = s.charAt(left);
                windowFreq[leftChar]--;

                // 若移除后该字符的频率不满足需求，匹配计数-1（退出收缩）
                if (windowFreq[leftChar] < tFreq[leftChar]) {
                    matchCount--;
                }

                left++; // 左边界右移
            }
        }

        // 5. 返回结果（若未找到有效窗口，返回空串）
        return minLen == Integer.MAX_VALUE ? "" : s.substring(start, start + minLen);
    }

    // 辅助函数：计算 t 中有效字符的种类数（排除频率为 0 的字符）
    private int getValidCharCount(int[] freq) {
        int count = 0;
        for (int f : freq) {
            if (f > 0) {
                count++;
            }
        }
        return count;
    }

    // 测试用例
    public static void main(String[] args) {
        MinimumWindowSubstring solution = new MinimumWindowSubstring();
        System.out.println(solution.minWindow("ADOBECODEBANC", "ABC")); // 输出 "BANC"
        System.out.println(solution.minWindow("a", "a")); // 输出 "a"
        System.out.println(solution.minWindow("a", "aa")); // 输出 ""
        System.out.println(solution.minWindow("ab", "a")); // 输出 "a"
        System.out.println(solution.minWindow("ab", "b")); // 输出 "b"
    }
}
```

### 代码说明：
- 时间复杂度：O(n + m)，n 为 `s` 长度，m 为 `t` 长度（仅遍历 `s` 和 `t` 各一次）；
- 空间复杂度：O(1)，两个频率数组大小固定为 128（与输入规模无关）。

## 四、常见滑动窗口问题归类
滑动窗口算法适用于**连续子串/子数组的极值问题**（最小长度、最大长度、满足条件的个数等），以下是经典题型：

### 1. 固定窗口大小
#### 问题特征：
窗口长度固定，需计算窗口内的某个指标（如和、最大值、平均值等）。
#### 经典例题：
- [leetcode 643. 子数组最大平均数 I](https://leetcode.cn/problems/maximum-average-subarray-i/)：给定数组和窗口大小 k，求所有长度为 k 的子数组的最大平均数；
- [leetcode 1052. 爱生气的书店老板](https://leetcode.cn/problems/grumpy-bookstore-owner/)：固定窗口大小 X，求窗口内“不生气时的顾客数”最大值。

### 2. 可变窗口（求最小长度）
#### 问题特征：
窗口长度可变，需找到**满足条件的最小长度子串/子数组**（如包含目标字符、和 ≥ 目标值等）。
#### 经典例题：
- [leetcode 209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)：给定数组和目标值 s，找到和 ≥ s 的最小长度子数组；
- 本文的最小覆盖子串（leetcode 76. 最小覆盖子串）。

### 3. 可变窗口（求最大长度）
#### 问题特征：
窗口长度可变，需找到**满足条件的最大长度子串/子数组**（如无重复字符、最多包含 k 个不同字符等）。
#### 经典例题：
- [leetcode 3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)：找到不含重复字符的最长子串；
- [leetcode 159. 至多包含两个不同字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters/)：最多包含 2 个不同字符的最长子串；
- [leetcode 424. 替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/)：替换 k 个字符后，最长的重复字符子串。

### 4. 窗口内计数问题
#### 问题特征：
统计满足条件的子串/子数组个数（条件通常与窗口内字符/元素的属性相关）。
#### 经典例题：
- [leetcode 763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)：将字符串划分为尽可能多的片段，每个片段中所有字符仅出现在该片段；
- [leetcode 340. 至多包含 K 个不同字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-most-k-distinct-characters/)：衍生问题——统计至多包含 k 个不同字符的子串个数。

### 滑动窗口通用模板（Java）
```java
// 通用变量（根据问题调整）
int left = 0;
int result = 0; // 存储结果（长度/个数等）
// 辅助结构（哈希表/数组，用于记录窗口状态）
Map<Character, Integer> window = new HashMap<>();

for (int right = 0; right < s.length(); right++) {
    // 1. 扩张窗口：将当前元素加入窗口，更新状态
    char curr = s.charAt(right);
    window.put(curr, window.getOrDefault(curr, 0) + 1);

    // 2. 收缩窗口：根据问题条件判断是否需要左移 left
    while (/* 窗口不满足条件（如超出限制、已找到有效窗口）*/) {
        char leftChar = s.charAt(left);
        // 更新窗口状态
        window.put(leftChar, window.get(leftChar) - 1);
        if (window.get(leftChar) == 0) {
            window.remove(leftChar);
        }
        left++; // 左移
    }

    // 3. 更新结果（根据问题类型计算，如窗口长度、个数等）
    result = Math.max(result, right - left + 1); // 求最大长度示例
}

return result;
```

## 五、总结
- 最小覆盖子串的核心是**滑动窗口 + 字符频率统计**，通过扩张窗口找到有效解，收缩窗口优化解，时间复杂度 O(n)；
- 滑动窗口的关键是：明确“窗口扩张条件”和“窗口收缩条件”，用辅助结构（数组/哈希表）记录窗口状态，避免重复计算；
- 遇到“连续子串/子数组的极值/计数”问题时，优先考虑滑动窗口算法，可大幅提升效率（从暴力的 O(n²) 优化至 O(n)）。
