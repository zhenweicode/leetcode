

https://leetcode.cn/problems/rotate-image/description/?envType=study-plan-v2&envId=top-100-liked

# 旋转图像（Java 详细解法）
## 一、问题描述
给定一个 `n x n` 的二维矩阵 `matrix`，请将其**顺时针旋转 90 度**。要求**原地**旋转（空间复杂度尽可能优化，不允许使用额外的二维矩阵存储结果）。

### 核心要求：
1. 旋转方向：顺时针 90 度；
2. 原地修改：空间复杂度最优为 O(1)（仅使用常数级临时变量）；
3. 适配任意 n×n 矩阵（n≥1），包括 1×1、2×2、3×3 等。

### 示例：
#### 示例 1（3×3 矩阵）
- 输入：
  ```
  [
    [1,2,3],
    [4,5,6],
    [7,8,9]
  ]
  ```
- 旋转后输出：
  ```
  [
    [7,4,1],
    [8,5,2],
    [9,6,3]
  ]
  ```

#### 示例 2（4×4 矩阵）
- 输入：
  ```
  [
    [ 1, 2, 3, 4],
    [ 5, 6, 7, 8],
    [ 9,10,11,12],
    [13,14,15,16]
  ]
  ```
- 旋转后输出：
  ```
  [
    [13, 9, 5, 1],
    [14,10, 6, 2],
    [15,11, 7, 3],
    [16,12, 8, 4]
  ]
  ```

## 二、问题分析
### 核心难点：
- 找到矩阵元素旋转后的位置映射规律（即原位置 `(i,j)` 旋转后对应哪个新位置）；
- 原地旋转时避免元素被覆盖（需合理安排交换顺序或使用临时变量）。

### 关键观察（元素位置映射）：
顺时针旋转 90 度后，原矩阵中位置 `(i,j)` 的元素会移动到新位置 `(j, n-1-i)`，具体验证：
- 以 3×3 矩阵为例（n=3）：
  - 原 (0,0)=1 → 新位置 (0, 3-1-0)=(0,2)？不对！示例中 1 最终在 (0,0)？哦，需重新推导：
  正确推导（顺时针旋转 90 度等价于“转置矩阵 + 水平翻转”，或直接找坐标映射）：
  重新观察 3×3 矩阵的元素移动：
  - 1（0,0）→ 7 原来的位置（2,0）？不，旋转后 1 在 (0,0) 变为 (0,2)？示例中旋转后 1 在第一列第一行（0,0）是 7，1 在 (0,2) 位置？哦示例输入的第一行 [1,2,3] 旋转后变为第三列 [1,2,3]，即：
  原矩阵的第 i 行第 j 列 → 旋转后第 j 行第 (n-1-i) 列（以 3×3 验证）：
  - 原 (0,0)=1 → 旋转后 (0, 2) → 示例中旋转后 (0,2) 是 1，正确；
  - 原 (0,1)=2 → 旋转后 (1,2) → 示例中旋转后 (1,2) 是 2，正确；
  - 原 (0,2)=3 → 旋转后 (2,2) → 示例中旋转后 (2,2) 是 3，正确；
  - 原 (1,0)=4 → 旋转后 (0,1) → 示例中旋转后 (0,1) 是 4，正确；
  - 原 (2,0)=7 → 旋转后 (0,0) → 示例中旋转后 (0,0) 是 7，正确。
  结论：**顺时针旋转 90 度的坐标映射为：原 (i,j) → 新 (j, n-1-i)**。

### 核心思路：
旋转图像的最优原地解法是 **“先转置矩阵，再水平翻转每一行”**（或“先垂直翻转，再转置”），该方法逻辑清晰、操作简单，且空间复杂度 O(1)：
1. 转置矩阵：将矩阵的行和列互换（原 (i,j) → 转置后 (j,i)）；
2. 水平翻转：将每一行的元素左右翻转（原行 [a,b,c] → 翻转后 [c,b,a]）。

验证（3×3 矩阵）：
- 原矩阵转置后：
  ```
  [
    [1,4,7],
    [2,5,8],
    [3,6,9]
  ]
  ```
- 水平翻转每一行后：
  ```
  [
    [7,4,1],
    [8,5,2],
    [9,6,3]
  ]
  ```
  与示例输出一致！

## 三、详细解法（转置 + 水平翻转）
### 1. 算法步骤
#### 步骤 1：转置矩阵
转置矩阵的核心是“遍历上三角矩阵，交换 (i,j) 和 (j,i) 位置的元素”（避免重复交换）：
- 遍历范围：行 `i` 从 0 到 n-1；列 `j` 从 `i+1` 到 n-1（因为 `j=i` 时是对角线元素，无需交换；`j<i` 时已交换过）；
- 交换 `matrix[i][j]` 和 `matrix[j][i]`。

#### 步骤 2：水平翻转每一行
水平翻转的核心是“遍历每一行的前半部分，交换 (i,j) 和 (i, n-1-j) 位置的元素”：
- 遍历每一行 `i`（0 到 n-1）；
- 遍历每一行的前半列 `j`（0 到 (n-1)/2）；
- 交换 `matrix[i][j]` 和 `matrix[i][n-1-j]`。

### 2. 示例演示（4×4 矩阵）
输入矩阵：
```
[
  [ 1, 2, 3, 4],
  [ 5, 6, 7, 8],
  [ 9,10,11,12],
  [13,14,15,16]
]
```
#### 步骤 1：转置矩阵
交换 (i,j) 和 (j,i)（i<j）：
```
[
  [ 1, 5, 9,13],
  [ 2, 6,10,14],
  [ 3, 7,11,15],
  [ 4, 8,12,16]
]
```
#### 步骤 2：水平翻转每一行
交换 (i,j) 和 (i, 3-j)（j=0 和 3，j=1 和 2）：
- 第一行 [1,5,9,13] → [13,9,5,1]；
- 第二行 [2,6,10,14] → [14,10,6,2]；
- 第三行 [3,7,11,15] → [15,11,7,3]；
- 第四行 [4,8,12,16] → [16,12,8,4]；
最终结果与示例一致！

### 3. Java 代码实现
```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        if (n <= 1) {
            return; // 1×1 矩阵无需旋转
        }

        // 步骤 1：转置矩阵（遍历上三角，交换 (i,j) 和 (j,i)）
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                // 交换两个元素
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }

        // 步骤 2：水平翻转每一行（交换 (i,j) 和 (i, n-1-j)）
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n / 2; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[i][n - 1 - j];
                matrix[i][n - 1 - j] = temp;
            }
        }
    }
}
```

### 4. 关键细节解释
- **转置时遍历上三角矩阵**：`j` 从 `i+1` 开始，避免 `i=j` 时的对角线元素交换（无意义），同时避免 `j<i` 时重复交换（如先交换 (0,1) 和 (1,0)，再交换 (1,0) 和 (0,1) 会还原）；
- **水平翻转时遍历前半列**：`j` 到 `n/2` 即可，因为交换 (i,j) 和 (i,n-1-j) 时，后半列的元素会被前半列的元素覆盖，无需重复遍历；
- **边界处理**：`n≤1` 时直接返回，避免无效操作。
