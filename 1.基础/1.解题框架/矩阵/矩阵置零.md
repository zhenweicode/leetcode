https://leetcode.cn/problems/set-matrix-zeroes/?envType=study-plan-v2&envId=top-100-liked



# 矩阵置零（Java 详细解法）
## 一、问题描述
给定一个 `m x n` 的矩阵 `matrix`，如果矩阵中某个元素为 `0`，则将其所在的**行**和**列**的所有元素都设为 `0`。要求**原地**修改矩阵（空间复杂度尽可能优化）。

### 核心要求：
1. 原地修改：不允许创建与原矩阵等大的辅助矩阵（否则空间复杂度 O(mn)，效率过低）；
2. 时间复杂度：O(mn)（需遍历矩阵至少一次）；
3. 处理边界情况：矩阵为空、单行/单列矩阵、全零矩阵等。

### 示例：
- 输入：
  ```
  [
    [1,1,1],
    [1,0,1],
    [1,1,1]
  ]
  ```
- 输出：
  ```
  [
    [1,0,1],
    [0,0,0],
    [1,0,1]
  ]
  ```

- 输入：
  ```
  [
    [0,1,2,0],
    [3,4,5,2],
    [1,3,1,5]
  ]
  ```
- 输出：
  ```
  [
    [0,0,0,0],
    [0,4,5,0],
    [0,3,1,0]
  ]
  ```

## 二、问题分析
### 关键痛点：
直接遍历矩阵并遇到 `0` 就置零会导致“后续无法区分原始零和被置零的零”——比如某行因原始零被置零后，后续遍历到该行的其他元素时，会误将其当作原始零，进而错误置零对应列。

### 核心思路：
利用**矩阵的第一行和第一列作为“标记位”**，提前记录哪些行和列需要置零，最后再根据标记位统一处理。这样无需额外辅助矩阵，仅需常数级或 O(m+n) 空间（根据优化程度）。

## 三、三种解法（从易到优）
### 解法一：使用额外数组标记（空间 O(m+n)）
#### 1. 思路
用两个一维数组分别记录“需要置零的行”和“需要置零的列”：
1. 第一次遍历矩阵：若 `matrix[i][j] == 0`，则标记 `row[i] = true`（第 i 行需置零）、`col[j] = true`（第 j 列需置零）；
2. 第二次遍历矩阵：若 `row[i]` 或 `col[j]` 为 `true`，则将 `matrix[i][j]` 置为 `0`。

#### 2. Java 代码实现
```java
class Solution {
    public void setZeroes(int[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return;
        }
        int m = matrix.length;    // 行数
        int n = matrix[0].length; // 列数
        
        // 标记需要置零的行和列
        boolean[] row = new boolean[m];
        boolean[] col = new boolean[n];
        
        // 第一次遍历：记录标记
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == 0) {
                    row[i] = true;
                    col[j] = true;
                }
            }
        }
        
        // 第二次遍历：根据标记置零
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (row[i] || col[j]) {
                    matrix[i][j] = 0;
                }
            }
        }
    }
}
```

#### 3. 复杂度分析
- 时间复杂度：O(mn)，两次遍历矩阵，每次遍历均为 O(mn)；
- 空间复杂度：O(m+n)，额外使用两个长度为 m 和 n 的布尔数组。

#### 4. 优点与缺点
- 优点：逻辑简单，无边界处理风险，易于理解和实现；
- 缺点：空间开销较大，未满足“原地修改”的最优空间要求。

---

### 解法二：利用矩阵第一行和第一列标记（空间 O(1)）
#### 1. 核心思路
优化解法一的空间开销：用矩阵自身的第一行和第一列作为标记位，同时用两个额外变量记录第一行和第一列是否需要置零（避免标记位被覆盖）。

#### 2. 具体步骤
##### 步骤 1：标记第一行和第一列是否需要置零
- 遍历第一行：若存在 `0`，则标记 `firstRowZero = true`（第一行最终需置零）；
- 遍历第一列：若存在 `0`，则标记 `firstColZero = true`（第一列最终需置零）。

##### 步骤 2：用第一行和第一列标记其他行和列
遍历矩阵的非第一行、非第一列元素（`i ≥ 1，j ≥ 1`）：
- 若 `matrix[i][j] == 0`，则将 `matrix[i][0] = 0`（标记第 i 行需置零）、`matrix[0][j] = 0`（标记第 j 列需置零）。

##### 步骤 3：根据标记位置零非第一行和第一列
- 遍历非第一行（`i ≥ 1`）：若 `matrix[i][0] == 0`，则将第 i 行所有元素置零；
- 遍历非第一列（`j ≥ 1`）：若 `matrix[0][j] == 0`，则将第 j 列所有元素置零。

##### 步骤 4：处理第一行和第一列
- 若 `firstRowZero == true`，将第一行所有元素置零；
- 若 `firstColZero == true`，将第一列所有元素置零。

#### 3. 示例演示（以输入矩阵为例）
输入矩阵：
```
[
  [0,1,2,0],  // 第一行存在 0 → firstRowZero = true
  [3,4,5,2],
  [1,3,1,5]
]
```
步骤 1：标记第一行和第一列：
- firstRowZero = true（第一行有 0）；
- 第一列元素为 [0,3,1] → 存在 0 → firstColZero = true。

步骤 2：用第一行和第一列标记其他行/列：
- 遍历 (0,0)：跳过（i=0 是第一行）；
- 遍历 (0,3)：跳过（i=0 是第一行）；
- 其他元素无 0，标记后第一行仍为 [0,1,2,0]，第一列仍为 [0,3,1]。

步骤 3：置零非第一行和第一列：
- 非第一行（i=1,2）：matrix[1][0] = 3（不置零），matrix[2][0] = 1（不置零）；
- 非第一列（j=1,2）：matrix[0][1] = 1（不置零），matrix[0][2] = 2（不置零）；
- j=3：matrix[0][3] = 0 → 第 3 列置零（元素 [0,2,5] → [0,0,0]）。

步骤 4：处理第一行和第一列：
- firstRowZero = true → 第一行置零 → [0,0,0,0]；
- firstColZero = true → 第一列置零 → [0,0,0]（列）。

最终结果：
```
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
```

#### 4. Java 代码实现
```java
class Solution {
    public void setZeroes(int[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return;
        }
        int m = matrix.length;    // 行数
        int n = matrix[0].length; // 列数
        
        boolean firstRowZero = false; // 标记第一行是否需要置零
        boolean firstColZero = false; // 标记第一列是否需要置零
        
        // 步骤 1：标记第一行和第一列是否需要置零
        // 检查第一行
        for (int j = 0; j < n; j++) {
            if (matrix[0][j] == 0) {
                firstRowZero = true;
                break; // 只要有一个 0，第一行就需置零
            }
        }
        // 检查第一列
        for (int i = 0; i < m; i++) {
            if (matrix[i][0] == 0) {
                firstColZero = true;
                break; // 只要有一个 0，第一列就需置零
            }
        }
        
        // 步骤 2：用第一行和第一列标记其他行和列
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = 0; // 标记第 i 行需置零
                    matrix[0][j] = 0; // 标记第 j 列需置零
                }
            }
        }
        
        // 步骤 3：根据标记位置零非第一行和第一列
        // 置零非第一行
        for (int i = 1; i < m; i++) {
            if (matrix[i][0] == 0) {
                for (int j = 1; j < n; j++) {
                    matrix[i][j] = 0;
                }
            }
        }
        // 置零非第一列
        for (int j = 1; j < n; j++) {
            if (matrix[0][j] == 0) {
                for (int i = 1; i < m; i++) {
                    matrix[i][j] = 0;
                }
            }
        }
        
        // 步骤 4：处理第一行和第一列
        if (firstRowZero) {
            for (int j = 0; j < n; j++) {
                matrix[0][j] = 0;
            }
        }
        if (firstColZero) {
            for (int i = 0; i < m; i++) {
                matrix[i][0] = 0;
            }
        }
    }
}
```

#### 5. 复杂度分析
- 时间复杂度：O(mn)，四次遍历矩阵（均为 O(mn) 或 O(m)、O(n)，总复杂度 O(mn)）；
- 空间复杂度：O(1)，仅使用两个布尔变量，完全原地修改。

#### 6. 优点与缺点
- 优点：空间最优，满足原地修改要求，无额外空间开销；
- 缺点：需处理边界（第一行和第一列），逻辑相对复杂，容易遗漏步骤。
