https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&envId=top-100-liked

# 螺旋矩阵（Java 详细解法）
## 一、问题描述
给定一个 `m x n` 的矩阵 `matrix`，请按照**顺时针螺旋顺序**，返回矩阵中的所有元素。

### 核心要求：
1. 遍历顺序：顺时针螺旋（右 → 下 → 左 → 上，循环直至所有元素遍历完毕）；
2. 边界处理：需准确控制每一轮遍历的边界，避免重复遍历或越界；
3. 适配任意规模矩阵：支持单行（`m=1`）、单列（`n=1`）、正方形（`m=n`）、长方形（`m≠n`）矩阵。

### 示例：
#### 示例 1（3x3 正方形矩阵）
- 输入：
  ```
  [
    [1,2,3],
    [4,5,6],
    [7,8,9]
  ]
  ```
- 输出：`[1,2,3,6,9,8,7,4,5]`

#### 示例 2（3x4 长方形矩阵）
- 输入：
  ```
  [
    [1,2,3,4],
    [5,6,7,8],
    [9,10,11,12]
  ]
  ```
- 输出：`[1,2,3,4,8,12,11,10,9,5,6,7]`

#### 示例 3（单行矩阵）
- 输入：`[[1,2,3,4]]` → 输出：`[1,2,3,4]`

#### 示例 4（单列矩阵）
- 输入：`[[1],[2],[3],[4]]` → 输出：`[1,2,3,4]`

## 二、问题分析
### 核心难点：
- 如何控制遍历方向的切换（右 → 下 → 左 → 上）；
- 如何收缩边界，避免重复遍历（比如第一行遍历完后，上边界向下移动；最后一列遍历完后，右边界向左移动）。

### 核心思路：
采用 **“边界收缩法”**：
1. 定义四个边界变量，标记当前未遍历区域的范围：
   - `top`：上边界（初始为 0，即第一行）；
   - `bottom`：下边界（初始为 `m-1`，即最后一行）；
   - `left`：左边界（初始为 0，即第一列）；
   - `right`：右边界（初始为 `n-1`，即最后一列）；
2. 按顺时针方向循环遍历，每遍历完一行/一列后，收缩对应的边界：
   - 右移：从左到右遍历 `top` 行，遍历完后 `top++`（上边界向下收缩）；
   - 下移：从上到下遍历 `right` 列，遍历完后 `right--`（右边界向左收缩）；
   - 左移：从右到左遍历 `bottom` 行（需判断 `top ≤ bottom`，避免重复遍历），遍历完后 `bottom--`（下边界向上收缩）；
   - 上移：从下到上遍历 `left` 列（需判断 `left ≤ right`，避免重复遍历），遍历完后 `left++`（左边界向右收缩）；
3. 当 `top > bottom` 或 `left > right` 时，遍历结束（所有元素已遍历）。

## 三、详细解法（边界收缩法）
### 1. 具体步骤
#### 步骤 1：初始化变量
- 定义结果列表 `list`，存储遍历后的元素；
- 定义四个边界变量：`top = 0`、`bottom = matrix.length - 1`、`left = 0`、`right = matrix[0].length - 1`；
- 定义循环条件：`while (true)`（内部通过边界判断退出循环）。

#### 步骤 2：右移遍历（上边界行）
- 从 `left` 到 `right` 遍历 `top` 行的所有元素，加入结果列表；
- 遍历完后，`top++`（上边界向下收缩，该 row 已遍历完毕）；
- 判断：若 `top > bottom`（上边界超过下边界，无更多行可遍历），退出循环。

#### 步骤 3：下移遍历（右边界列）
- 从 `top` 到 `bottom` 遍历 `right` 列的所有元素，加入结果列表；
- 遍历完后，`right--`（右边界向左收缩，该 column 已遍历完毕）；
- 判断：若 `left > right`（左边界超过右边界，无更多列可遍历），退出循环。

#### 步骤 4：左移遍历（下边界行）
- 从 `right` 到 `left` 遍历 `bottom` 行的所有元素，加入结果列表；
- 遍历完后，`bottom--`（下边界向上收缩，该 row 已遍历完毕）；
- 判断：若 `top > bottom`，退出循环。

#### 步骤 5：上移遍历（左边界列）
- 从 `bottom` 到 `top` 遍历 `left` 列的所有元素，加入结果列表；
- 遍历完后，`left++`（左边界向右收缩，该 column 已遍历完毕）；
- 判断：若 `left > right`，退出循环。

#### 步骤 6：循环步骤 2-5，直至边界交叉退出
### 2. 示例演示（以 3x4 矩阵为例）
输入矩阵：
```
[
  [1,2,3,4],  // top=0
  [5,6,7,8],  // middle
  [9,10,11,12]// bottom=2
]
```
初始边界：`top=0`、`bottom=2`、`left=0`、`right=3`

#### 第一轮：
- 右移（top=0 行）：遍历 [1,2,3,4] → 结果 list=[1,2,3,4] → top=1；
- 下移（right=3 列）：遍历 [8,12] → list=[1,2,3,4,8,12] → right=2；
- 左移（bottom=2 行）：遍历 [11,10,9] → list=[1,2,3,4,8,12,11,10,9] → bottom=1；
- 上移（left=0 列）：遍历 [5] → list=[1,2,3,4,8,12,11,10,9,5] → left=1；

#### 第二轮：
- 右移（top=1 行）：遍历 [6,7] → list=[1,2,3,4,8,12,11,10,9,5,6,7] → top=2；
- 判断 `top=2 > bottom=1` → 退出循环。

最终结果与示例一致：`[1,2,3,4,8,12,11,10,9,5,6,7]`

### 3. Java 代码实现
```java
import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> list = new ArrayList<>();
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return list;
        }

        // 初始化边界
        int top = 0;  // 上边界，按行
        int bottom = matrix.length - 1;  // 下边界，按行
        int left = 0;  // 左边界，按列
        int right = matrix[0].length - 1;   // 右边界，按列

        while (true) {
            // 1. 右移：遍历上边界行（top），从左到右
            for (int i = left; i <= right; i++) {
                list.add(matrix[top][i]);
            }
            top++; // 上边界向下收缩
            if (top > bottom) break; // 无更多行，退出

            // 2. 下移：遍历右边界列（right），从上到下
            for (int i = top; i <= bottom; i++) {
                list.add(matrix[i][right]);
            }
            right--; // 右边界向左收缩
            if (left > right) break; // 无更多列，退出

            // 3. 左移：遍历下边界行（bottom），从右到左
            for (int i = right; i >= left; i--) {
                list.add(matrix[bottom][i]);
            }
            bottom--; // 下边界向上收缩
            if (top > bottom) break; // 无更多行，退出

            // 4. 上移：遍历左边界列（left），从下到上
            for (int i = bottom; i >= top; i--) {
                list.add(matrix[i][left]);
            }
            left++; // 左边界向右收缩
            if (left > right) break; // 无更多列，退出
        }

        return list;
    }

    // 测试用例
    public static void main(String[] args) {
        Solution solution = new Solution();

        // 示例 1：3x3 矩阵
        int[][] matrix1 = {{1,2,3},{4,5,6},{7,8,9}};
        System.out.println(solution.spiralOrder(matrix1)); // [1,2,3,6,9,8,7,4,5]

        // 示例 2：3x4 矩阵
        int[][] matrix2 = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};
        System.out.println(solution.spiralOrder(matrix2)); // [1,2,3,4,8,12,11,10,9,5,6,7]

        // 示例 3：单行矩阵
        int[][] matrix3 = {{1,2,3,4}};
        System.out.println(solution.spiralOrder(matrix3)); // [1,2,3,4]

        // 示例 4：单列矩阵
        int[][] matrix4 = {{1},{2},{3},{4}};
        System.out.println(solution.spiralOrder(matrix4)); // [1,2,3,4]
    }
}
```

### 4. 关键细节解释
- **边界判断的必要性**：
  - 左移遍历前需判断 `top ≤ bottom`：比如单行矩阵（`m=1`），右移遍历后 `top=1`，`bottom=0`，此时无需左移，直接退出；
  - 上移遍历前需判断 `left ≤ right`：比如单列矩阵（`n=1`），下移遍历后 `right=0`，`left=1`，此时无需上移，直接退出；
- **循环退出条件**：每轮遍历后都需判断边界是否交叉，避免重复遍历或越界；
- **遍历顺序的严格性**：必须按“右 → 下 → 左 → 上”的顺序，且每轮遍历后及时收缩边界，确保下一轮遍历的范围正确。

## 四、复杂度分析
- **时间复杂度**：O(mn)，其中 `m` 是矩阵行数，`n` 是矩阵列数。每个元素仅遍历一次，总遍历次数为 `m×n`；
- **空间复杂度**：O(1)（不考虑结果列表的空间）。仅使用四个边界变量和循环变量，无额外辅助空间开销。

## 五、常见错误点与注意事项
1. **遗漏边界判断**：比如左移或上移前未判断边界是否交叉，导致重复遍历（如单行矩阵左移时再次遍历同一行）；
2. **边界收缩错误**：遍历后未及时更新边界（如右移后未 `top++`），导致无限循环；
3. **矩阵为空处理**：未判断 `matrix` 为空、`matrix.length=0` 或 `matrix[0].length=0`，导致数组越界；
4. **遍历方向错误**：比如左移时从左到右、上移时从上到下，导致遍历顺序不符合螺旋要求。

## 六、拓展：螺旋矩阵 II（生成螺旋矩阵）
若题目改为“给定正整数 `n`，生成一个 `n x n` 的螺旋矩阵”（LeetCode 59 题），可复用本解法的边界收缩思路，仅需将“读取元素”改为“写入元素”：
```java
class Solution {
    public int[][] generateMatrix(int n) {
        int[][] matrix = new int[n][n];
        int top = 0, bottom = n-1, left = 0, right = n-1;
        int num = 1; // 待写入的数字
        while (true) {
            // 右移写入
            for (int i = left; i <= right; i++) matrix[top][i] = num++;
            top++;
            if (top > bottom) break;
            // 下移写入
            for (int i = top; i <= bottom; i++) matrix[i][right] = num++;
            right--;
            if (left > right) break;
            // 左移写入
            for (int i = right; i >= left; i--) matrix[bottom][i] = num++;
            bottom--;
            if (top > bottom) break;
            // 上移写入
            for (int i = bottom; i >= top; i--) matrix[i][left] = num++;
            left++;
            if (left > right) break;
        }
        return matrix;
    }
}
```

## 七、总结
螺旋矩阵的核心解法是 **“边界收缩法”**，关键在于：
1. 用四个边界变量精准控制未遍历区域；
2. 按顺时针顺序遍历，每轮后收缩对应边界；
3. 每轮遍历后判断边界是否交叉，避免重复或越界。

该解法适配所有规模的矩阵，时间复杂度 O(mn)、空间复杂度 O(1)，是最优解法。面试中遇到螺旋遍历类问题（读取/生成），均可直接套用此思路。
