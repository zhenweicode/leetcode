# 买卖股票的最佳时机（全解法+扩展问题）详解（Java）
买卖股票的最佳时机是数组类经典问题，核心是通过「低买高卖」最大化利润，不同约束条件（交易次数、冷冻期等）对应不同解法。本文将先讲解**基础版（最多买卖一次）的3种清晰解法**（暴力、贪心、动态规划），再拓展5种高频变种问题的解决方案，全程使用Java实现，逻辑分步拆解。

## 一、基础版问题定义
### 1. 核心描述
给定数组 `prices`，`prices[i]` 表示第 `i` 天的股票价格，**最多买卖一次**（买入后卖出，不可多次交易），返回最大利润；若无获利机会，返回 0。

### 2. 示例
- 输入：`prices = [7,1,5,3,6,4]` → 输出：`5`（第2天买，第5天卖，利润 `6-1=5`）；
- 输入：`prices = [7,6,4,3,1]` → 输出：`0`（价格持续下跌，无获利）。

## 二、基础版3种解法（清晰易懂）
### 解法1：暴力枚举（直观但低效）
#### 思路
枚举所有「买入日 `i` + 卖出日 `j`」（`j > i`），计算利润 `prices[j] - prices[i]`，取最大值。

#### Java代码
```java
public int maxProfit(int[] prices) {
    if (prices == null || prices.length <= 1) return 0;
    int maxProfit = 0;
    int n = prices.length;
    // 枚举买入日i
    for (int i = 0; i < n - 1; i++) {
        // 枚举卖出日j（j > i）
        for (int j = i + 1; j < n; j++) {
            int profit = prices[j] - prices[i];
            if (profit > maxProfit) {
                maxProfit = profit;
            }
        }
    }
    return maxProfit;
}
```

#### 复杂度分析
- 时间复杂度：`O(n²)`，两层循环遍历所有可能的交易对；
- 空间复杂度：`O(1)`，无额外空间消耗；
- 适用场景：仅用于理解问题本质，数组长度 `n ≤ 1000` 时可用，大规模数据会超时。

### 解法2：贪心算法（最优时间效率）
#### 思路
核心逻辑：**记录历史最低买入价，每天计算当前卖出的利润，更新最大利润**。
1. 遍历数组，维护一个变量 `minPrice`，记录截至当天的最低股票价格；
2. 对于每天的价格 `prices[i]`，计算「当前价格 - 历史最低价格」的利润；
3. 用该利润更新最大利润 `maxProfit`。

#### Java代码
```java
public int maxProfit(int[] prices) {
    if (prices == null || prices.length <= 1) return 0;
    int minPrice = prices[0]; // 历史最低买入价
    int maxProfit = 0; // 最大利润
    for (int i = 1; i < prices.length; i++) {
        // 更新历史最低买入价（若当前价格更低）
        minPrice = Math.min(minPrice, prices[i]);
        // 计算当前卖出的利润，更新最大利润
        maxProfit = Math.max(maxProfit, prices[i] - minPrice);
    }
    return maxProfit;
}
```

#### 关键说明
- 贪心的本质是「局部最优推导全局最优」：每天都做「以历史最低价买入、当前价卖出」的最优选择，最终得到全局最大利润；
- 遍历顺序：从左到右一次遍历，无需回溯，效率极高。

#### 复杂度分析
- 时间复杂度：`O(n)`，仅遍历数组一次；
- 空间复杂度：`O(1)`，仅用两个变量；
- 适用场景：基础版最优解法，适合所有规模数据。

## 三、常见扩展问题及解决方案
### 扩展1：买卖股票的最佳时机 II（无交易次数限制）
#### 问题描述
可多次买卖股票（买入后必须卖出才能再买入），求最大利润。

#### 核心变化
无交易次数限制 → 买入时的利润来源是「之前卖出后的利润」（而非基础版的0）。

#### 解法（贪心/动态规划）
##### 贪心解法（最简单）
思路：**只要当天价格比前一天高，就进行一次“低买高卖”**（相当于捕捉所有上涨区间的利润）。
```java
public int maxProfitII(int[] prices) {
    if (prices == null || prices.length <= 1) return 0;
    int maxProfit = 0;
    for (int i = 1; i < prices.length; i++) {
        // 当天价格 > 前一天价格，就赚差价
        if (prices[i] > prices[i-1]) {
            maxProfit += prices[i] - prices[i-1];
        }
    }
    return maxProfit;
}
```

### 扩展2：买卖股票的最佳时机含冷冻期
#### 问题描述
无交易次数限制，但卖出股票后，第2天不能买入（冷冻期1天）。

#### 解法（动态规划）
新增「冷冻期状态」，定义3个状态：
- `notHold`：不持有股票，且不在冷冻期；
- `hold`：持有股票；
- `cooldown`：不持有股票，且在冷冻期。

```java
public int maxProfitWithCooldown(int[] prices) {
    if (prices == null || prices.length <= 1) return 0;
    int n = prices.length;
    int notHold = 0;    // 不持有，非冷冻期
    int hold = -prices[0]; // 持有
    int cooldown = 0;   // 不持有，冷冻期
    
    for (int i = 1; i < n; i++) {
        int prevNotHold = notHold;
        // 更新不持有（非冷冻期）：继承前一天非冷冻期，或前一天冷冻期结束
        notHold = Math.max(notHold, cooldown);
        // 更新冷冻期：前一天持有，当天卖出
        cooldown = hold + prices[i];
        // 更新持有：继承前一天持有，或前一天非冷冻期买入
        hold = Math.max(hold, prevNotHold - prices[i]);
    }
    
    // 最终最大利润：非冷冻期不持有 或 冷冻期不持有
    return Math.max(notHold, cooldown);
}
```

#### 示例
- 输入：`[1,2,3,0,2]` → 输出：`3`（1买2卖，冷冻期后0买2卖，利润 `1+2=3`）。

### 扩展5：买卖股票的最佳时机含手续费
#### 问题描述
无交易次数限制，但每次卖出股票需支付固定手续费 `fee`，求最大利润。

#### 解法（动态规划）
状态转移调整：卖出股票时，利润 =「持有利润 + 当前价格 - 手续费」（扣除手续费）。

```java
public int maxProfitWithFee(int[] prices, int fee) {
    if (prices == null || prices.length <= 1) return 0;
    int notHold = 0; // 不持有
    int hold = -prices[0]; // 持有
    for (int price : prices) {
        int prevNotHold = notHold;
        // 卖出时扣除手续费
        notHold = Math.max(prevNotHold, hold + price - fee);
        hold = Math.max(hold, prevNotHold - price);
    }
    return notHold;
}
```

#### 示例
- 输入：`prices = [1,3,2,8,4,9], fee = 2` → 输出：`8`（1买8卖，4买9卖，利润 `(8-1-2)+(9-4-2)=5+3=8`）。