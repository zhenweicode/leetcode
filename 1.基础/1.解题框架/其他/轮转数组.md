https://leetcode.cn/problems/rotate-array/description/?envType=study-plan-v2&envId=top-100-liked

# 轮转数组（Java 详细解法）

轮转数组是指将数组的元素向右移动 `k` 个位置，其中 `k` 是非负数。例如，数组 `[1,2,3,4,5,6,7]` 轮转 `3` 次后变为 `[5,6,7,1,2,3,4]`。

下面介绍几种常见的解法，从基础到优化逐步分析。

## 方法一：使用额外数组（暴力解法）

### 思路
创建一个新数组，将原数组的元素按照轮转后的位置放入新数组，然后将新数组复制回原数组。

对于原数组的第 `i` 个元素，轮转 `k` 次后的位置是 `(i + k) % n`（`n` 是数组长度）。

### 代码实现
```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        int[] newArr = new int[n];
        for (int i = 0; i < n; i++) {
            newArr[(i + k) % n] = nums[i];
        }

        for(int i = 0; i < nums.length; i++) {
            nums[i] = newArr[i];
        }
    }
}
```

### 复杂度分析
- 时间复杂度：`O(n)`，其中 `n` 是数组的长度。需要遍历数组一次。
- 空间复杂度：`O(n)`，需要额外的数组来存储结果。

## 方法二：多次反转数组（最优解法）

### 思路
通过三次反转操作实现数组轮转：
1. 反转整个数组
2. 反转前 `k` 个元素
3. 反转后 `n - k` 个元素

例如，数组 `[1,2,3,4,5,6,7]`，`k=3`：
- 反转整个数组：`[7,6,5,4,3,2,1]`
- 反转前 3 个元素：`[5,6,7,4,3,2,1]`
- 反转后 4 个元素：`[5,6,7,1,2,3,4]`

### 代码实现
```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k = k % n; // 处理 k 大于 n 的情况
        reverse(nums, 0, n - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, n - 1);
    }
    
    private void reverse(int[] nums, int start, int end) {
        while (start < end) {
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start++;
            end--;
        }
    }
}
```

### 复杂度分析
- 时间复杂度：`O(n)`，其中 `n` 是数组的长度。三次反转操作的总时间复杂度是 `O(n)`。
- 空间复杂度：`O(1)`，只需要常数级别的额外空间。

## 方法三：环状替换

### 思路
将数组中的元素依次轮转，每次将一个元素放到它轮转后的位置，然后处理被替换的元素，直到完成一个循环。需要注意处理循环的终止条件，避免重复处理。

### 代码实现
```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k %= n;
        int count = 0; // 记录已经处理的元素个数
        for (int start = 0; count < n; start++) {
            int current = start;
            int prev = nums[start];
            do {
                int next = (current + k) % n;
                int temp = nums[next];
                nums[next] = prev;
                prev = temp;
                current = next;
                count++;
            } while (start != current);
        }
    }
}
```

### 复杂度分析
- 时间复杂度：`O(n)`，其中 `n` 是数组的长度。每个元素只被移动一次。
- 空间复杂度：`O(1)`，只需要常数级别的额外空间。

## 总结

| 方法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 |
|------|------------|------------|------|------|
| 额外数组 | `O(n)` | `O(n)` | 实现简单 | 空间开销大 |
| 三次反转 | `O(n)` | `O(1)` | 空间最优，实现较简单 | 思路相对不直观 |
| 环状替换 | `O(n)` | `O(1)` | 空间最优 | 实现相对复杂 |

在实际应用中，**三次反转法**是最优的选择，因为它兼具时间和空间效率，且代码实现相对简洁。
