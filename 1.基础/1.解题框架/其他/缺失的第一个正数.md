
https://leetcode.cn/problems/first-missing-positive/description/?envType=study-plan-v2&envId=top-100-liked

# 缺失的第一个正数（Java 详细解法）
## 一、问题描述
给定一个未排序的整数数组 `nums`，找出其中没有出现的最小的正整数。

### 核心要求：
1. 时间复杂度必须为 O(n)（n 为数组长度）；
2. 空间复杂度必须为 O(1)（除输入数组外，不允许使用额外辅助空间）；
3. 数组元素可能包含负数、0、重复数，且长度不固定（可能为空）。

### 示例：
- 输入：`nums = [1,2,0]` → 输出：`3`（缺失的最小正整数是 3）
- 输入：`nums = [3,4,-1,1]` → 输出：`2`（缺失的最小正整数是 2）
- 输入：`nums = [7,8,9,11,12]` → 输出：`1`（最小正整数 1 未出现）
- 输入：`nums = [1]` → 输出：`2`（仅包含 1，缺失 2）
- 输入：`nums = []` → 输出：`1`（空数组缺失最小正整数 1）

## 二、问题分析
### 关键观察：
- 最小的正整数一定在 `[1, n+1]` 范围内（n 为数组长度）：
  - 若数组包含 1~n 的所有正整数，则缺失的最小正整数是 `n+1`（如 `nums = [1,2,3]` → 缺失 4）；
  - 若数组不包含 1~n 中的某个数，则缺失的最小正整数就是这个数（如 `nums = [3,4,-1,1]` → 缺失 2）。

### 核心思路：
利用数组本身作为“哈希表”，通过**原地置换**将每个正整数 `x` 放到其对应的索引 `x-1` 位置（即 `nums[x-1] = x`）。遍历数组时，第一个索引 `i` 对应的 `nums[i] != i+1` 的位置，`i+1` 就是缺失的最小正整数；若所有位置都匹配，则缺失的是 `n+1`。

## 三、详细解法（原地置换法）
### 1. 算法步骤
#### 步骤 1：过滤无效元素，置换有效正整数
遍历数组，对每个元素 `nums[i]` 进行以下处理：
- 若 `nums[i]` 是**有效正整数**（`1 ≤ nums[i] ≤ n`），且其对应的目标位置 `nums[i]-1` 上的元素不等于 `nums[i]`（即未正确置换），则将 `nums[i]` 置换到目标位置 `nums[i]-1`；
- 置换后需重新检查当前位置 `i` 的新元素（因此用 `while` 循环，而非 `for` 循环的单次遍历）；
- 若 `nums[i]` 是负数、0 或大于 `n` 的数，直接跳过（这些元素不影响最小正整数的判断）。

#### 步骤 2：遍历数组，寻找缺失的正整数
置换完成后，再次遍历数组：
- 若 `nums[i] != i+1`，则 `i+1` 就是缺失的最小正整数，直接返回；
- 若所有元素都满足 `nums[i] == i+1`，则返回 `n+1`（数组包含 1~n 所有正整数）。

### 2. 置换逻辑演示（以 `nums = [3,4,-1,1]` 为例）
- 初始数组：`[3,4,-1,1]`（n=4）
- i=0，`nums[0]=3`（有效正整数，目标位置 2）：
  - 目标位置 `nums[2] = -1 != 3`，置换后数组变为 `[-1,4,3,1]`；
  - 置换后当前元素为 `-1`（无效），退出循环，i 自增为 1。
- i=1，`nums[1]=4`（有效正整数，目标位置 3）：
  - 目标位置 `nums[3] = 1 != 4`，置换后数组变为 `[-1,1,3,4]`；
  - 置换后当前元素为 `1`（有效），继续处理：
    - 目标位置 `nums[0] = -1 != 1`，置换后数组变为 `[1,-1,3,4]`；
    - 置换后当前元素为 `-1`（无效），退出循环，i 自增为 2。
- i=2，`nums[2]=3`（目标位置 2，已正确置换），跳过；
- i=3，`nums[3]=4`（目标位置 3，已正确置换），跳过。

#### 步骤 2 遍历检查：
- i=0：`nums[0]=1 == 0+1` → 正常；
- i=1：`nums[1]=-1 != 1+1` → 缺失的最小正整数是 `2`，返回 2。

### 3. Java 代码实现
```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        
        // 步骤 1：原地置换，将正整数 x 放到索引 x-1 位置
        for (int i = 0; i < n; i++) {
            // 循环条件：当前元素是有效正整数，且未放到正确位置
            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
                // 置换 nums[i] 到目标位置 nums[i]-1
                int targetIndex = nums[i] - 1;
                int temp = nums[targetIndex];
                nums[targetIndex] = nums[i];
                nums[i] = temp;
            }
        }
        
        // 步骤 2：遍历数组，寻找第一个不匹配的位置
        for (int i = 0; i < n; i++) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        
        // 步骤 3：所有位置都匹配，缺失的是 n+1
        return n + 1;
    }

    // 测试用例
    public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.firstMissingPositive(new int[]{1,2,0})); // 3
        System.out.println(solution.firstMissingPositive(new int[]{3,4,-1,1})); // 2
        System.out.println(solution.firstMissingPositive(new int[]{7,8,9,11,12})); // 1
        System.out.println(solution.firstMissingPositive(new int[]{1})); // 2
        System.out.println(solution.firstMissingPositive(new int[]{})); // 1
        System.out.println(solution.firstMissingPositive(new int[]{2,2})); // 1（重复元素）
    }
}
```

### 4. 关键细节解释
- **置换循环用 `while` 而非 `for`**：置换后当前位置 `i` 的新元素可能仍是有效正整数，需要继续置换（如示例中 i=1 位置的 4 置换后变为 1，需再次置换 1 到 i=0 位置）；
- **避免重复置换**：条件 `nums[nums[i]-1] != nums[i]` 确保不会对同一元素重复置换（如 `nums = [2,2]`，不会无限循环）；
- **无效元素直接跳过**：负数、0、大于 `n` 的元素不影响最小正整数的判断，无需处理。

## 四、复杂度分析
- **时间复杂度**：O(n)
  - 每个有效正整数最多被置换一次（置换后会放到正确位置，后续不会再处理）；
  - 两次遍历数组的总时间为 O(n)，无额外嵌套循环。
- **空间复杂度**：O(1)
  - 仅使用常数级别的临时变量，未使用额外辅助空间（数组本身作为“哈希表”复用）。

## 五、其他解法对比（拓展）
### 1. 哈希表法（空间 O(n)，不满足要求）
- 思路：用哈希表存储数组中的所有正整数，再从 1 开始遍历，找到第一个不在哈希表中的正整数。
- 代码：
  ```java
  public int firstMissingPositive(int[] nums) {
      Set<Integer> set = new HashSet<>();
      for (int num : nums) {
          if (num > 0) set.add(num);
      }
      for (int i = 1; i <= nums.length + 1; i++) {
          if (!set.contains(i)) return i;
      }
      return 1;
  }
  ```
- 缺点：空间复杂度 O(n)，不满足题目“空间 O(1)”的要求，仅适用于不限制空间的场景。

### 2. 标记法（修改数组元素，空间 O(1)）
- 思路：先将数组中所有非正整数标记为 `n+1`（因为最小正整数不会超过 `n+1`），再对每个有效正整数 `x`，将索引 `x-1` 位置的元素标记为负数（表示 `x` 已出现），最后遍历数组找到第一个正数，其索引+1 即为缺失值。
- 代码：
  ```java
  public int firstMissingPositive(int[] nums) {
      int n = nums.length;
      // 步骤 1：将非正整数改为 n+1
      for (int i = 0; i < n; i++) {
          if (nums[i] <= 0) nums[i] = n + 1;
      }
      // 步骤 2：标记已出现的正整数
      for (int i = 0; i < n; i++) {
          int x = Math.abs(nums[i]);
          if (x <= n) nums[x-1] = -Math.abs(nums[x-1]);
      }
      // 步骤 3：找到第一个未标记的位置
      for (int i = 0; i < n; i++) {
          if (nums[i] > 0) return i + 1;
      }
      return n + 1;
  }
  ```
- 优点：空间 O(1)，时间 O(n)；
- 缺点：修改了数组中的非正整数（若题目不允许修改原数组则不适用），而置换法仅调整有效正整数的位置，对无效元素无修改。

## 六、总结
### 最优解法推荐：原地置换法
- 满足时间 O(n)、空间 O(1) 的核心要求；
- 逻辑直观，仅通过数组原地操作实现，无额外空间开销；
- 适用于所有边界情况（空数组、全负数、重复元素等）。

### 关键总结：
1. 最小正整数的范围是 `[1, n+1]`，无需考虑大于 `n` 的元素；
2. 利用数组索引作为“哈希键”，正整数 `x` 对应索引 `x-1`，实现原地映射；
3. 置换时需处理重复元素和无效元素，避免无限循环和错误映射。

### 常见错误点：
- 忘记处理重复元素，导致置换循环无限（需加 `nums[nums[i]-1] != nums[i]` 条件）；
- 置换时用 `for` 循环单次遍历，导致部分元素未正确置换（需用 `while` 循环）；
- 忽略空数组或全负数的情况，未返回 1（需在最后返回 `n+1`，空数组 `n=0` 时返回 1）。
