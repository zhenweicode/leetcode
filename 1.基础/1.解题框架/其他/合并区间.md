https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-100-liked


### 算法核心思路
合并区间的关键是**先按区间左端点排序**，再依次判断相邻区间是否重叠：
- 若重叠（当前区间的左端点 ≤ 结果中最后一个区间的右端点），则合并为一个区间（右端点取两者的最大值）；
- 若不重叠，直接将当前区间加入结果。


### 代码逐行解析
```java
class Solution {
    public int[][] merge(int[][] intervals) {
        // 步骤1：按区间左端点升序排序
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
        
        // 步骤2：初始化结果列表，先加入第一个区间
        List<int[]> result = new ArrayList<>();
        result.add(new int[]{intervals[0][0], intervals[0][1]});
        
        // 步骤3：遍历后续所有区间，判断是否合并
        for (int i = 1; i < intervals.length; i++) {
            int m = result.size(); // 结果列表的当前长度
            int[] current = intervals[i]; // 当前待判断的区间
            int[] last = result.get(m - 1); // 结果中最后一个区间
            
            // 若当前区间左端点 ≤ 最后一个区间的右端点 → 重叠，合并
            if (current[0] <= last[1]) {
                last[1] = Math.max(last[1], current[1]); // 右端点取最大值
            } else {
                // 不重叠，直接加入结果
                result.add(new int[]{current[0], current[1]});
            }
        }
        
        // 步骤4：将List转换为二维数组返回
        int[][] resultArray = new int[result.size()][2];
        for (int i = 0; i < result.size(); i++) {
            resultArray[i] = result.get(i);
        }
        return resultArray;
    }
}
```


### 示例演示
以输入 `intervals = [[1,3],[2,6],[8,10],[15,18]]` 为例：
1. **排序后**：`[[1,3],[2,6],[8,10],[15,18]]`；
2. 初始化结果列表：`[[1,3]]`；
3. 处理 `[2,6]`：`2 ≤ 3`（重叠），合并为 `[[1,6]]`；
4. 处理 `[8,10]`：`8 > 6`（不重叠），加入结果 → `[[1,6],[8,10]]`；
5. 处理 `[15,18]`：`15 > 10`（不重叠），加入结果 → `[[1,6],[8,10],[15,18]]`；
6. 最终返回 `[[1,6],[8,10],[15,18]]`。


### 复杂度分析
- **时间复杂度**：`O(n log n)`，其中 `n` 是区间数量。主要开销是排序（`O(n log n)`），后续遍历是 `O(n)`。
- **空间复杂度**：`O(n)`，用于存储结果列表（最坏情况所有区间都不重叠）。


该解法是合并区间问题的经典高效实现，逻辑清晰且性能优异，适用于所有区间合并场景。
