

https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-100-liked

# 除自身以外数组的乘积（Java 详细解法）
## 一、问题描述
给定一个整数数组 `nums`，返回一个数组 `answer`，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余所有元素的乘积。

### 核心要求：
1. 不能使用除法（避免数组中存在 0 导致除零错误，同时满足题目常规限制）；
2. 时间复杂度必须为 O(n)（n 为数组长度）；
3. 进阶要求：空间复杂度为 O(1)（除输出数组外，不使用额外辅助空间）。

### 示例：
- 输入：`nums = [1,2,3,4]`
- 输出：`[24,12,8,6]`（解释：answer[0]=2×3×4=24，answer[1]=1×3×4=12，answer[2]=1×2×4=8，answer[3]=1×2×3=6）
- 输入：`nums = [-1,1,0,-3,3]`
- 输出：`[0,0,9,0,0]`（解释：answer[2] 对应 nums[2]=0，其余元素乘积为 (-1)×1×(-3)×3=9，其余位置因包含 0 乘积为 0）

## 二、基础解法：左右前缀乘积数组（空间 O(n)）
### 1. 算法核心思想
对于每个元素 `nums[i]`，其除自身外的乘积 = **左侧所有元素的乘积 × 右侧所有元素的乘积**。
- 左侧前缀乘积数组 `left`：`left[i]` 表示 `nums[0..i-1]` 的乘积（即 `nums[i]` 左侧所有元素的乘积）；
- 右侧后缀乘积数组 `right`：`right[i]` 表示 `nums[i+1..n-1]` 的乘积（即 `nums[i]` 右侧所有元素的乘积）；
- 最终结果 `answer[i] = left[i] × right[i]`。

### 2. 具体步骤
1. 初始化左侧前缀数组 `left`：`left[0] = 1`（第一个元素左侧无元素，乘积为 1），然后遍历数组从左到右，`left[i] = left[i-1] × nums[i-1]`；
2. 初始化右侧后缀数组 `right`：`right[n-1] = 1`（最后一个元素右侧无元素，乘积为 1），然后遍历数组从右到左，`right[i] = right[i+1] × nums[i+1]`；
3. 遍历数组，计算 `answer[i] = left[i] × right[i]`。

### 3. Java 代码实现
```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        if (n == 0) return new int[0];
        
        // 左侧前缀乘积数组：left[i] =  nums[0..i-1] 的乘积
        int[] left = new int[n];
        left[0] = 1; // 第一个元素左侧无元素，乘积为 1
        for (int i = 1; i < n; i++) {
            left[i] = left[i-1] * nums[i-1];
        }
        
        // 右侧后缀乘积数组：right[i] = nums[i+1..n-1] 的乘积
        int[] right = new int[n];
        right[n-1] = 1; // 最后一个元素右侧无元素，乘积为 1
        for (int i = n-2; i >= 0; i--) {
            right[i] = right[i+1] * nums[i+1];
        }
        
        // 计算结果：answer[i] = 左侧乘积 × 右侧乘积
        int[] answer = new int[n];
        for (int i = 0; i < n; i++) {
            answer[i] = left[i] * right[i];
        }
        
        return answer;
    }
}
```

### 复杂度分析
- 时间复杂度：O(n)，三次遍历数组（左→右、右→左、结果计算），每次遍历均为 O(n)；
- 空间复杂度：O(n)，额外使用了 `left` 和 `right` 两个长度为 n 的数组。

## 三、优化解法：原地计算（空间 O(1)，进阶要求）
### 1. 算法核心思想
基于基础解法的思路，利用输出数组 `answer` 复用空间，避免额外创建 `left` 和 `right` 数组：
1. 第一步：用 `answer` 数组存储左侧前缀乘积（替代 `left` 数组）；
2. 第二步：用一个变量 `rightProduct` 动态记录右侧后缀乘积（替代 `right` 数组），从右到左遍历数组，实时计算 `answer[i] = answer[i] × rightProduct`，并更新 `rightProduct`。

### 2. 具体步骤
1. 初始化 `answer` 数组为左侧前缀乘积：`answer[0] = 1`，遍历数组从左到右，`answer[i] = answer[i-1] × nums[i-1]`；
2. 初始化右侧乘积变量 `rightProduct = 1`（最后一个元素右侧无元素，乘积为 1）；
3. 遍历数组从右到左：
   - `answer[i] = answer[i] × rightProduct`（此时 `answer[i]` 已存储左侧乘积，乘以右侧乘积得到结果）；
   - 更新 `rightProduct = rightProduct × nums[i]`（为下一个左侧元素的右侧乘积做准备）。

### 3. Java 代码实现
```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        if (n == 0) return new int[0];
        
        int[] answer = new int[n];
        
        // 第一步：用 answer 存储左侧前缀乘积（替代 left 数组）
        answer[0] = 1;
        for (int i = 1; i < n; i++) {
            answer[i] = answer[i-1] * nums[i-1];
        }
        
        // 第二步：用变量记录右侧后缀乘积，原地更新 answer
        int rightProduct = 1; // 初始为最后一个元素的右侧乘积（1）
        for (int i = n-1; i >= 0; i--) {
            // 当前 answer[i] 是左侧乘积，乘以右侧乘积得到结果
            answer[i] = answer[i] * rightProduct;
            // 更新右侧乘积（下一个左侧元素的右侧乘积 = 当前右侧乘积 × 当前元素）
            rightProduct = rightProduct * nums[i];
        }
        
        return answer;
    }
}
```

### 代码示例演示（以 `nums = [1,2,3,4]` 为例）
1. 第一步（计算左侧前缀乘积）：
   - `answer[0] = 1`
   - `answer[1] = answer[0] × 1 = 1×1=1`
   - `answer[2] = answer[1] × 2 = 1×2=2`
   - `answer[3] = answer[2] × 3 = 2×3=6`
   - 此时 `answer = [1,1,2,6]`

2. 第二步（计算右侧乘积并更新结果）：
   - 初始 `rightProduct = 1`
   - i=3：`answer[3] = 6 × 1 = 6`，`rightProduct = 1×4=4`
   - i=2：`answer[2] = 2 × 4 = 8`，`rightProduct = 4×3=12`
   - i=1：`answer[1] = 1 × 12 = 12`，`rightProduct = 12×2=24`
   - i=0：`answer[0] = 1 × 24 = 24`，`rightProduct = 24×1=24`
   - 最终 `answer = [24,12,8,6]`（符合预期）

### 复杂度分析
- 时间复杂度：O(n)，两次遍历数组（左→右、右→左），每次遍历均为 O(n)；
- 空间复杂度：O(1)，除输出数组 `answer` 外，仅使用一个常数级变量 `rightProduct`（满足进阶要求）。

## 四、边界情况处理
1. 数组长度为 1：根据题目要求，子数组至少包含一个元素，此时除自身外无其他元素，乘积为 1（输入 `[5]`，输出 `[1]`）；
2. 数组包含 0：无需特殊处理，算法自然适配（如输入 `[-1,1,0,-3,3]`，输出 `[0,0,9,0,0]`）；
3. 数组包含负数：乘积计算会保留负号，算法无影响（如输入 `[-2,3,-4]`，输出 `[-12,8,-6]`）。

## 五、总结
| 解法 | 时间复杂度 | 空间复杂度 | 核心优势 | 适用场景 |
|------|------------|------------|----------|----------|
| 左右前缀数组 | O(n) | O(n) | 逻辑直观，易于理解 | 入门学习，不限制空间 |
| 原地计算 | O(n) | O(1) | 空间最优，满足进阶要求 | 工程实践，追求极致性能 |

### 关键总结：
1. 核心思路是“左侧乘积 × 右侧乘积”，避开除法运算，同时保证 O(n) 时间复杂度；
2. 原地计算解法的关键是“复用输出数组空间”和“动态维护右侧乘积变量”，既优化了空间，又不增加时间开销；
3. 该算法适用于所有整数数组（含 0、负数），边界情况处理全面，是该问题的最优解法。
