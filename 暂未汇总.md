[toc]

# 算法
## 一、七大排序
![](http://images2015.cnblogs.com/blog/1156565/201707/1156565-20170709101949884-639315010.jpg)
　　当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至O（n）；
　　而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O（n^2）；
　　原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。

- 稳定的排序算法：冒泡排序、直接插入排序、归并排序和基数排序
- 不稳定的排序算法：希尔排序、简单选择排序、堆排序、快速排序
### 1. 直接插入排序
```
    public static void insertionSort(int[] a) {//可以对a是否为null或者长度简单判断
        int length = a.length;
        int temp = 0;
        int j = 0;
        for (int i = 1; i < length; i++) {
            temp = a[i];
            for (j = i; j > 0 && temp < a[j - 1]; j--) {
                a[j] = a[j - 1];
            }
            a[j] = temp;
        }
    }
```
时间复杂度O(N^2)，空间复杂度O(1)，稳定

### 2. 希尔排序
```
    public static void shellSort(int[] a) {
        int i = 0;
        int j = 0;
        int temp = 0;
        int length = a.length;
        for (int increment = length / 2; increment > 0; increment /= 2) {
            for (i = increment; i < length; i++) {
                temp = a[i];
                for (j = i; j >= increment && temp < a[j - increment]; j -= increment) {
                    a[j] = a[j - increment];
                }
                a[j] = temp;
            }
        }
    }
```
时间复杂度O(NlogN)，空间复杂度O(1)，不稳定（在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动）

### 3. 简单选择排序
```
    public static void selectSort(int[] a) {
        int length = a.length;
        int temp = 0;
        for (int i = 0; i < length; i++) {
            int k = i;
            for (int j = length - 1; j > i; j--) {
                if (a[j] < a[k]) {
                    k = j;
                }
            }
            temp = a[i];
            a[i] = a[k];
            a[k] = temp;
        }
    }
```
时间复杂度O(N^2)，空间复杂度O(1)，不稳定（假设有三个数依次为：a,b,c，并且c<a=b，如果c是某轮循环的最小值，那么a会和c交换，b就在a前面了）

### 4. 堆排序
　　每次调整都是从父节点、左孩子节点、右孩子节点三者中选择最大者跟父节点进行交换(交换之后可能造成被交换的孩子节点不满足堆的性质，因此每次交换之后要重新对被交换的孩子节点进行调整。
```
    public static void  heapSort(int[] a) {
        // 首先构造大顶堆，从最后一个节点a.length-1的父节点（a.length-1-1）/2开始，
        // 直到根节点0，反复调整堆，比如0的两个儿子1和2，则i从3/2-1==0开始
        int len = a.length;
        for (int i = len / 2 - 1; i >= 0; i--) {
            adjustHeap(a, i, len - 1);
        }

        for (int i = len - 1; i > 0; i--) {// 此时不用考虑i=0，因为只剩一个节点肯定是有序的
            swap(a, 0, i); // 将堆顶元素和堆低元素交换，即得到当前最大元素正确的排序位置
            adjustHeap(a, 0, i - 1); // 将剩余的元素调整成堆
        }
    }
   
    // 将元素a[k]放到合适的位置
    private static void adjustHeap(int[] a, int k, int lastIndex) {
        int temp = a[k];
        for (int i = 2 * k + 1; i <= lastIndex; i = 2 * i + 1) { // i初始化为节点k的左孩子;i<=lastIndex表示左孩子存在
            if (i < lastIndex && a[i] < a[i + 1]) { // 先判断右孩子存在，然后再判断左右孩子的大小
                i++;
            }
            if (temp < a[i]) { // 根节点小于左右孩子中较大者
                a[k] = a[i];
                k = i; // 【关键】修改k值，以便继续向下调整
            } else {
                break;
            }
        }
        a[k] = temp; // 被调整的结点放入最终位置
    }

    private static void swap(int[] a, int i, int j) {
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
```
建堆：O(N)，每次调整O(logN)，故最好、最坏、平均情况下：O(NlogN);空间复杂度O(1)，不稳定（由于记录的比较与交换是跳跃式进行的）

#### 找到无序数组中最小的k个数
// 可以改一下逻辑，先拿到k个数，建堆（不够用Integer.MIN_VALUE补齐），然后分别插入，调整
```
    // 时间复杂度O(N*logk)，从数组arr中找到最小的k个数，一直维护一个有k个数的大顶堆即可
    public static int[] getMinKByHeap(int[] arr, int k) {
        if (k < 1 || k > arr.length) {
            return arr;
        }
        int[] kHeap = new int[k];
        for (int i = 0; i < k; i++) {
            heapInsert(kHeap, arr[i], i);
        }
        for (int i = k; i < arr.length; i++) {
            if (arr[i] < kHeap[0]) {
                kHeap[0] = arr[i];
                adjustHeap(kHeap, 0, k-1);
            }
        }
        return kHeap;
    }

    // 插入操作:向大顶堆arr的index下标位置插入数据x，假设数组index位置之前都有元素
    public static void heapInsert(int[] arr, int x, int index) {
        arr[index] = x;
        while (index != 0) {
            int parent = (index - 1) / 2;
            if (arr[parent] < arr[index]) {
                swap(arr, parent, index);
                index = parent;
            } else {
                break;
            }
        }
    }
   
    private static void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
   
    // 将元素array[k]放到合适的位置
    private static void adjustHeap(int[] array, int k, int lastIndex) {
        int temp = array[k];
        for (int i = 2 * k + 1; i <= lastIndex; i = 2 * i + 1) { // i初始化为节点k的左孩子;i<=lastIndex表示左孩子存在
            if (i < lastIndex && array[i] < array[i + 1]) { // 先判断右孩子存在，然后再判断左右孩子的大小
                i++;
            }
            if (temp < array[i]) { // 根节点小于左右孩子中较大者
                array[k] = array[i];
                k = i; // 【关键】修改k值，以便继续向下调整
            } else {
                break;
            }
        }
        array[k] = temp; // 被调整的结点放入最终位置
    }
```

### 5. 冒泡排序
```
    public static void bubbleSort(int[] a) {
        int temp;
        int flag;
        int length = a.length;
        for (int i = 0; i < length - 1; i++) {//外层循环只是用于控制排序轮数
            flag = 0;
            for (int j = 0; j < length - 1 - i; j++) {
                if (a[j] > a[j + 1]) {
                    temp = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = temp;
                    flag = 1;
                }
            }
            if(flag == 0)
                break;
        }
    }
```
时间复杂度O(N^2)，空间复杂度O(1)，稳定（当a=b，由于只有大于才做交换，故a，b的位置没有机会交换）

### 6. 快速排序
```
    public static void quickSort(int[] a) {
        if (a.length > 0) {
            quickSort(a, 0, a.length - 1);
        }
    }

    private static void quickSort(int[] a, int low, int high) {
        if (low < high) {
            int middle = getMiddle(a, low, high); // 将a数组进行一分为二
            quickSort(a, low, middle - 1); // 对低字段表进行递归排序
            quickSort(a, middle + 1, high); // 对高字段表进行递归排序
        }
    }

    private static int getMiddle(int[] a, int low, int high) {
        int temp = a[low];                   // 数组的第一个作为基准
        while (low < high) {                //从数组的两端交替地向中间扫描 
            while (low < high && a[high] >= temp) { // 不考虑=的话会陷入死循环
                high--;
            }
            a[low] = a[high];            // 比基准小的记录移到低端
            while (low < high && a[low] <= temp) {
                low++;
            }
            a[high] = a[low];           // 比基准大的记录移到高端
        }
        a[low] = temp;                     // 将基准的记录放到此时low=high的位置
        return low;                          // 返回此时基准的位置
    }
```
时间复杂度O(NlogN);
空间复杂度O(logN):首先快速排序使用的空间是O(1)的；而真正消耗空间的是递归调用，因为每次递归都要保持一些数据,我们将每次递归抽象为一次内存分配,平均O(logN)；
不稳定（当a=b>pivot且a在b前面的时候：由于从后面开始遍历，故b会先于a被替换到pivot的前面，这样，b就变成了在a的前面，也就是说，ab位置对调）

### 7. 归并排序
```
    public static void mergeSort(int[] a) {
        if (a.length > 0) {
            int[] temp =  new int[a.length];
            mergeSort(a, temp, 0, a.length - 1);
        }
    }

    private static void  mergeSort(int[] a, int[] temp, int low, int high) {
        if (low < high) {
            int mid = (low + high) / 2;
            mergeSort(a, temp, low, mid);          // 左边有序
            mergeSort(a, temp, mid + 1, high);     // 右边有序
            merge(a, temp, low, mid, high);        // 将两个有序数列合并
        }
    }

    private static void merge(int[] a, int[] temp, int low, int mid, int high) {
        int i = low;                         // 左指针
        int j = mid + 1;                     // 右指针
        int k = 0;                           // 临时数组末尾坐标
        while (i <= mid && j <= high) {      // 把较小的数先移到临时数组中
            if (a[i] <= a[j]) {
                temp[k++] = a[i++];
            } else {
                temp[k++] = a[j++];
            }
        }
        while (i <= mid) {                   // 把左边剩余的数移入临时数组
            temp[k++] = a[i++];
        }
        while (j <= high) {                  // 把右边边剩余的数移入临时数组，这种情况和上面的情况只有一个成立
            temp[k++] = a[j++];
        }
        for (i = 0; i < k; i++) {             // 将临时数组中的元素写回到原数组当中去
            a[i + low] = temp[i];
        }
    }
```
时间复杂度O(NlogN);
空间复杂度O(N):递归造成的空间复杂度为O(logN)，辅助用来归并的临时数组需要O(N)的空间，所以总空间复杂度为O(N+logN) 约为 O(N) ；
稳定（由于没有发生数据交换，所有当a=b的时候，a一开始如果在b前面，则其每一次合并后仍然在b前面）

## 二、表、栈和队列
### 1. 单链表定义
```
    private static class Node {
        int data;
        Node next;
       
        Node(int data) {
            this.data = data;
        }
    }

    private Node head;
```

### 2. 排序链表--冒泡排序
```
    public Node orderList(Node head) {
        if (head == null || head.next == null) {
            return head;
        }
        int length = 0;
        Node curNode = head;
        while (curNode != null) {
            length++;
            curNode = curNode.next;
        }

        int tmp = 0;
        Node nextNode = null;
        for (int i = 0; i < length - 1; i++) {
            curNode = head;
            nextNode = curNode.next;
            for (int j = 0; j < length - 1 - i; j++) {
                if (curNode.data > nextNode.data) {
                    tmp = curNode.data;
                    curNode.data = nextNode.data;
                    nextNode.data = tmp;
                }
                curNode = curNode.next;
                nextNode = curNode.next;
            }
        }
        return curNode;
    }
```

### 3. 去除链表中重复的元素
方法1：将链表中的元素放入一个HashMap中，时间复杂度低，但空间复杂度高;
```
    public void delDup1(Node head) {
        if(head ==null)return;
        Map<Integer,Integer> map = new HashMap<>();
        Node pre = head;     //头结点一定不被删除，先放进去
        Node cur = head.next;
        map.put(cur.data,1);
        while(cur != null){
            if(map.containsKey(cur.data)){
                pre.next = cur.next;
            }else{
                map.put(cur.data,1);
                pre = cur;
            }
            cur = cur.next;
        }
    }
```
方法2：双重循环遍历去重，空间复杂度低，但时间复杂度高
```
    public void delDup2(Node head) {
        Node p = head;
        Node q = null;
        while (p != null) {
            q = p;
            while (q.next != null) {
                if (p.data == q.next.data) {
                    q.next = q.next.next;
                } else {
                    q = q.next;
                }
            }
            p = p.next;
        }
    }
```
### 4. 查找单链表中的倒数第k个节点
这里需要声明两个指针：即两个节点型的变量first和second，首先让first和second都指向第一个节点，然后让second节点往后挪k-1个位置，此时first和second就间隔了k-1个位置，然后整体向后移动这两个节点，直到second节点走到最后一个节点的时候，此时first节点所指向的位置就是倒数第k个节点的位置。
```
    public Node findLastNode2(Node head, int k) {
        if (k == 0 || head == null) {
            return null;
        }
        Node first = head;
        Node second = head;
        for (int i = 0; i < k - 1; i++) {
            second = second.next;
            if (second == null) { // 说明k的值已经大于链表的长度了
                // throw new NullPointerException("链表的长度小于" + k);
                return null;
            }
        }
       
        while (second.next != null) {
            first = first.next;
            second = second.next;
        }
        return first;
    }
```

### 5. 查找单链表中的中间节点
```
    public Node findMidNode(Node head) {
        if (head == null) {
            return null;
        }
        Node first = head;
        Node second = head;
        while (second.next != null && second.next.next != null) { //如果判断second != null && second.next != null，会1,2,3,4,5,6的中点为4
            first = first.next;
            second = second.next.next;
        }
        return first;
    }
```

### 6. 从尾到头打印单链表
方法1：利用栈；
```
    public void reversePrint1(Node head) {
        if (head == null) {
            return;
        }
        Stack<Node> stack = new Stack<>(); // 新建一个栈
        Node current = head;
        while (current != null) {       // 将链表的所有节点压栈
            stack.push(current);
            current = current.next;
        }
        while (stack.size() > 0) {
            System.out.println(stack.pop().data);
        }
    }
```
方法2：递归
```
    public void reversePrint2(Node head) {
        if (head == null) {
            return;
        }else{
            reversePrint2(head.next);
            System.out.println(head.data);
        }
    }
```

### 7. 检测单链表是否有环，如果有环，判断环的入口点
推导见： http://www.cnblogs.com/xzwblog/p/7197708.html#_label1_12
```
    public Node FindLoopPort(Node head) {
        if (head == null || head.next == null) {
            return null;
        }
        Node fast = head;
        Node slow = head;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next; // slow指针走一步
            fast = fast.next.next; // fast指针走两步
            if (slow == fast) { // 一旦两个指针相遇，说明链表是有环的
                break;
            }
        }
        slow = head;
        while (slow != fast) {
            slow = slow.next; // slow指针走一步
            fast = fast.next; // fast指针走两步
        }
        return slow;
    }
```


### 8. 判断两个无环链表是否相交，如果相交，请输出相交点
```
    public static Node noLoop(Node head1, Node head2) {
        if (head1 == null || head2 == null) {
            return null;
        }
        Node cur1 = head1;
        Node cur2 = head2;
        int n = 0;
        while (cur1.next != null) {
            n++;
            cur1 = cur1.next;
        }
        while (cur2.next != null) {
            n--;
            cur2 = cur2.next;
        }
        if (cur1 != cur2) {
            return null;
        }
        cur1 = n > 0 ? head1 : head2;
        cur2 = cur1 == head1 ? head2 : head1;
        n = Math.abs(n);
        while (n != 0) {
            n--;
            cur1 = cur1.next;
        }
        while (cur1 != cur2) {
            cur1 = cur1.next;
            cur2 = cur2.next;
        }
        return cur1;
    }
```

### 9. 用一个栈实现另一个栈的排序
```
    public static void sortStackByStack(Stack<Integer> stack) {
        Stack<Integer> help = new Stack<Integer>();
        while (!stack.isEmpty()) {
            int cur = stack.pop();
            while (!help.isEmpty() && help.peek() < cur) {
                stack.push(help.pop());
            }
            help.push(cur);
        }
        while (!help.isEmpty()) {//最后再压回stack
            stack.push(help.pop());
        }
    }
```

## 三、树
<font color="red">二叉查找树（或二叉排序树或二叉搜索树）</font>：对于树中的每个节点X，它的左子树中所有项的值小于X中的项，而它的右子树中所有项的值大于X中的项。
<font color="red">AVL树</font>是一种平衡的二叉查找树。其每个节点的左子树和右子树的高度最多差1的二叉査找树(空树的高度定义为-1)。
<font color="red">红黑树</font>，它一种特殊的二叉搜索树。红黑树的特性:
(1) 每个节点或者是黑色，或者是红色
(2) 根节点是黑色。
(3) 每个叶子节点都带有两个空的黑色节点（被称为黑哨兵），如果一个节点n的只有一个左孩子，那么n的右孩子是一个黑哨兵；如果节点n只有一个右孩子，那么n的左孩子是一个黑哨兵。
(4) 如果一个节点是红色的，则它的子节点必须是黑色的。
(5) 从一个节点到null节点的所有路径上都包含相同数目的黑色节点。特性(5)确保没有一条路径会比其他路径长出2倍。因而，红黑树是接近平衡的二叉树。

<font color="red">队列和栈的函数</font>
栈：push，pop，peek
队列：offer，poll，peek

### 1. 树的前中后序遍历
#### 递归
```
    public static void preOrderRecur(Node head) {
        if (head == null) {
            return;
        }
        System.out.print(head.value + " ");
        preOrderRecur(head.left);
        preOrderRecur(head.right);
    }

    public static void inOrderRecur(Node head) {
        if (head == null) {
            return;
        }
        inOrderRecur(head.left);
        System.out.print(head.value + " ");
        inOrderRecur(head.right);
    }

    public static void posOrderRecur(Node head) {
        if (head == null) {
            return;
        }
        posOrderRecur(head.left);
        posOrderRecur(head.right);
        System.out.print(head.value + " ");
    }
```

#### 非递归
```
    public static void preOrderUnRecur(Node head) {
        if (head != null) {
            Stack<Node> stack = new Stack<Node>();
            stack.push(head);
            while (!stack.isEmpty()) {
                head = stack.pop();
                System.out.print(head.value + " ");
                if (head.right != null) {
                    stack.push(head.right);
                }
                if (head.left != null) {
                    stack.push(head.left);
                }
            }
        }
    }

    public static void inOrderUnRecur(Node head) {
        if (head != null) {
            Stack<Node> stack = new Stack<Node>();
            while (!stack.isEmpty() || head != null) {//打印根节点时栈为空
                if (head != null) {
                    stack.push(head);
                    head = head.left;
                } else {
                    head = stack.pop();
                    System.out.print(head.value + " ");
                    head = head.right;
                }
            }
        }
    }

    //h表示最近一次弹出并打印的节点
    //c表示stack的栈顶元素
    public static void posOrderUnRecur(Node h) {
        if (h != null) {
            Stack<Node> stack = new Stack<Node>();
            stack.push(h);
            Node c = null;
            while (!stack.isEmpty()) {
                c = stack.peek();
                if (c.left != null && h != c.left && h != c.right) {//c左子树不为空，且左右子树都未打印
                    stack.push(c.left);
                } else if (c.right != null && h != c.right) {//c右子树不为空，且右子树都未打印
                    stack.push(c.right);
                } else {//c左右子树都已打印
                    System.out.print(stack.pop().value + " ");
                    h = c;
                }
            }
        }
    }

```

### 2. 深度优先遍历DFS和广度优先遍历BFS
#### DFS
即Depth First Search。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次，对于二叉树来说，其实就是先序遍历。

#### BFS
即Breadth First Search，又叫宽度优先搜索或横向优先搜索。其过程简单来说是对每一层节点依次访问，访问完一层进入下一层，而且每个节点只能访问一次。
```
    public void levelOrderTraversal(Node root) {
        if (root == null) {
            return;
        }
        Queue<Node> queue = new LinkedList<Node>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            Node node = queue.poll();
            System.out.print(node.data + "    ");
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
    }
```

### 3. 二叉树深度
这个可以使用递归，分别求出左子树的深度、右子树的深度，两个深度的较大值+1即可。
```
    public  int getMaxDepth(Node root) {
        if (root == null)
            return 0;
        else {
            int left = getMaxDepth(root.left);
            int right = getMaxDepth(root.right);
            return 1 + Math.max(left, right);
        }
    }
```

### 4. 二叉树宽度
```

    public int getMaxWidth(Node root) {
        if (root == null)
            return 0;

        Queue<Node> queue = new LinkedList<Node>();
        int maxWidth = 1; // 最大宽度
        queue.offer(root); // 入队

        while (true) {
            int len = queue.size(); // 当前层的节点个数
            if (len == 0)
                break;
            while (len > 0) {// 如果当前层，还有节点
                Node t = queue.poll();
                len--;
                if (t.left != null)
                    queue.offer(t.left);
                if (t.right != null)
                    queue.offer(t.right);
            }
            maxWitdth = Math.max(maxWidth, queue.size());
        }
        return maxWidth;
    }
```

### 5. 判断搜索二叉树
　　搜索二叉树一个非常重要的特点的是它的中序遍历为递增序列，如果中序遍历递增，那么肯定是二叉查找树。将中序遍历简单改写即可。
```
    public static boolean isBST(Node head) {
        if (head == null) {
            return true;
        }
        Node p = head;
        Stack<Node> stack = new Stack<Node>();
        int temp = Integer.MIN_VALUE;
        while (!stack.isEmpty() || p != null) {
            if (p != null) {
                stack.push(p);
                p = p.left;
            } else {
                p = stack.pop();
                if (p.value <= temp) {
                    return false;
                }
                temp = p.value;
                p = p.right;
            }
        }
        return true;
    }
```

### 6. 通过有序数组生成平衡搜索二叉树
```
    public static Node generateTree(int[] sortArr) {
        if (sortArr == null) {
            return null;
        }
        return generate(sortArr, 0, sortArr.length - 1);
    }

    public static Node generate(int[] sortArr, int start, int end) {
        if (start > end) {
            return null;
        }
        int mid = (start + end) / 2;
        Node head = new Node(sortArr[mid]);
        head.left = generate(sortArr, start, mid - 1);
        head.right = generate(sortArr, mid + 1, end);
        return head;
    }
```

### 7. 先序、中序和后序数组两两结合重构二叉树
```
    public static Node preInToTree(int[] pre, int[] in) {
        if (pre == null || in == null) {
            return null;
        }
        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        for (int i = 0; i < in.length; i++) {
            map.put(in[i], i);
        }
        return preIn(pre, 0, pre.length - 1, in, 0, in.length - 1, map);
    }

    public static Node preIn(int[] p, int pi, int pj, int[] n, int ni, int nj, HashMap<Integer, Integer> map {
        if (pi > pj) {
            return null;
        }
        Node head = new Node(p[pi]);
        int index = map.get(p[pi]);
        //pi+1表示第一个头结点；index-ni表示左子树长度
        head.left = preIn(p, pi + 1, pi + index - ni, n, ni, index - 1, map);
        head.right = preIn(p, pi + index - ni + 1, pj, n, index + 1, nj, map);
        return head;
    }
```
```
    public static Node inPosToTree(int[] in, int[] pos) {
        if (in == null || pos == null) {
            return null;
        }
        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        for (int i = 0; i < in.length; i++) {
            map.put(in[i], i);
        }
        return inPos(in, 0, in.length - 1, pos, 0, pos.length - 1, map);
    }

    public static Node inPos(int[] n, int ni, int nj, int[] s, int si, int sj,HashMap<Integer, Integer> map){
        if (si > sj) {
            return null;
        }
        Node head = new Node(s[sj]);
        int index = map.get(s[sj]);
        head.left = inPos(n, ni, index - 1, s, si, si + index - ni - 1, map);//si + index - ni - 1由于第一个不是头结点
        head.right = inPos(n, index + 1, nj, s, si + index - ni, sj - 1, map);
        return head;
    }
```

## 四、递归
### 1. 如何把一个数组循环右移k位，比如数组12345678，k=2则变为78123456
```
    public static void shiftK(int[] a, int k) {
        reverse(a, 0, a.length - 1);
        reverse(a, 0, k - 1);
        reverse(a, k, a.length - 1);
    }

    /**
     * 倒置数组中begin和end之间的元素，包括begin和end
     */
    private static void reverse(int[] a, int begin, int end) {
        for (; begin < end; begin++, end--) {
            int temp = a[begin];
            a[begin] = a[end];
            a[end] = temp;
        }
    }
```

### 4. 打靶（递归）问题
射击运动员10枪打90环的打法有多少种？（每发成绩均为整数，且在0到10环之间，可为0环也可为10环）。
```
public class Permutation {
    private static int sum = 0;

    public static void main(String[] args) {
        compute(10, 90);
        System.out.println(sum);
    }

    // num代表还可以打多少次，scores代表还差多少分
    private static void compute(int num, int scores) {
        if (scores > num * 10)// 这种情况无论如何都打不够了
            return;
        if (num == 1) {
            if (10 >= scores)
                sum++;
            return;
        }
        for (int i = 0; i <= 10; i++)
            compute(num - 1, scores - i);
    }
}
```


射击运动员10枪打超过90环的打法有多少种？
```
public class Permutation {
    private static int sum = 0;

    public static void main(String[] args) {
        compute(10, 90);
        System.out.println(sum);
    }

    // num代表还可以打多少次，scores代表还差多少分
    private static void compute(int num, int scores) {
        if (scores > num * 10)// 这种情况无论如何都打不够了
            return;
        if (scores <= 0) {//已经打够了，剩下的随便打都可以
            sum += Math.pow(11, num);
            return;
        }
        if (num <= 0) {
            return;
        }
        for (int i = 0; i <= 10; i++)
            compute(num - 1, scores - i);
    }
}
```

## 五、动态规划
### 1. 矩阵的最小路径和
给定一个矩阵m，M行N列，规定只能从左上角开始，每次只能向右或者向下，最后到达右下角，求最小路径和。
#### 不进行空间压缩，空间复杂度O(MN)
```
    public static int minPathSum(int[][] m) {
        if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) {
            return 0;
        }
        int row = m.length;
        int col = m[0].length;
        int[][] dp = new int[row][col];
        dp[0][0] = m[0][0];
        for (int i = 1; i < row; i++) {
            dp[i][0] = dp[i - 1][0] + m[i][0];
        }
        for (int j = 1; j < col; j++) {
            dp[0][j] = dp[0][j - 1] + m[0][j];
        }
        for (int i = 1; i < row; i++) {
            for (int j = 1; j < col; j++) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + m[i][j];
            }
        }
        return dp[row - 1][col - 1];
    }
```
#### 按照列数进行空间压缩，空间复杂度O(N)
```
    public static int minPathSum(int[][] m) {
        if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) {
            return 0;
        }
        int n = m[0].length;
        int[] dp = new int[n];
        dp[0] = m[0][0];
        for (int i = 1; i < n; i++) {
            dp[i] = dp[i - 1] + m[0][i];
        }
        for (int i = 1; i < m.length; i++) {
            dp[0] = dp[0] + m[i][0];
            for (int j = 1; j < n; j++) {
                dp[j] = Math.min(dp[j], dp[j - 1]) + m[i][j];
            }
        }
        return dp[n - 1];
    }
```

#### 终极空间压缩，空间复杂度O(min(M,N))
```
    public static int minPathSum2(int[][] m) {
        if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) {
            return 0;
        }
        int more = Math.max(m.length, m[0].length); // 行数与列数较大的那个为more
        int less = Math.min(m.length, m[0].length); // 行数与列数较小的那个为less
        boolean rowmore = more == m.length; // 行数是不是大于等于列数
        int[] dp = new int[less]; // 辅助数组的长度仅为行数与列数中的最小值
        dp[0] = m[0][0];
        for (int i = 1; i < less; i++) {
            dp[i] = dp[i - 1] + (rowmore ? m[0][i] : m[i][0]);
        }
        for (int i = 1; i < more; i++) {
            dp[0] = dp[0] + (rowmore ? m[i][0] : m[0][i]);
            for (int j = 1; j < less; j++) {
                dp[j] = Math.min(dp[j - 1], dp[j])
                        + (rowmore ? m[i][j] : m[j][i]);
            }
        }
        return dp[less - 1];
    }
```

### 1. 换钱的最少货币数
假设每张货币可以重复使用，不进行空间压缩
```
    public static int minCoins1(int[] arr, int aim) {
        if (arr == null || arr.length == 0 || aim < 0) {
            return -1;
        }
        int n = arr.length;
        int max = Integer.MAX_VALUE;
        int[][] dp = new int[n][aim + 1];
        for (int j = 1; j <= aim; j++) {
            dp[0][j] = max;
            if (j - arr[0] >= 0 && dp[0][j - arr[0]] != max) {
                dp[0][j] = dp[0][j - arr[0]] + 1;
            }
        }
        int left = 0;
        for (int i = 1; i < n; i++) {
            for (int j = 1; j <= aim; j++) {
                left = max;
                if (j - arr[i] >= 0 && dp[i][j - arr[i]] != max) {
                    left = dp[i][j - arr[i]] + 1;
                }
                dp[i][j] = Math.min(left, dp[i - 1][j]);
            }
        }
        return dp[n - 1][aim] != max ? dp[n - 1][aim] : -1;
    }
```
空间压缩：
```
    public static int minCoins2(int[] arr, int aim) {
        if (arr == null || arr.length == 0 || aim < 0) {
            return -1;
        }
        int n = arr.length;
        int max = Integer.MAX_VALUE;
        int[] dp = new int[aim + 1];
        for (int j = 1; j <= aim; j++) {
            dp[j] = max;
            if (j - arr[0] >= 0 && dp[j - arr[0]] != max) {
                dp[j] = dp[j - arr[0]] + 1;
            }
        }
        int left = 0;
        for (int i = 1; i < n; i++) {
            for (int j = 1; j <= aim; j++) {
                left = max;
                if (j - arr[i] >= 0 && dp[j - arr[i]] != max) {
                    left = dp[j - arr[i]] + 1;
                }
                dp[j] = Math.min(left, dp[j]);
            }
        }
        return dp[aim] != max ? dp[aim] : -1;
    }
```
假设每张货币不可以重复使用，不进行空间压缩
```
    public static int minCoins3(int[] arr, int aim) {
        if (arr == null || arr.length == 0 || aim < 0) {
            return -1;
        }
        int n = arr.length;
        int max = Integer.MAX_VALUE;
        int[][] dp = new int[n][aim + 1];
        for (int j = 1; j <= aim; j++) {
            dp[0][j] = max;
        }
        if (arr[0] <= aim) {
            dp[0][arr[0]] = 1;
        }
        int leftup = 0; // 左上角某个位置的值
        for (int i = 1; i < n; i++) {
            for (int j = 1; j <= aim; j++) {
                leftup = max;
                if (j - arr[i] >= 0 && dp[i - 1][j - arr[i]] != max) {
                    leftup = dp[i - 1][j - arr[i]] + 1;
                }
                dp[i][j] = Math.min(leftup, dp[i - 1][j]);
            }
        }
        return dp[n - 1][aim] != max ? dp[n - 1][aim] : -1;
    }
```
空间压缩：
```
    public static int minCoins4(int[] arr, int aim) {
        if (arr == null || arr.length == 0 || aim < 0) {
            return -1;
        }
        int n = arr.length;
        int max = Integer.MAX_VALUE;
        int[] dp = new int[aim + 1];
        for (int j = 1; j <= aim; j++) {
            dp[j] = max;
        }
        if (arr[0] <= aim) {
            dp[arr[0]] = 1;
        }
        int leftup = 0; // 左上角某个位置的值
        for (int i = 1; i < n; i++) {
            for (int j = aim; j > 0; j--) {//特别注意这里：不能从0→aim计算
                leftup = max;
                if (j - arr[i] >= 0 && dp[j - arr[i]] != max) {
                    leftup = dp[j - arr[i]] + 1;
                }
                dp[j] = Math.min(leftup, dp[j]);
            }
        }
        return dp[aim] != max ? dp[aim] : -1;
    }
```


### 2. 换钱的方法数
假设每张货币可以重复使用，再给定整数aim表示要找的钱数，求换钱的方法数。
dp[i][j]=dp[i-1][j]+dp[i][j-arr[i]];
```
    public static int coins(int[] arr, int aim) {
        if (arr == null || arr.length == 0 || aim < 0) {
            return 0;
        }
        int[] dp = new int[aim + 1];
        for (int j = 0; arr[0] * j <= aim; j++) {
            dp[arr[0] * j] = 1;
        }
        for (int i = 1; i < arr.length; i++) {
            for (int j = 1; j <= aim; j++) {
                dp[j] += j - arr[i] >= 0 ? dp[j - arr[i]] : 0;
            }
        }
        return dp[aim];
    }
```

### 3. 最长公共子序列问题
给定两个字符串str1和str2，返回两个字符串的最长公共子序列。
```
    public static int[][] getdp(char[] str1, char[] str2) {
        int[][] dp = new int[str1.length][str2.length];
        dp[0][0] = str1[0] == str2[0] ? 1 : 0;
        for (int i = 1; i < str1.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], str1[i] == str2[0] ? 1 : 0);
        }
        for (int j = 1; j < str2.length; j++) {
            dp[0][j] = Math.max(dp[0][j - 1], str1[0] == str2[j] ? 1 : 0);
        }
        for (int i = 1; i < str1.length; i++) {
            for (int j = 1; j < str2.length; j++) {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                if (str1[i] == str2[j]) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + 1);
                }
            }
        }
        return dp;
    }

    public static String lcse(String str1, String str2) {
        if (str1 == null || str2 == null || str1.equals("") || str2.equals("")) {
            return "";
        }
        char[] chs1 = str1.toCharArray();
        char[] chs2 = str2.toCharArray();
        int[][] dp = getdp(chs1, chs2);
        int m = chs1.length - 1;
        int n = chs2.length - 1;
        char[] res = new char[dp[m][n]];
        int index = res.length - 1;
        while (index >= 0) {
            if (n > 0 && dp[m][n] == dp[m][n - 1]) {
                n--;
            } else if (m > 0 && dp[m][n] == dp[m - 1][n]) {
                m--;
            } else {
                res[index--] = chs1[m];
                m--;
                n--;
            }
        }
        return String.valueOf(res);
    }
```

### 4. 最长公共子串问题
给定两个字符串str1和str2，返回两个字符串的最长公共子串。
```
    public static String lcst1(String str1, String str2) {
        if (str1 == null || str2 == null || str1.equals("") || str2.equals("")) {
            return "";
        }
        char[] chs1 = str1.toCharArray();
        char[] chs2 = str2.toCharArray();
        int[][] dp = getdp(chs1, chs2);
        int end = 0;
        int max = 0;
        for (int i = 0; i < chs1.length; i++) {
            for (int j = 0; j < chs2.length; j++) {
                if (dp[i][j] > max) {
                    end = i;
                    max = dp[i][j];
                }
            }
        }
        return str1.substring(end - max + 1, end + 1);
    }

    public static int[][] getdp(char[] str1, char[] str2) {
        int[][] dp = new int[str1.length][str2.length];
        for (int i = 0; i < str1.length; i++) {
            if (str1[i] == str2[0]) {
                dp[i][0] = 1;
            }
        }
        for (int j = 1; j < str2.length; j++) {
            if (str1[0] == str2[j]) {
                dp[0][j] = 1;
            }
        }
        for (int i = 1; i < str1.length; i++) {
            for (int j = 1; j < str2.length; j++) {
                if (str1[i] == str2[j]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
            }
        }
        return dp;
    }
```

### 5. 背包问题
http://www.cnblogs.com/xzwblog/p/7221398.html#_label1_13

## 六、字符串问题
### 1. 判断两个字符串是否有相同的字符组成
集合法（空间换时间）
```
    public boolean compare(String str1, String str2) {
        if (str1 == null || str2 == null || str1.length() != str2.length()) {
            return false;
        }
        char[] c1 = str1.toCharArray();
        char[] c2 = str2.toCharArray();

        Map<Character, Integer> map = new HashMap<Character, Integer>();
        for (int i = 0; i < c1.length; i++) {
            if (map.containsKey(c1[i])) {
                map.put(c1[i], map.get(c1[i]) + 1);
            } else {
                map.put(c1[i], 1);
            }
        }
        for (int j = 0; j < c2.length; j++) {
            if (map.containsKey(c1[j]) && map.get(c1[j]) == 1) {
                map.remove(c1[j]);
            } else {
                map.put(c1[j], map.get(c1[j]) - 1);
            }
        }
        return map.isEmpty();
    }
```
数组法（空间换时间）
```
    public boolean compare(String str1, String str2) {
        if (str1 == null || str2 == null || str1.length() != str2.length()) {
            return false;
        }

        byte[] b1 = str1.getBytes();
        byte[] b2 = str2.getBytes();

        int[] num = new int[256];
        for (int i = 0; i < b1.length; i++) {
            num[b1[i]]++;
        }

        for (int i = 0; i < b2.length; i++) {
            if (num[b2[i]] != 0) { // 不满足直接返回false，最小化判断次数
                num[b2[i]]--;
            } else {
                return false;
            }
        }
        return true;
    }
```

注意：str1.toCharArray()和str1.getBytes()的区别，前者是得到字符数组，后者是得到字节数组，比如字符串"an"，分别得到：
![](http://images2017.cnblogs.com/blog/1156565/201708/1156565-20170806112454803-22771931.png)
其实两者相似，我们可以num['a']或者num[97]，会自动转化的。

## 大数据算法
### Bloom Filter
　即布隆过滤器，它可以用于检索一个元素是否在一个集合中。在垃圾邮件的黑白名单过滤、爬虫(Crawler)的网址判重等中经常被用到。它的优点是空间效率和查询时间都优于一般的算法，缺点是有一定的误识别率和删除困难。
　Bloom-Filter算法的核心思想就是利用多个独立均匀分布的Hash函数来解决“冲突”。为了添加一个元素，用k个hash函数将它hash得到bloom filter中k个bit位，将这k个bit位置1(超过m的取余%m)。为了查询一个元素，即判断它是否在集合中，用k个hash函数将它hash得到k个bit位。若这k bits全为1，则此元素以概率(1-p)在集合中；若其中任一位不为1，则此元素必不在集合中（因为如果在，则在添加时已经把对应的k个bits位置为1）。

### Hash
　Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把一个对象的关键字，通过散列算法，映射到一个固定长度的数组中。当我们想要找到对应的对象时，只需要根据它的关键字在散列表中查找（再计算一次散列值）。散列函数一般要求不同输入获得的散列值尽量均匀分布，并且尽可能减少冲突。常用的散列算法：直接定址法；折叠法；平方取中法；除留余数法。
　Hash处理冲突方法：开放定址法；再散列法；链地址法；

### Bit-Map（位图）
　比如：给你一个文件，里面包含40亿个非负整数，写一个算法找出该文件中不包含的一个整数， 假设你有1GB内存可用。如果你只有10MB的内存呢？
　　 32位无符号整数的范围是0~4294967295(即2 x 2147483647+1)，因此可以申请一个长度为4294967295的bit数组bitArr，bitArr的每个位置只可以表示0或者1。8个bit为1B，所以长度为4294967295的数组占用内存：40*10^8bit=0.5GB=500MB。
　　 然后遍历这40亿个无符号数，例如，遇到7000，就把bitArr[7000]置为1。遍历数字完成后，遍历bitArr，哪个位置的值为0，哪个数就不在这40亿个数内。

现在我们来看如果内存要求是10MB呢？
　　 我们可以将所有0~4294967295的数据平均分成64个区间，每个区间保存67108864个数，比如：第0区间[0~67108863]，第1区间[67108864~134217727]，第i区间为[67108864i~67108864(i+1)-1]...,实际上我们并不保存这些数，而是给每一个区间设置一个计数器。这样每读入一个数，我们就在它所在的区间对应的计数器加1。处理结束之后， 我们找到一个区间，它的计数器值小于区间大小(67108864)， 说明了这一段里面一定有数字是文件中所不包含的。然后我们单独处理这个区间即可。接下来我们就可以用Bit Map算法了。申请长度为67108864的bitArr，记为bitArr[0..67108863]，我们再遍历一遍数据， 把落在这个区间的数对应的位置1(当然数据要经过处理，即落在区间i的数num，则bitArr[num-67108864*i]=1)。 最后我们找到这个区间中第一个为0的位，其对应的数就是一个没有出现在该文件中的数。

再比如：
2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。
将bit-map扩展一下，用2bit表示一个数即可，00表示未出现，01表示出现一次，10表示出现2次及以上，在遍历这些数的时候，如果对应位置的值是00，则将其置为01；如果是01，将其置为10；如果是10，则保持不变。或者我们不用2bit来进行表示，我们用两个bit-map即可模拟实现这个2bit-map，都是一样的道理。

#### 外排序

　　当待排序的对象数目特别多时，在内存中不能一次处理，必须把它们以文件的形式存放于外存，排序时再把他们一部分一部分的调入内存进行处理，这种方式就是外排序法。
　　基本原理及要点：
外部排序的两个独立阶段：
1）首先按内存大小，将外存上含n个记录的文件分成若干长度为L的子文件或段。依次将子文件读入内存并利用有效的内部排序对他们进行排序，并将排序后得到的有序子文件重新写入外存，通常称这些子文件为归并段。
2）对这些归并段进行逐趟归并，使归并段逐渐由小到大，最后在外存上形成整个文件的单一归并段，也就完成了文件的外排序。
　　适用范围：
　　大数据的排序，去重

一个典型实现：
假设文件被分成L段子文件，需要将所有数据从大到小进行排序（即先将最大的输出，再输出第二大的，直到所有元素的顺序被获得）。
（1）依次读入每个文件块，在内存中对当前文件块进行排序（应用恰当的内排序算法），并将排序后的结果直接写入外存文件（分别写到不同的子文件）。此时，每块文件相当于一个由大到小排列的有序队列。
（2）接下来进行多路归并排序，在内存中建立一个L个元素的大顶堆（注意这里的要求不仅仅是要获得topK，还要按照从大到小的排序输出，所以没使用小顶堆），建堆的过程就是把L块文件中每个文件的队列头（每个文件的最大值）依次加入到堆里，并调整成大顶堆。
（3）弹出堆顶元素，如果堆顶元素来自第i块（怎么知道堆顶元素来自哪一块？可以在内存中建立一个hashMap，以第几个子文件为key，以最近一个加入的元素为value，每次新加入元素则更新value），则从第i块文件中补充一个元素到大顶堆，并调整大顶堆结构。弹出的元素暂存至临时数组。
（4）当临时数组存满时，将数组写至磁盘，并清空数组内容。
（5）重复过程（3）、（4），直至所有文件块读取完毕。

### top K问题
如何分流：可以根据数据值或者把数据hash(md5)后的值，按照范围划分到不同的子集，但是计算md5代价是比较高的，可以考虑其他比较简单的hash。一般应用查询的是字符串，关于String的hash函数，由于字符串计算hashCode类似于31进制转10进制，因此7个左右的字符（接近`2^5*2^5*2^5`...，不用32的原因是最后算的值有效位太少）就可以达到最大int值，然后利用hashCode的低16位和高16位异或，尽量取所有的特征位，可见自学Java HashMap源码，再%表长，可以有效分流。

　针对top K类问题，通常比较好的方案是：hash映射分流 + hashMap统计 + 小顶堆求topK，即先将数据集按照Hash映射分解成多个小数据集，然后使用Trie树或者HashMap统计每个小数据集中的query词频，之后用小顶堆求出每个数据集中出现频率最高的前K个数，最后在所有top K中求出最终的top K。

eg：有1亿个浮点数，如果找出其中最大的10000个？
Hash去重+最小堆法。如果这1亿个数里面有很多重复的数，先通过hashMap，把这1亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治+最小堆法或直接最小堆法查找最大的10000个数。

### 重复问题
针对此类问题，一般可以通过位图法实现。
（1）给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？
方案1：
可以估计每个文件的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。

遍历文件a，对每个url求hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,a2...a999）中，这样每个小文件的大约为300M。
遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,b2...b999）中。这样处理后，所有可能相同的url都在对应(a0-b0,a1-b1,...,a999-b999)的小文件中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。
求每对小文件中相同的url时，可以把其中一个小文件的url存储到hashSet中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hashSet中，如果是，那么就是共同的url，存到文件里面就可以了。
方案2：
如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示320亿bit。将其中一个文件中的url使用Bloom filter映射为这320亿bit，然后逐个读取另外一个文件的url，检查它是否在Bloom filter表示的集合中，如果是，那么该url应该是共同的url（注意会有一定的错误率）。

（2）在25亿个整数中找出不重复的整数，内存不足以容纳这25亿个整数。
方案1：
采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需2^32∗2bit=2^30B=1GB内存，还可以接受。然后扫描这25亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所有整数遍历完成后，查看bitmap，把对应位是01的整数输出即可。也就是2^32b=0.5*2^30B=500MB

方案2：
采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文件中不重复的整数。对于每个小文件，用hash_map(int,count)来统计每个整数出现的次数，输出即可。

### 排序问题
一般采用位图(若为int型的数，最多2^32,2^32*1bit=2^30/2B=0.5GB=500MB，完全可以放入内存)或者外排序。
（1）有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。
方案1：
- 顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为a0,a1,a2...a9）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。
- 找一台内存在2G左右的机器(如果可用内存很小，则分到更多的文件中)，依次对a0,a1,a2...a9用hash_map(query, query_count)来统计每个query出现的次数，然后利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（记为b0,b1,b2...b9）。
- 对b0,b1,b2...b9这10个文件进行归并排序（内排序与外排序相结合）。

方案2：
一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了

方案3：
与方案1类似，但在做完hash，分成多个文件后，可以交给多个机器来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。

## 图论算法
　　邻接矩阵：A[u][v]=1（无权图）表示u可以到v。A[u][v]=3（有权图）表示u到v花费代价3。
　　顶点的度（ degree） 是指依附于某顶点 v 的边数，通常记为 TD (v)。顶点 v 的入度（ in degree） 是指以顶点为终点的边的数目，记为 ID (v)；顶点 v 出度（ out degree） 是指以顶点 v 为起始点的边的数目，记为 OD (v)。对于有向图有 TD(v) = ID(v) ＋ OD(v)。在无向图中每条边都可以看成出边，也可以看成入边，此时 TD(v) = ID(v) = OD(v)。
　　广度优先搜索（ breadth first search,BFS）按层处理顶点。 距起始点最近的那些顶点首先被求值，最远点则最后被求值，这很像对树的层序遍历（level-order traversal）。
　　深度优先搜索（depth-first search,DFS）是对前序遍历的推广。深度优先搜索的基本方法是：从图中某个顶点发 v 出发，访问此顶点，然后依次从 v 的未被访问的邻接点出发深度优先遍历图，直至图中所有和 v 有路径相通的顶点都被访问到；若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。

## 数组和矩阵问题
### 未排序数组中累加和为给定值的最长子数组系列问题
```
    public static int maxLength(int[] arr, int k) {
        if (arr == null || arr.length == 0) {
            return 0;
        }
        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        map.put(0, -1); // important
        int len = 0;
        int sum = 0;
        for (int i = 0; i < arr.length; i++) {
            sum += arr[i];
            if (map.containsKey(sum - k)) {
                len = Math.max(i - map.get(sum - k), len);
            }
            if (!map.containsKey(sum)) {
                map.put(sum, i);
            }
        }
        return len;
    }
```

### 子数组的最大累加和问题
```
    public static int maxSum(int[] arr) {
        if (arr == null || arr.length == 0) {
            return 0;
        }
        int max = Integer.MIN_VALUE;
        int cur = 0;
        for (int i = 0; i != arr.length; i++) {
            cur += arr[i];
            max = Math.max(max, cur);
            cur = cur < 0 ? 0 : cur;
        }
        return max;
    }
```

### 数组中子数组的最大累乘积问题
```
    public static double maxProduct(double[] arr) {
        if (arr == null || arr.length == 0) {
            return 0;
        }
        double max = arr[0];
        double min = arr[0];
        double res = arr[0];
        double maxEnd = 0;
        double minEnd = 0;
        for (int i = 1; i < arr.length; ++i) {
            maxEnd = max * arr[i];
            minEnd = min * arr[i];
            max = Math.max(Math.max(maxEnd, minEnd), arr[i]);
            min = Math.min(Math.min(maxEnd, minEnd), arr[i]);
            res = Math.max(res, max);
        }
        return res;
    }
```


### 数组分区问题
　　有一个数组，再给定一个值k，请实现比k小的数都放在数组的左边，等于k的数都放在数组的中间，比k大的数都放在数组的右边。要求时间复杂度O(N)，空间复杂度O(1)。

　　利用双指针的思路，首先将比k小的和不比k小的左右分开；然后在不比k小的子数组中，再将等于k的数和大于k的数分开，遍历两遍数组，复杂度符合题目要求。
```
    public static void splitArray(int[] arr, int k) {
        if (arr == null || arr.length < 2) {
            return;
        }

        int left = 0;
        int right = arr.length - 1;
        while (left < right) {
            while (left < right && arr[left] < k) {
                left++;
            }
            while (left < right && arr[right] >= k) {
                right--;
            }
            swap(arr, left++, right--);
        }
        // 注意：在上面运行时，left可能停在不比k小的子数组的第一个元素（最后left==right的位置符合arr[left] < k），
        // 也可能停在第二个元素(最后left==right的位置符合arr[left] >=k)，因为交换完成后又执行了left++;right--

        left = left - 1;// 保证能包括不比k小的子数组中的所有元素即可
        right = arr.length - 1;
        while (left < right) {
            while (left < right && arr[left] <= k) {// 取等号防止left = left-1后包括了arr[left] == k的元素
                left++;
            }
            while (left < right && arr[right] > k) {
                right--;
            }
            swap(arr, left++, right--);
        }
    }

    public static void swap(int[] nums, int n1, int n2) {
        int tmp = nums[n1];
        nums[n1] = nums[n2];
        nums[n2] = tmp;
    }
```


## 位运算
### 整数的二进制中有多少个1
要经过32次循环的方法
```
    public static int count1(int n) {
        int res = 0;
        while (n != 0) {
            res += n & 1;
            n >>>= 1;
        }
        return res;
    }
```
n&(n-1)抹去最右边的1
```
    public static int count2(int n) {
        int res = 0;
        while (n != 0) {
            n &= (n - 1);
            res++;
        }
        return res;
    }
```
n&(~n+1)得到最右边的1
```
    public static int count3(int n) {
        int res = 0;
        while (n != 0) {
            n -= n & (~n + 1);
            res++;
        }
        return res;
    }
```

### 在其他数都出现偶数次的数组中找到出现奇数次的数
```
    public static void printOddTimesNum1(int[] arr) {
        int eO = 0;
        for (int cur : arr) {
            eO ^= cur;
        }
        System.out.println(eO);
    }
```

### 在其他数都出现k词的数组中找到只出现1次的数
```
    public static int onceNum(int[] arr, int k) {
        int[] eO = new int[32];
        for (int i = 0; i != arr.length; i++) {
            setExclusiveOr(eO, arr[i], k);
        }
        int res = getNumFromKSysNum(eO, k);
        return res;
    }

    public static void setExclusiveOr(int[] eO, int value, int k) {
        int[] curKSysNum = getKSysNumFromNum(value, k);
        for (int i = 0; i != eO.length; i++) {
            eO[i] = (eO[i] + curKSysNum[i]) % k;
        }
    }

    //10转k进制
    public static int[] getKSysNumFromNum(int value, int k) {
        int[] res = new int[32];
        int index = 0;
        while (value != 0) {
            res[index++] = value % k;
            value = value / k;
        }
        return res;
    }

    //k转10进制
    public static int getNumFromKSysNum(int[] eO, int k) {
        int res = 0;
        for (int i = eO.length - 1; i != -1; i--) {
            res = res * k + eO[i];
        }
        return res;
    }
```


## 其他题目
### 任意进制转换
```
    /**
     * 10进制转k进制
     * @param num 输入10进制数
     * @param k 输出k进制数
     */
    public static String toKConvert(int num, int k) {
        StringBuffer numk = new StringBuffer();
        int temp = 0;
        while (num != 0) {
            temp = num % k;
            if (temp > 9) {
                numk.append((char) ('a' + temp - 10));// 千万注意，这里括号不能删除(char)('a' + b - 10)
            } else {
                numk.append(temp);
            }
            num = num / k;
        }
        return numk.reverse().toString();
    }

    /**
     * 将36进制内的任意进制数转换为10进制
     *
     * @param num_k 输入36进制内字符串
     * @param k 输入进制数
     */
    public static int to10Convert(String numk, int k) {
        int num = 0; // 转换后的10进制
        int temp = 0; // numk的任一位的ASCII码
        int temp2 = 0; // temp对应的10进制数
        for (int i = 0; i <numk.length(); i++) {
            temp = (int) numk.charAt(i);
            if (temp >= (int) 'a') {
                temp2 = temp - 'a' + 10;
            } else {
                temp2 = temp - '0';
            }
            num = num * k + temp2;
        }
        return num;
    }

    /**
     * 将任意进制转任意进制
     *
     * 比如16进制4cf，转为25进制数,那就先转换为10进制，再转换为25进制
     * @param numk 输入36进制内字符串
     * @param ki 输入进制数
     * @param ko 输出进制数
     */
    public static String kConvert3(String numki, int ki, int ko) {
        int num=to10Convert(numki, ki);
        return toKConvert(num, ko);
    }
```

### 反射消除String的不可变性
```
public static void main(String[] args) throws Exception{
    String str = "hello" ;    //实例化一个String类对象
    String s = str ;    //用于后面的比较测试
    //打印字符串和hashCode编码
    System.out.println(str + "::" + str.hashCode());//hello::99162322
    Class<?> cls = String.class;
    Field value = cls.getDeclaredField("value");
    value.setAccessible(true);
    char[] arr = (char[]) value.get(str);    //反射取得str对象的字符数组
    arr[0] = 's' ;   //修改字符数组的内容
    System.out.println(str + "::" + str.hashCode());//sello::99162322
    System.out.println(s == str); //比较两次是否相同
}
```

### 单例模式
立即加载/“饿汉模式”
```
/**
 * 立即加载方式==饿汉模式
 * 此代码版本为立即加载，此版本代码的缺点是类加载时就要初始化对象
 */
public class Test {
    private Test() {}

    private static Test uniqueInstance = new Test();

    public static Test getInstance() { 
        return uniqueInstance;
    }
}
```
内部类方式--推荐：
```
public class Test {
    private static class MyObject {
        public static Test uniqueInstance = new Test();
    }

    private Test() {
    }

    public static Test getInstance() {
        return MyObject.uniqueInstance;
    }
}
```

### 死锁的经典例子
```
public class LeftRightDeadlock {
    private final Object left = new Object();
    private final Object right = new Object();

    public void leftRight() {
        synchronized (left) {
            synchronized (right) {
                doSomething();
            }
        }
    }

    public void rightLeft() {
        synchronized (right) {
            synchronized (left) {
                doSomethingElse();
            }
        }
    }

    void doSomething() {
    }

    void doSomethingElse() {
    }
}
```

### 利用线程间通信实现生产者消费者模式
```
public class MyLinkedBlockingList {
    private final AtomicInteger count = new AtomicInteger();
    private final Object putLock = new Object();
    private final Object takeLock = new Object();
    private final LinkedList<Integer> list = new LinkedList<>();
    private final int capacity;

    public MyLinkedBlockingList(int capacity) {
        if (capacity < 0)
            throw new IllegalArgumentException();
        this.capacity = capacity;
    }

    public void put(int data) {
        int c = -1;
        try {
            synchronized (putLock) {
                // 使用while判断是为了防止线程被"伪唤醒”而出现的情况,即当线程被唤醒时而队列的大小依旧等于capacity时，线程应该继续等待，即线程恢复运行后从this.wait()重新执行，此时还会判断while条件
                while (count.get() == capacity) {
                    putLock.wait();
                }
                list.addLast(data);
                // 为了判断执行插入后要不要唤醒取出线程，只有在插入之前队列大小为0才需要唤醒一个
                c = count.getAndIncrement();// 返回值为改变之前的值

                /*
                 * 注:c+1得到的结果是新元素入队列之后队列元素的总和。当前队列中的总元素个数小于最大容量时,
                 * 此时唤醒其他执行入队列的线程让它们可以放入元素,如果新加入元素之后,队列的大小等于capacity，
                 * 那么就意味着此时队列已经满了,也就没有必须要唤醒其他正在等待入队列的线程,因为唤醒它们之后，它们也还是继续等待。
                 * 加入这个判断的原因： 由于take方法每次就唤醒一个put的线程，可能永远就一个生产者在工作
                 */
                if (c + 1 < capacity)
                    putLock.notify();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // 之前的队列是空队列,出队列的线程都处于等待状态，现在添加了一个新的元素,即队列不再为空,因此它会唤醒正在等待获取元素的线程
        if (c == 0) {
            // 必须获得takeLock的锁才能调用notify()
            synchronized (takeLock) {
                takeLock.notify();
            }
        }
    }

    public int take() {
        int x = 0;
        int c = -1;
        try {
            synchronized (takeLock) {
                while (count.get() == 0) {
                    takeLock.wait();
                }
                x = list.removeFirst();
                c = count.getAndDecrement();
                if (c > 1)
                    takeLock.notify();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        if (c == capacity) {
            synchronized (putLock) {
                putLock.notifyAll();
            }
        }
        return x;
    }
}
```
```
public class Test {
    private static class Producter extends Thread {
        public volatile boolean stop = false;
        private final MyLinkedBlockingList myLinkedBlockingList;

        public Producter(MyLinkedBlockingList myLinkedBlockingList) {
            this.myLinkedBlockingList = myLinkedBlockingList;
        }

        @Override
        public void run() {
            Random random = new Random();
            while (!stop) {
                myLinkedBlockingList.put(random.nextInt(1000));
            }
        }
    }

    private static class Consumer extends Thread {
        public volatile boolean stop = false;
        private MyLinkedBlockingList myLinkedBlockingList;

        public Consumer(MyLinkedBlockingList myLinkedBlockingList) {
            this.myLinkedBlockingList = myLinkedBlockingList;
        }

        @Override
        public void run() {
            while (!stop) {
                System.out.println(myLinkedBlockingList.take());
            }
        }
    }

    public static void main(String[] args) {
        MyLinkedBlockingList myLinkedBlockingList = new MyLinkedBlockingList(500);
        for (int i = 0; i < 3; i++) {
            new Producter(myLinkedBlockingList).start();
        }
        for (int i = 0; i < 3; i++) {
            new Consumer(myLinkedBlockingList).start();
        }
    }
}
```

### 阻塞队列生产者消费者模式

```

public class Test3 {

    private static Integer count = 0;

    //创建一个阻塞队列

    private static final BlockingQueue<Integer> blockingQueue = new LinkedBlockingQueue<>(10);



    class Producer implements Runnable {

        public void run() {

            for (int i = 0; i < 10; i++) {

                try {

                    blockingQueue.put(1);

                    count++;

                    System.out.println(Thread.currentThread().getName() + "生产者生产，目前总共有" + count);

                } catch (InterruptedException e) {

                    e.printStackTrace();

                }

            }

        }

    }



    class Consumer implements Runnable {

        public void run() {

            for (int i = 0; i < 10; i++) {

                try {

                    blockingQueue.take();

                    count--;

                    System.out.println(Thread.currentThread().getName() + "消费者消费，目前总共有" + count);

                } catch (InterruptedException e) {

                    e.printStackTrace();

                }

            }

        }

    }

}

```



### 动态代理
```
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

interface IUserDao {
    void save();
}

class UserDao implements IUserDao {
    public void save() {
        System.out.println("----已经保存数据!----");
    }
}

class ProxyFactory {
    private Object target;

    public ProxyFactory(Object target) {
        this.target = target;
    }

    // 给目标对象生成代理对象，其class文件是由 JVM 在运行时动态生成
    public Object getProxyInstance() {
        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),
                new InvocationHandler() {
                    @Override
                    // 该方法负责集中处理动态代理类上的所有方法调用。第一个参数是代理类实例，第二个参数是被调用的方法对象,第三个参数是方法参数的数组形式
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        System.out.println("开始");
                        // 执行目标对象方法，方法参数是target，表示该方法从属于target
                        Object returnValue = method.invoke(target, args);
                        System.out.println("提交");
                        return returnValue;
                    }
                });
    }
}

public class Client {
    public static void main(String[] args) {
        // 目标对象
        IUserDao target = new UserDao();
        System.out.println(target.getClass());
        // 代理对象
        IUserDao proxy = (IUserDao) new ProxyFactory(target).getProxyInstance();
        System.out.println(proxy.getClass());
        proxy.save();
    }
}
```
输出：
```
class model.UserDao
class model.$Proxy0
开始
----已经保存数据!----
提交
```
