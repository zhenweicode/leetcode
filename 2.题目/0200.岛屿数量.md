https://leetcode.cn/problems/number-of-islands/description/?envType=study-plan-v2&envId=top-100-liked

# 岛屿数量（LeetCode 200）详细解法 - Java实现
## 题目描述
给定一个由 `'1'`（陆地）和 `'0'`（水）组成的二维网格，计算岛屿的数量。岛屿由相邻的陆地（水平或垂直相邻，斜向不相邻）连接形成，网格的四周都被水包围。

## 核心思路
岛屿问题的本质是 **连通分量计数**（统计无向图中互不连通的1的集合个数）。常用解法有两种：
1. **深度优先搜索（DFS）**：遇到陆地时，递归遍历其上下左右的所有相邻陆地，标记为已访问（避免重复计数），每完成一次完整遍历则岛屿数+1。
2. **广度优先搜索（BFS）**：遇到陆地时，用队列存储相邻陆地，迭代遍历并标记，同样每完成一次遍历计数+1。

两种方法时间复杂度均为 **O(m×n)**（m为网格行数，n为列数，每个格子仅访问一次），空间复杂度为 **O(m×n)**（最坏情况全是陆地，递归栈或队列占满网格）。

## 解法1：深度优先搜索（DFS）
### 实现步骤
1. 遍历网格的每个单元格；
2. 若当前单元格是 `'1'`，则启动DFS，同时岛屿数+1；
3. DFS过程：将当前单元格标记为 `'0'`（已访问），递归检查上下左右四个方向的相邻单元格，若为 `'1'` 则继续DFS。

### Java代码
```java
public class NumberOfIslands {
    // 网格行数和列数
    private int rows;
    private int cols;

    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }

        rows = grid.length;
        cols = grid[0].length;
        int count = 0;

        // 遍历每个单元格
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (grid[i][j] == '1') {
                    count++; // 发现新岛屿，计数+1
                    dfs(grid, i, j); // 标记该岛屿所有陆地
                }
            }
        }
        return count;
    }

    // DFS：标记当前陆地及相邻陆地为已访问（改为'0'）
    private void dfs(char[][] grid, int i, int j) {
        // 终止条件：越界或当前单元格不是陆地（'0'）
        if (i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] == '0') {
            return;
        }

        // 标记为已访问
        grid[i][j] = '0';

        // 递归遍历上下左右四个方向
        dfs(grid, i - 1, j); // 上
        dfs(grid, i + 1, j); // 下
        dfs(grid, i, j - 1); // 左
        dfs(grid, i, j + 1); // 右
    }
}
```

## 解法2：广度优先搜索（BFS）
### 实现步骤
1. 遍历网格的每个单元格；
2. 若当前单元格是 `'1'`，则岛屿数+1，同时将该单元格坐标加入队列；
3. 队列非空时，取出队首坐标，标记为 `'0'`，并将其上下左右未访问的陆地（`'1'`）加入队列；
4. 重复步骤3，直到队列为空（当前岛屿遍历完成）。

### Java代码
```java
import java.util.LinkedList;
import java.util.Queue;

public class NumberOfIslands {
    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }

        int rows = grid.length;
        int cols = grid[0].length;
        int count = 0;
        Queue<int[]> queue = new LinkedList<>();

        // 遍历每个单元格
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (grid[i][j] == '1') {
                    count++; // 新岛屿计数+1
                    queue.offer(new int[]{i, j}); // 加入队列
                    grid[i][j] = '0'; // 标记为已访问

                    // BFS遍历当前岛屿的所有陆地
                    while (!queue.isEmpty()) {
                        int[] curr = queue.poll();
                        int x = curr[0];
                        int y = curr[1];

                        // 检查上下左右四个方向
                        if (x - 1 >= 0 && grid[x - 1][y] == '1') { // 上
                            queue.offer(new int[]{x - 1, y});
                            grid[x - 1][y] = '0'; // 提前标记，避免重复入队
                        }
                        if (x + 1 < rows && grid[x + 1][y] == '1') { // 下
                            queue.offer(new int[]{x + 1, y});
                            grid[x + 1][y] = '0';
                        }
                        if (y - 1 >= 0 && grid[x][y - 1] == '1') { // 左
                            queue.offer(new int[]{x, y - 1});
                            grid[x][y - 1] = '0';
                        }
                        if (y + 1 < cols && grid[x][y + 1] == '1') { // 右
                            queue.offer(new int[]{x, y + 1});
                            grid[x][y + 1] = '0';
                        }
                    }
                }
            }
        }
        return count;
    }
}
```