# 目录
* [题目地址](#题目地址)
* [题目描述](#题目描述)
* [解题思路](#解题思路)
* [解法1-动态规划](#解法1-动态规划)
* [解法2-动态规划](#解法2-动态规划)
* [扩展题目](#扩展题目)



# 题目地址
难易程度：
- ![medium.jpg](../.images/medium.jpg)

是否经典：
- ⭐️

https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/

# 题目描述
```$xslt
设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。

你的 KthLargest 类需要一个同时接收整数 k 和整数数组nums 的构造器，它包含数据流中的初始元素。每次调用 KthLargest.add，返回当前数据流中第K大的元素。

示例:

int k = 3;
int[] arr = [4,5,8,2];
KthLargest kthLargest = new KthLargest(3, arr);
kthLargest.add(3);   // returns 4
kthLargest.add(5);   // returns 5
kthLargest.add(10);  // returns 5
kthLargest.add(9);   // returns 8
kthLargest.add(4);   // returns 8
说明:
你可以假设 nums 的长度≥ k-1 且k ≥ 1。
```


# 解题思路
- 小顶堆



# 解法1-小顶堆
## 关键点
建一个大小为k的堆即可


## 代码
```Java
class KthLargest {
    private int[] k_nums = null;
    private int k = 1;

    // 不管怎么样，初始化一个大小为k的数组，然后堆排序；然后不断插入元素维护小顶堆
    public KthLargest(int k, int[] nums) {
        this.k_nums = new int[k];
        this.k = k;
        if (nums.length <= k) {
            for (int i = 0; i < nums.length; i++) {
                k_nums[i] = nums[i];
            }

            // 这里必须初始化，否则输入负值，会因为小于默认值0，而始终返回0
            for (int i = nums.length; i < k; i++) {
                k_nums[i] = - Integer.MAX_VALUE;
            }

            buildHeap(k_nums, k);
        } else {
            for (int i = 0; i < k; i++) {
                k_nums[i] = nums[i];
            }

            buildHeap(k_nums, k);
            for (int i = k; i < nums.length; i++) {
                if (nums[i] > k_nums[0]) {
                    k_nums[0] = nums[i];
                    adjustHeap(k_nums, 0, k - 1);
                }
            }
        }
    }

    private void buildHeap(int[] a, int k) {
        for (int i = k / 2 - 1; i >= 0; i--) {
            adjustHeap(k_nums, i, k - 1);
        }
    }

    private void adjustHeap(int[] a, int k, int lastIndex) {
        int temp = a[k];
        for (int i = 2 * k + 1; i <= lastIndex; i = 2 * i + 1) {
            if (i < lastIndex && a[i] > a[i + 1]) {
                i++;
            }

            if (temp > a[i]) {
                a[k] = a[i];
                k = i;
            } else {
                break;
            }

            a[k] = temp;
        }
    }

    public int add(int val) {
        if (val > k_nums[0]) {
            k_nums[0] = val;
            adjustHeap(k_nums, 0, k - 1);
        }

        return k_nums[0];
    }
}
```


## 复杂度
- 时间复杂度：O(Nlog(k))
- 空间复杂度：O(k)
