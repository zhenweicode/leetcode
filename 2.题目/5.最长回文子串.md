# 目录
* [题目地址](#题目地址)
* [题目描述](#题目描述)
* [解题思路](#解题思路)
* [解法1-动态规划](#解法1-动态规划)
* [解法2-动态规划](#解法2-动态规划)
* [扩展题目](#扩展题目)



# 题目地址
难易程度：
- ![medium.jpg](../.images/medium.jpg)

是否经典：
- ⭐️

https://leetcode-cn.com/problems/longest-palindromic-substring/

# 题目描述
```text
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
示例 2：

输入: "cbbd"
输出: "bb"
```


# 解题思路
- 动态规划


# 解法1-动态规划
## 关键点
回文是一个正读和反读都相同的字符串，例如，“aba” 是回文，而 “abc” 不是。

考虑 “ababa” 这个示例。如果我们已经知道 “bab” 是回文，那么很明显，“ababa” 一定是回文，因为它的左首字母和右尾字母是相同的。

我们给出 P(i,j) 的定义如下：
$$P(i,j) = \begin{cases} \text{true,} &\quad\text{如果子串} S_i \dots S_j \text{是回文子串}\\ \text{false,} &\quad\text{其它情况} \end{cases}$$ 

因此，
$$P(i, j) = ( P(i+1, j-1) \text{ and } S_i == S_j )$$

基本示例如下：
- P(i,i)=true
- $P(i, i+1) = ( S_i == S_{i+1} )$

这产生了一个直观的动态规划解法，我们首先初始化一字母和二字母的回文，然后找到所有三字母回文，并依此类推…

求 长度为 1 和长度为 2 的 P(i,j) 时不能用上边的公式，因为我们代入公式后会遇到 P[i][j] 中 i > j 的情况，比如求P[1][2] 的话，我们需要知道 P[1+1][2-1]=P[2][1] ，而 P[2][1] 代表着 S[2,1] 是不是回文串，显然是不对的，所以我们需要单独判断。

所以我们先初始化长度是 1 的回文串的P[i,j]，这样利用上边提出的公式，两边向外各扩充一个字符，长度为 3 的，为 5 的，所有奇数长度的就都求出来了。

同理，初始化长度是 2 的回文串 P[i,i+1]，利用公式，长度为 4 的，6 的所有偶数长度的就都求出来了。

## 代码
```Java

```


## 复杂度
- 时间复杂度：$O(n^2)$。
- 空间复杂度：$O(n^2)$。


# 解法2-动态规划
## 关键点



## 代码



## 复杂度
- 时间复杂度：
- 空间复杂度：


# 扩展题目




图片压缩大小：
<img src="../.images/leetcode.jpeg" width="500" height="300">