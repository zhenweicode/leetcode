# 目录
* [题目地址](#题目地址)
* [题目描述](#题目描述)
* [解题思路](#解题思路)
* [解法1-动态规划](#解法1-动态规划)
* [解法2-动态规划](#解法2-动态规划)
* [扩展题目](#扩展题目)



# 题目地址
难易程度：
- ![medium.jpg](../.images/medium.jpg)

是否经典：
- ⭐️

https://leetcode-cn.com/problems/single-number/

# 题目描述
```$xslt
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,1]
输出: 1
示例 2:

输入: [4,1,2,1,2]
输出: 4
```

# 解题思路
- hash表
- 位运算


# 解法1-hash表
## 关键点



## 代码
```Java
class Solution {
    public int singleNumber(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        for (Integer i : nums) {
            Integer count = map.get(i);
            count = count == null ? 1 : ++count;
            map.put(i, count);
        }
        for (Integer i : map.keySet()) {
            Integer count = map.get(i);
            if (count == 1) {
                return i;
            }
        }
        return -1; // can't find it.
    }
}
```


## 复杂度
- 时间复杂度：O(n)
- 空间复杂度：O(n)


# 解法2-异或
## 关键点
如果我们对 0 和二进制位做 XOR 运算，得到的仍然是这个二进制位

$a \oplus 0 = a$

如果我们对相同的二进制位做 XOR 运算，返回的结果是 0

$a \oplus a = 0$

XOR 满足交换律和结合律

$a \oplus b \oplus a = (a \oplus a) \oplus b = 0 \oplus b = b$

所以我们只需要将所有的数进行 XOR 操作，得到那个唯一的数字。

## 代码
```Java
class Solution {
    public int singleNumber(int[] nums) {
        int ans = nums[0];
        if (nums.length > 1) {
            for (int i = 1; i < nums.length; i++) {
                ans = ans ^ nums[i];
            }
        }
        return ans;
    }
}
```


## 复杂度
- 时间复杂度：O(n) 。我们只需要将 nums 中的元素遍历一遍，所以时间复杂度就是 nums 中的元素个数。
- 空间复杂度：O(1) 。


# 扩展题目




图片压缩大小：
<img src="../.images/leetcode.jpeg" width="500" height="300">