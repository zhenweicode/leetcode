# 目录
* [题目地址](#题目地址)
* [题目描述](#题目描述)
* [解题思路](#解题思路)
* [解法1-动态规划](#解法1-动态规划)
* [解法2-动态规划](#解法2-动态规划)
* [扩展题目](#扩展题目)



# 题目地址
难易程度：
- ![hard.jpg](../.images/hard.jpg)

是否经典：
- ⭐️

https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/

# 题目描述
```$xslt
请实现两个函数，分别用来序列化和反序列化二叉树。

示例: 

你可以将以下二叉树：

    1
   / \
  2   3
     / \
    4   5

序列化为 "[1,2,3,null,null,4,5]"
```


# 解题思路
- 先序遍历
- 层序遍历



# 解法1-先序遍历
## 关键点
我们从根节点 1 开始，序列化字符串是 1,。然后我们跳到根节点 2 的左子树，序列化字符串变成 1,2,。现在从节点 2 开始，我们访问它的左节点 3（1,2,3，none，none，）和右节点 4。
(1,2,3,None,None,4,None,None)。None,None, 是用来标记缺少左、右子节点，这就是我们在序列化期间保存树结构的方式。最后，我们回到根节点 1 并访问它的右子树，它恰好是叶节点 5。最后，序列化字符串是按 1,2,3,None,None,4,None,None,5,None,None,.


## 代码
```Java
public class Codec {
    public String serialize(TreeNode root) {
        if (root == null) {
            return "null,";
        }

        String str = root.val + ",";
        str += serialize(root.left);
        str += serialize(root.right);
        return str;
    }

    public TreeNode deserialize(String data) {
        String[] values = data.split(",");
        Queue<String> queue = new LinkedList<String>();
        for (int i = 0; i != values.length; i++) {
            queue.offer(values[i]);
        }
        return rdeserialize(queue);
    }

    public TreeNode rdeserialize(Queue<String> queue) {
        String value = queue.poll();
        if (value.equals("null")) {
            return null;
        }
        TreeNode head = new TreeNode(Integer.valueOf(value));
        head.left = rdeserialize(queue);
        head.right = rdeserialize(queue);
        return head;
    }
}
```

## 复杂度
- 时间复杂度：在序列化和反序列化函数中，我们只访问每个节点一次，因此时间复杂度为 O(n)，其中 n 是节点数，即树的大小。
- 空间复杂度：在序列化和反序列化函数中，我们将整棵树保留在开头或结尾，因此，空间复杂性为 O(n)。


# 解法2-层序遍历
## 关键点
常规队列实现


## 代码
```Java
public class Codec {
    public String serialize(TreeNode root) {
        if (root == null) {
            return "null,";
        }
        String res = root.val + ",";
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            root = queue.poll();
            if (root.left != null) {
                res += root.left.val + ",";
                queue.offer(root.left);
            } else {
                res += "null,";
            }
            if (root.right != null) {
                res += root.right.val + ",";
                queue.offer(root.right);
            } else {
                res += "null,";
            }
        }
        return res;
    }

    public TreeNode deserialize(String data) {
        String[] values = data.split(",");
        int index = 0;
        TreeNode head = generateNodeByString(values[index++]);
        Queue<TreeNode> queue = new LinkedList<>();
        if (head != null) {
            queue.offer(head);
        }
        TreeNode node = null;
        while (!queue.isEmpty()) {
            node = queue.poll();
            node.left = generateNodeByString(values[index++]);
            node.right = generateNodeByString(values[index++]);
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
        return head;
    }

    private static TreeNode generateNodeByString(String val) {
        if (val.equals("null")) {
            return null;
        }
        return new TreeNode(Integer.valueOf(val));
    }
}
```


## 复杂度
- 时间复杂度：O(n)
- 空间复杂度：O(n)

