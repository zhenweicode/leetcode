# 目录
* [题目地址](#题目地址)
* [题目描述](#题目描述)
* [解题思路](#解题思路)
* [解法1-动态规划](#解法1-动态规划)
* [解法2-利用栈](#解法2-利用栈)
* [解法3-不需要额外的空间](#解法3-不需要额外的空间)
* [扩展题目](#扩展题目)


# 题目地址
- 难易程度：![hard.jpg](../.images/hard.jpg)
- 是否经典：⭐️

https://leetcode-cn.com/problems/median-of-two-sorted-arrays/

# 题目描述
```
给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。

示例 1:

nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
示例 2:

nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5
```


# 解题思路
- 合并两个有序数组，找第k大，但是复杂度O(m+n)
- 二分


# 解法1-合并两个有序数组
详见


# 解法2-哈希表和线性空间的构造
## 关键点
利用hashset求解。思路：
这些数字用一个 HashSet 保存，实现 O(1) 时间的查询，同时，我们只对`当前数字 - 1`不在哈希表里的数字，作为连续序列的第一个数字去找对应的最长序列，这是因为其他数字一定已经出现在了某个序列里。


## 代码
```Java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> numSet = new HashSet<Integer>();
        for (int num : nums) {
            numSet.add(num);
        }

        int max = 0;
        for (int num : numSet) {
            if (!numSet.contains(num - 1)) {
                int current = 1;
                while (numSet.contains(num + 1)) {
                    num += 1;
                    current += 1;
                }

                max = Math.max(max, current);
            }
        }

        return max;
    }
}
```


## 复杂度
- 时间复杂度：O(n)。尽管在 for 循环中嵌套了一个 while 循环，时间复杂度看起来像是二次方级别的。但其实它是线性的算法。**因为只有当 num 遇到了一个序列的开始， while 循环才会被执行（也就是 num-1 不在数组 nums 里），即当while执行遍历，并且遍历到最长序列的最大值，中间的其他值都不会再执行while，while 循环在整个运行过程中只会被迭代 n 次**。这意味着尽管看起来时间复杂度为 $O(n \cdot n)$ ，实际这个嵌套循环只会运行 O(n + n) = O(n)次。所有的计算都是线性时间的，所以总的时间复杂度是 O(n)的。
- 空间复杂度：O(n)。我们对哈希表分配线性空间，以保存 nums 数组中的 O(n) 个数字。除此以外，所需空间与暴力解法一致。

