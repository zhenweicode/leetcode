# 目录
* [题目地址](#题目地址)
* [题目描述](#题目描述)
* [解题思路](#解题思路)
* [解法1-hash表](#解法1-hash表)
* [解法2-异或](#解法2-异或)
* [扩展题目](#扩展题目)



# 题目地址
难易程度：
- ![medium.jpg](../.images/medium.jpg)

是否经典：
- ⭐️

https://leetcode-cn.com/problems/single-number/

# 题目描述
```$xslt
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,1]
输出: 1
示例 2:

输入: [4,1,2,1,2]
输出: 4
```

# 解题思路
- hash表
- 位运算


# 解法1-hash表
## 关键点



## 代码
```Java
class Solution {
    public int singleNumber(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        for (Integer i : nums) {
            Integer count = map.get(i);
            count = count == null ? 1 : ++count;
            map.put(i, count);
        }
        for (Integer i : map.keySet()) {
            Integer count = map.get(i);
            if (count == 1) {
                return i;
            }
        }
        return -1; // can't find it.
    }
}
```


## 复杂度
- 时间复杂度：O(n)
- 空间复杂度：O(n)


# 解法2-异或
## 关键点
异或运算的关键特性
1. **相同数字异或为0**：`a ^ a = 0`（偶数次出现的数字异或后会抵消为0）；
2. **0异或任何数字为该数字**：`0 ^ a = a`；
3. **异或运算满足交换律和结合律**：`a ^ b ^ c = a ^ (b ^ c) = c ^ a ^ b`。

## 代码
```Java
class Solution {
    public int singleNumber(int[] nums) {
        int ans = nums[0];
        if (nums.length > 1) {
            for (int i = 1; i < nums.length; i++) {
                ans = ans ^ nums[i];
            }
        }
        return ans;
    }
}
```


## 复杂度
- 时间复杂度：O(n) 。我们只需要将 nums 中的元素遍历一遍，所以时间复杂度就是 nums 中的元素个数。
- 空间复杂度：O(1) 。


# 扩展题目
## 有两个数出现奇数次，其他的数都出现偶数次，打印这两个数
核心步骤
1. **获取两个目标数的异或结果**：遍历数组，将所有元素异或，最终结果 `xorSum = x ^ y`（x和y是出现奇数次的两个数，其余数抵消为0）；
2. **找到xorSum的最低位1**：`xorSum` 不为0（因为x≠y），其二进制中至少有一位是1。找到最低位的1（记为 `lowBit`），该位表示x和y在该位上的二进制值不同（一个为0，一个为1）；
3. **按lowBit分组异或**：将数组元素按“该位是否为1”分成两组，x和y会被分到不同组。每组内异或所有元素，最终两组的结果分别为x和y（每组内其他元素均出现偶数次，抵消为0）。

```java
import java.util.Arrays;

public class FindTwoOddOccurrence {
    public int[] findTwoNumbers(int[] nums) {
        // 步骤1：计算所有元素的异或和，结果为 x ^ y（x和y是目标数）
        int xorSum = 0;
        for (int num : nums) {
            xorSum ^= num;
        }

        // 步骤2：找到xorSum的最低位1（x和y在该位上不同）
        // 利用补码特性：xorSum & (-xorSum) 仅保留最低位1
        int lowBit = xorSum & (-xorSum);

        // 步骤3：按lowBit分组异或，得到x和y
        int x = 0, y = 0;
        for (int num : nums) {
            if ((num & lowBit) == 0) {
                // 该组包含x，异或后得到x（其他元素出现偶数次，抵消为0）
                x ^= num;
            } else {
                // 该组包含y，异或后得到y
                y ^= num;
            }
        }

        // 返回结果（顺序无要求）
        return new int[]{x, y};
    }
}
```
要理解 **`xorSum & (-xorSum)` 仅保留最低位1**，核心是搞懂 **计算机中负数的补码表示** + **按位与（&）运算的规则**，下面用「通俗语言+实例+二进制推导」一步步拆解：
计算机不直接存储负数的“-”号，而是用 **补码** 表示负数，补码的计算规则是：  
**负数的补码 = 其绝对值的二进制（原码）按位取反（反码） + 1**。

根据补码规则，`-xorSum` 的补码 = `xorSum的反码 + 1`：
1. 先对 `xorSum` 按位取反（反码）：
    - 原 `xorSum` ：`...a 1 0...0`（第k位是1，右边全0）；
    - 反码结果：`...(~a) 0 1...1`（第k位变0，右边全变1，左边按位取反）。
2. 反码 + 1（得到补码）：
    - 右边全1 + 1 会产生 **进位**，一直进位到第k位；
    - 第k位的0 + 1 变为1，右边的所有1因进位变为0；
    - 第k位左边的位（...~a）不受进位影响（因为进位到第k位就停止了）。

最终 `-xorSum` 的补码结构：`...(~a) 1 0...0`  
（仅第k位是1，其余位与 `xorSum` 完全相反，右边全0）


## 在其他数都出现k次的数组中找到只出现一次的数
```$xslt
给定一个整型数组arr和一个大于1的整数k。已知arr中只有1个数出现了1次，其他的数都出现了k次，请返回只出现了1次的数。
```

以下的例子是两个七进制数的无进位相加，即忽略进位的相加，比如： 
- 七进制数a：6432601 
- 七进制数b：3450111
- 无进位相加结果：2112012

可以看出，两个七进制的数a和b，在i位上无进位相加的结果就是（a（i） +b（i））%7。那么，如果k个相同的k进制数进行无进位相加，相加的结果一定是每一位上都是0的k进制数。

理解了上述过程之后，解这道题就变得简单了，首先设置一个变量eO，它是一个32 位的k进制数，且每个位置上都是0。然后遍历arr，把遍历到的每一个整数都转换为 k进制数，然后与eO进行无进位相加。遍历结束时，把32位的k进制数eORes转换为 十进制整数，就是我们想要的结果。因为k个相同的k进制数无进位相加，结果一定 是每一位上都是0的k进制数，所以只出现一次的那个数最终就会剩下来。

```Java
class Solution {
    public int singleNumber(int[] nums) {
        return onceNum(nums, 3);
    }

    public static int onceNum(int[] arr, int k) {
        int[] eO = new int[32];
        for (int i = 0; i < arr.length; i++) {
            setExclusiveOr(eO, arr[i], k);
        }
        
        return getNumFromKSysNum(eO, k);
    }

    public static void setExclusiveOr(int[] eO, int value, int k) {
        int[] curKSysNum = getKSysNumFromNum(value, k);
        for (int i = 0; i < eO.length; i++) {
            eO[i] = (eO[i] + curKSysNum[i]) % k;
        }
    }

    // 10进制转k进制
    public static int[] getKSysNumFromNum(int value, int k) {
        int[] res = new int[32];
        int index = 0;
        while (value != 0) {
            res[index++] = value % k;
            value = value / k;
        }
        return res;
    }

    // 10进制转k进制 
    public static int getNumFromKSysNum(int[] eO, int k) {
        int res = 0;
        for (int i = eO.length - 1; i >= 0; i--) {
            res = res * k + eO[i];
        }
        return res;
    }
}
```

注意：
k进制转10进制，比如7进制632转10进制：(6 x 7 + 3) x 7 + 2 = 317

10进制转k进制，
- 317%7=2,317/7=45
- 45%7=3,45/7=6

得到632

- 时间复杂度：O(n) 。
- 空间复杂度：O(1) 。