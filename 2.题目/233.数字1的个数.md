# 目录
* [题目地址](#题目地址)
* [题目描述](#题目描述)
* [解题思路](#解题思路)
* [解法1-暴力](#解法1-暴力)
* [解法2-找规律](#解法2-找规律)



# 题目地址
难易程度：
- ![hard.jpg](../.images/hard.jpg)

是否经典：
- ⭐️

https://leetcode-cn.com/problems/number-of-digit-one/

# 题目描述
```$xslt
给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。

示例:

输入: 13
输出: 6 
解释: 数字 1 出现在以下数字中: 1, 10, 11, 12, 13 。
```


# 解题思路
- 暴力
- 找规律


# 解法1-暴力
## 关键点
一个数一个数的判断，一位一位的判断。
但这个解法会超时。


## 代码
```Java
class Solution {
    public int countDigitOne(int n) {
        int num = 0;
        for (int i = 1; i <= n; i++) {
            int temp = i;
            while (temp > 0) {
                if (temp % 10 == 1) {
                    num++;
                }
                temp /= 10;
            }
        }
        return num;
    }
}
```


## 复杂度
- 时间复杂度：$O(n*log_{10}(n))$
- 空间复杂度：O(1)


# 解法2-找规律
## 关键点
总体思想就是分类，先求所有数中个位是 1 的个数，再求十位是 1 的个数，再求百位是 1 的个数...

假设 n = xyzdabc，此时我们求千位是 1 的个数，也就是 d 所在的位置。当我们考虑千位是 1 的时候，我们将千位定为 1，也就是 xyz1abc。

对于 xyz 的话，可以取 0,1,2...(xyz-1)，也就是 xyz 种可能。当 xyz 固定为上边其中的一个数的时候，abc 可以取 0,1,2...999，也就是 1000 种可能。这样的话，总共就是 xyz*1000 种可能。

注意到，我们前三位只取到了 xyz-1，那么如果取 xyz 呢？此时千分位最大可以取到的数是d，所以要对d讨论：
- d == 0：千位上 1 的个数就是 xyz * 1000
- d == 1：千位刚好是 1，此时 abc 可以取的值就是 0 到 abc ，所以多加了 abc + 1，即千位上 1 的个数就是 xyz * 1000 + abc + 1
- d > 1：d 如果取 1，那么 abc 就可以取 0 到 999，此时就多加了 1000

再看一个具体的例子。
```$xslt
如果n = 4560234
让我们统计一下千位有多少个 1
xyz 可以取 0 到 455, abc 可以取 0 到 999
4551000 to 4551999 (1000)
4541000 to 4541999 (1000)
4531000 to 4531999 (1000)
...
  21000 to   21999 (1000)
  11000 to   11999 (1000)    
   1000 to    1999 (1000)
总共就是 456 * 1000

如果 n = 4561234
xyz 可以取 0 到 455, abc 可以取 0 到 999
4551000 to 4551999 (1000)
4541000 to 4541999 (1000)
4531000 to 4531999 (1000)
...
1000 to 1999 (1000)
xyz 还可以取 456, abc 可以取 0 到 234
4561000 to 4561234 (234 + 1)
总共就是 456 * 1000 + 234 + 1

如果 n = 4563234
xyz 可以取 0 到 455, abc 可以取 0 到 999    
4551000 to 4551999 (1000)
4541000 to 4541999 (1000)
4531000 to 4531999 (1000)
...
1000 to 1999 (1000)
xyz 还可以取 456, abc 可以取 0 到 999
4561000 to 4561999 (1000)
总共就是 456 * 1000 + 1000
```

至于其它位的话是一样的道理。

## 代码
```Java
class Solution {
    public int countDigitOne(int n) {
        int count = 0;
        //依次考虑个位、十位、百位...是 1
        for (long k = 1; k <= n; k *= 10) {  // 如果不用long，k可能为n*10，溢出int，导致无限循环
            long abc = n % k;
            long xyzd = n / k;
            long d = xyzd % 10;
            long xyz = xyzd / 10;
            count += xyz * k;
            if (d > 1) {
                count += k;
            }
            if (d == 1) {
                count += abc + 1;
            }
        }
        return count;
    }
}
```


## 复杂度
- 时间复杂度：$O(log_{10}(n))$，遍历的次数等于 n 转成字符串后字符串的长度。
- 空间复杂度：只需要 O(1)的额外空间。