# 目录
* [题目地址](#题目地址)
* [题目描述](#题目描述)
* [解题思路](#解题思路)
* [解法1-动态规划](#解法1-动态规划)
* [解法2-动态规划](#解法2-动态规划)
* [扩展题目](#扩展题目)



# 题目地址
难易程度：
- ![medium.jpg](../.images/medium.jpg)

是否经典：
- ⭐️

https://leetcode-cn.com/problems/meeting-rooms/

# 题目描述
```text
给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 [[s1,e1],[s2,e2],...] (si < ei)，请你判断一个人是否能够参加这里面的全部会议。

示例 1:

输入: [[0,30],[5,10],[15,20]]
输出: false
示例 2:

输入: [[7,10],[2,4]]
输出: true
```


# 解题思路
- 暴力法
- 排序

# 解法1-暴力法
## 关键点
最简单的方法是将数组中的会议全部两两比较，判断它们是否有冲突（即它们的时间是否有交叠）。若一个会议开始时另一个会议依然没有结束，则它们存在交叠。


## 代码
```Java
class Solution {
    public boolean canAttendMeetings(int[][] intervals) {
        for (int i = 0; i < intervals.length; i++) {
            for (int j = i + 1; j < intervals.length; j++) {
                if (overlap(intervals[i], intervals[j]))
                    return false;
            }
        }
        return true;
    }

    public static boolean overlap(int[] i1, int[] i2) {
        return ((i1[0] >= i2[0] && i1[0] < i2[1]) || (i2[0] >= i1[0] && i2[0] < i1[1]));
    }
}
```


## 复杂度
- 时间复杂度：$O(n^2)$
- 空间复杂度：O(1)。


# 解法2-排序
## 关键点
思路是按照开始时间对会议进行排序。接着依次遍历会议，检查它是否在下个会议开始前结束。

## 代码
```Java
class Solution {
    public boolean canAttendMeetings(int[][] intervals) {
        Arrays.sort(intervals, new Comparator<int[]>() {
            public int compare(int[] i1, int[] i2) {
                return i1[0] - i2[0];
            }
        });

        for (int i = 0; i < intervals.length - 1; i++) {
            if (intervals[i][1] > intervals[i + 1][0])
                return false;
        }
        return true;
    }
}
```


## 复杂度
时间复杂度 : $O(nlogn)$ 。时间复杂度由排序决定。一旦排序完成，只需要 O(n) 的时间来判断交叠。
空间复杂度 : O(1)。没有使用额外空间。


# 扩展题目




图片压缩大小：
<img src="../.images/leetcode.jpeg" width="500" height="300">