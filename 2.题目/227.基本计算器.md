# 目录
* [题目地址](#题目地址)
* [题目描述](#题目描述)
* [解题思路](#解题思路)
* [解法1-栈和运算符反转](#解法1-栈和运算符反转)
* [扩展题目](#扩展题目)



# 题目地址
难易程度：
- ![medium.jpg](../.images/medium.jpg)

是否经典：
- ⭐️

https://leetcode-cn.com/problems/basic-calculator/

# 题目描述
```text
实现一个基本的计算器来计算一个简单的字符串表达式的值。

字符串表达式可以包含左括号 ( ，右括号 )，加号 + ，减号 -，非负整数和空格  。

示例 1:

输入: "1 + 1"
输出: 2
示例 2:

输入: " 2-1 + 2 "
输出: 3
示例 3:

输入: "(1+(4+5+2)-3)+(6+8)"
输出: 23
说明：

你可以假设所给定的表达式都是有效的。
请不要使用内置的库函数 eval。
```


# 解题思路
- 栈和运算符反转


# 解法1-栈和运算符反转
## 关键点
这题只要解决了括号的问题就很简单了。再加上本题有个限定条件是只有加和减两种操作，所以在处理括号时只需要考虑括号前的符号：

- 如果(前是-，那么反转括号内的所有运算符（+变成-，-变成+）
- 如果(前是+，则不需要反转括号内的运算符
- 遇到)时，恢复成上一层级的反转规则
- 用一个栈来保存当前的运算符反转规则，true代表反转，false代表不反转，栈为空时也不反转

以1-(2-(3+4)-5)+6为例说明：

- 第一个(前的运算符是-，将反转规则true入栈，栈内容[true]，已处理的算式为1-2
- 下一个运算符是-，而当前栈顶元素为true，故将其反转，此时已处理的算式为1-2+
- 第二个(前的运算符是+（刚刚反转的），故将反转规则false入栈，栈内容[false,true]，已处理的算式为1-2+3
- 下一个运算符是+，当前栈顶元素为false，不需要反转，已处理的算式为1-2+3+4
- 遇到)，将栈顶元素弹出，栈内容[true]，下一个运算符为-，根据当前栈顶元素，需要进行反转，已处理的算式为1-2+3+4+5
- 再次遇到)，将栈顶元素弹出，此时栈为空
- 下一个运算符是+，此时栈为空，不需要反转，最终处理完成的算式为1-2+3+4+5+6
- 现在算式中已经没有括号，直接进行运算即可得出最终结果17

运算符的处理和运算可以在一趟迭代中完成，故算法时间复杂度为O(N)。需要一个栈来保存括号前的运算符，实际使用的辅助空间取决于算式内括号的层数，极限的辅助空间为O(N)

## 代码
```Java
class Solution {
    public int calculate(String s) {
        if(s == null || s.length() == 0){
            return 0;
        }
        
        LinkedList<Boolean> stack = new LinkedList<>();
        int result = 0, opr = 0; //result: 当前的结果值; opr: 当前的被加/被减数
        Character op = null; //当前要执行的运算符
        
        for (char c : s.toCharArray()) {
            if (c == '+' || c == '-') {  // 遇到操作符，说明前面连续的数字统计完成，比如123，需要123 >> 120 + 3 >> 100 + 20 + 3，计算即可
                if (op == null) {
                    result = opr;  //遇到第一个运算符时，将result置为opr（即第一个运算符左边的数字）
                } else {
                    //result = result +/- opr;
                    result = cal(op, result, opr);
                }
                //根据栈顶元素决定是否反转运算符
                op = swap(stack.peek() == null ? false : stack.peek(), c);
                opr = 0;
            } else if (c == '(') {
                stack.push(op != null && op == '-');
            } else if (c == ')') {
                stack.pop();
            } else if (c != ' ') {
                opr = opr * 10 + c - '0';
            }
        }
        
        if (op == null) {
            //算式中没有运算符时，opr就是最终结果
            return opr;
        } else {
            //否则将result与opr（即算式中最右边的数字）执行一次运算
            return cal(op, result, opr);
        }
    }

    private char swap(boolean swap, char c) {
        if (swap) {
            return c == '+' ? '-' : '+';
        } else {
            return c;
        }
    }

    private int cal(char op, int opr1, int opr2) {
        switch (op) {
            case '+':
                return opr1 + opr2;
            case '-':
                return opr1 - opr2;
            default:
                return 0;
        }
    }
}
```


## 复杂度
- 时间复杂度：O(N)
- 空间复杂度：O(N)


# 解法2-动态规划
## 关键点



## 代码



## 复杂度
- 时间复杂度：
- 空间复杂度：


# 扩展题目
## 150. 逆波兰表达式求值
https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/

```text
有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

说明：

整数除法只保留整数部分。
给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。
示例 1：

输入: ["2", "1", "+", "3", "*"]
输出: 9
解释: ((2 + 1) * 3) = 9
示例 2：

输入: ["4", "13", "5", "/", "+"]
输出: 6
解释: (4 + (13 / 5)) = 6
示例 3：

输入: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]
输出: 22
解释: 
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```

- 解法一：数组
```Java
class Solution {
    //纯数组模拟栈实现(推荐)   3 ms	36 MB
    public static int evalRPN(String[] tokens) {
        int[] numStack = new int[tokens.length / 2 + 1];
        int index = 0;
        for (String s : tokens) {
            switch (s) {
                case "+":
                    numStack[index - 2] += numStack[--index];
                    break;
                case "-":
                    numStack[index - 2] -= numStack[--index];
                    break;
                case "*":
                    numStack[index - 2] *= numStack[--index];
                    break;
                case "/":
                    numStack[index - 2] /= numStack[--index];
                    break;
                default:
                    // numStack[index++] = Integer.valueOf(s); valueOf改为parseInt，减少自动拆箱装箱操作
                    numStack[index++] = Integer.parseInt(s);
                    break;
            }
        }
        return numStack[0];
    }
}
```

- 解法二：栈实现
```Java
class Solution {
    // 栈实现   8 ms	36.7 MB	
    public static int evalRPN(String[] tokens) {
        Stack<Integer> numStack = new Stack<>();
        Integer op1, op2;
        for (String s : tokens) {
            switch (s) {
                case "+":
                    op2 = numStack.pop();
                    op1 = numStack.pop();
                    numStack.push(op1 + op2);
                    break;
                case "-":
                    op2 = numStack.pop();
                    op1 = numStack.pop();
                    numStack.push(op1 - op2);
                    break;
                case "*":
                    op2 = numStack.pop();
                    op1 = numStack.pop();
                    numStack.push(op1 * op2);
                    break;
                case "/":
                    op2 = numStack.pop();
                    op1 = numStack.pop();
                    numStack.push(op1 / op2);
                    break;
                default:
                    numStack.push(Integer.valueOf(s));
                    break;
            }
        }
        return numStack.pop();
    }
}
```