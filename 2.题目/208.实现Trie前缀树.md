# 目录
* [题目地址](#题目地址)
* [题目描述](#题目描述)


# 题目地址
难易程度：
- ![medium.jpg](../.images/medium.jpg)

是否经典：
- ⭐️

https://leetcode-cn.com/problems/implement-trie-prefix-tree/

# 题目描述
```text
实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。

示例:

Trie trie = new Trie();

trie.insert("apple");
trie.search("apple");   // 返回 true
trie.search("app");     // 返回 false
trie.startsWith("app"); // 返回 true
trie.insert("app");   
trie.search("app");     // 返回 true
说明:

你可以假设所有的输入都是由小写字母 a-z 构成的。
保证所有输入均为非空字符串。
```


# 解法1
## 关键点
Trie 树是一个有根的树，其结点具有以下字段：。

最多 R 个指向子结点的链接，其中每个链接对应字母表数据集中的一个字母。

- 本文中假定 R 为 26，小写拉丁字母的数量。

- 布尔字段，以指定节点是对应键的结尾还是只是键前缀。


## 代码
```java
public class Trie {
    private boolean is_string = false;
    private Trie[] next = new Trie[26];

    public Trie() {
    }

    public void insert(String word) {//插入单词
        Trie root = this;
        char[] w = word.toCharArray();
        for (int i = 0; i < w.length; ++i) {
            if (root.next[w[i] - 'a'] == null) root.next[w[i] - 'a'] = new Trie();
            root = root.next[w[i] - 'a'];
        }
        root.is_string = true;
    }

    public boolean search(String word) {//查找单词
        Trie root = this;
        char w[] = word.toCharArray();
        for (int i = 0; i < w.length; ++i) {
            if (root.next[w[i] - 'a'] == null) return false;
            root = root.next[w[i] - 'a'];
        }
        return root.is_string;
    }

    public boolean startsWith(String prefix) {//查找前缀
        Trie root = this;
        char p[] = prefix.toCharArray();
        for (int i = 0; i < p.length; ++i) {
            if (root.next[p[i] - 'a'] == null) return false;
            root = root.next[p[i] - 'a'];
        }
        return true;
    }
}
```


## 复杂度
- 时间复杂度：O(m)
- 空间复杂度：插入最坏O(m)，其他基本O(1)