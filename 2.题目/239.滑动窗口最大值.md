# 目录
* [题目地址](#题目地址)
* [题目描述](#题目描述)
* [解题思路](#解题思路)
* [解法1-暴力](#解法1-暴力)
* [解法2-双向队列](#解法2-双向队列)



# 题目地址
难易程度：
- ![hard.jpg](../.images/hard.jpg)

是否经典：
- ⭐️

https://leetcode-cn.com/problems/sliding-window-maximum/

# 题目描述
```$xslt
给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

 

进阶：

你能在线性时间复杂度内解决此题吗？

 

示例:

输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
 

提示：

1 <= nums.length <= 10^5
-10^4 <= nums[i] <= 10^4
1 <= k <= nums.length
```


# 解题思路
- 暴力
- 双向队列


# 解法1-暴力
## 关键点
最简单直接的方法是遍历每个滑动窗口，找到每个窗口的最大值。一共有 N - k + 1 个滑动窗口，每个有 k 个元素，于是算法的时间复杂度为O(Nk)，表现较差。

## 代码
```Java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        if (n * k == 0) return new int[0];
        
        int [] output = new int[n - k + 1];
        for (int i = 0; i < n - k + 1; i++) {
            int max = Integer.MIN_VALUE;
            for(int j = i; j < i + k; j++) 
                max = Math.max(max, nums[j]);
            output[i] = max;
        }
        return output;
    }
}
```


## 复杂度
- 时间复杂度：O(Nk)。其中 N 为数组中元素个数。
- 空间复杂度：O(N−k+1)，用于输出数组。


# 解法2-双向队列
## 关键点
单调的双向队列，双向队列大家都知道，既能在头部进行插入、删除操作，也能在尾部进行插入删除操作，而所谓的单调，就是我们人为规定从队列的头部到尾部，所存储的元素是依次递减（变小）的。

窗口在每次滑动的时候，就从队列头部取当前窗口中的最大值，每次窗口新进来一个元素的时候，就将它与队列中的元素进行大小比较：
- 如果刚刚进来的元素比队列的尾部元素大，那么先将队列尾部的元素弹出（如果比倒数第二个大，重复弹出），然后把刚刚进来的元素添到队列的尾部；
- 如果刚刚进来的元素比队列的尾部元素小，那么把刚刚进来的元素直接添到队列的尾部即可。

添加元素：
```$xslt
在不规定窗口大小的前提下，我们先看看如何将新元素添加到单调的双向队列中。假如有5、4、1、2、6要进入单调的双向队列，首先让索引为0的元素5进入，由于之前队列是空的，所以5直接进去即可，如下所示：

头部                    尾部
 --------------------------
|  5                      |
|  ↑                     |
|  0                      |
 --------------------------
  大                  小
此时，索引1位置上的4要进队列，则需要比较队列尾部与4的大小关系。由于5是大于4的，并且4从尾部进去以后能够满足从头到尾、从大到小的规定，所以我们让4进去即可，如下所示：

头部                    尾部
 --------------------------
|  5    4                 |
|  ↑   ↑                |
|  0    1                 |
 --------------------------
  大                  小
然后，索引2位置上的元素1也想要进去，根据我们的规定，让它直接进入就好了，如下所示：

头部                    尾部
 --------------------------
|  5    4    1            |
|  ↑   ↑   ↑           |
|  0    1    2            |
 --------------------------
  大                  小
然后，索引3位置上的元素2想要进去，此时，由于尾部的元素1是小于元素2的，2进去以后不满足从大到小的规定，所以让1从尾部出来，直接丢掉它，然后再让元素2从尾部进入，如下所示：

头部                    尾部
 --------------------------
|  5    4    2            |
|  ↑   ↑   ↑           |
|  0    1    3            |
 --------------------------
  大                  小
  
好了，现在还剩下索引为4的元素6想要进入队列，我们发现6比队列中任何一个元素都要大，所以我们将队列中的所有元素都弹出，然后只让6进入，如下所示：

头部                    尾部
 --------------------------
|  6                      |
|  ↑                     |
|  4                      |
 --------------------------
  大                  小
此时，窗口中的最大值就是6了。要注意一点的是：如果此时又来了一个索引为5的元素6想要进入队列中，则我们需要将之前的索引为4的元素6进行弹出，让新来的6进入，此时就变成了如下所示：

头部                    尾部
 --------------------------
|  6                      |
|  ↑                     |
|  5                      |
 --------------------------
  大                  小
为什么在元素相等的情况下，也要更新元素呢？

这时因为窗口是每次向右进行滑动的，每次进入到窗口中的值都有可能是当前窗口中最大的值，我们将相同的值进行更换，其实是为了更新它的索引。这样在窗口进行滑动的时候，每次的最大值都是新的，就能保持最大。
```

删除元素：
```$xslt
不妨假设以下场景，窗口大小是 2，之前窗口中包含5和4，但是此时已经来到了4、1元素，队列中的情况也如下所示：

元素： 5  [4  1]  2
索引： 0   1  2   3

头部                    尾部
 --------------------------
|  5   4   1              |
|  ↑  ↑  ↑             |
|  0   1   2              |
 --------------------------
  大                  小
由于元素5已经被滑动窗口略过了，所以我们应将队列中的最大值，也就是5弹出，让4成为当前窗口新的最大值，如下所示：

头部                    尾部
 --------------------------
|     4   1               |
|     ↑  ↑              |
|     1   2               |
 --------------------------
  大                  小
```


## 代码
```Java
class Solution {
    ArrayDeque<Integer> deq = new ArrayDeque<>();
    int[] nums;

    private void clean_deque(int i, int k) {
        if (!deq.isEmpty() && deq.getFirst() == i - k)  // 如果第一个元素不在窗口内，删除
            deq.removeFirst();

        while (!deq.isEmpty() && nums[i] > nums[deq.getLast()]) deq.removeLast();  // 保证队列内元素降序

        deq.addLast(i);
    }

    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        if (n * k == 0) return new int[0];
        if (k == 1) return nums;

        this.nums = nums;
        int max_idx = 0;
        for (int i = 0; i < k; i++) {
            clean_deque(i, k);
            if (nums[i] > nums[max_idx]) max_idx = i;
        }

        int[] output = new int[n - k + 1];
        output[0] = nums[max_idx];
        
        for (int i = k; i < n; i++) {
            clean_deque(i, k);
            output[i - k + 1] = nums[deq.getFirst()];
        }
        return output;
    }
}
```


## 复杂度
- 时间复杂度：O(N)，每个元素被处理两次-其索引被添加到双向队列中和被双向队列删除。
- 空间复杂度：O(N)，输出数组使用了 O(N−k+1) 空间，双向队列使用了 O(k)。