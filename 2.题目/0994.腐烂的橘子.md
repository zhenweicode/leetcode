https://leetcode.cn/problems/rotting-oranges/description/?envType=study-plan-v2&envId=top-100-liked

# 腐烂的橘子（LeetCode 994）详细解法 - Java实现
## 题目描述
在给定的 `m x n` 网格中，每个单元格可以是以下三种状态之一：
- `0`：空单元格
- `1`：新鲜橘子
- `2`：腐烂橘子

每分钟，**所有与腐烂橘子相邻（水平或垂直相邻）的新鲜橘子都会腐烂**。请你计算直到单元格中没有新鲜橘子为止所需要的最少分钟数。如果存在无法腐烂的新鲜橘子，则返回 `-1`。

## 核心思路
这是一道典型的 **多源广度优先搜索（Multi-source BFS）** 问题，核心逻辑如下：
1. **多源起点**：所有腐烂橘子（状态`2`）同时作为BFS的起点，因为它们会在第1分钟同时扩散腐烂；
2. **层次遍历**：BFS的每一层对应一分钟，每遍历一层，就处理当前所有腐烂橘子能感染的新鲜橘子；
3. **状态追踪**：
    - 统计初始新鲜橘子总数（`freshCount`），用于后续判断是否有无法腐烂的橘子；
    - 记录BFS的层数（`minutes`），即所需时间；
4. **终止条件**：
    - BFS结束后，若`freshCount`为0，返回`minutes`；
    - 若`freshCount`>0，返回`-1`（存在无法腐烂的新鲜橘子）。

### 关键分析
- 时间复杂度：`O(m×n)`，每个单元格仅入队和出队一次；
- 空间复杂度：`O(m×n)`，最坏情况（全是腐烂橘子）下队列存储所有单元格。

## 详细实现步骤
1. **初始化**：
    - 遍历网格，统计初始新鲜橘子数（`freshCount`）；
    - 将所有腐烂橘子的坐标加入队列（BFS起点）；
2. **BFS遍历**：
    - 若队列为空且`freshCount`>0，直接返回`-1`（无腐烂橘子，新鲜橘子无法腐烂）；
    - 定义方向数组（上下左右），用于遍历相邻单元格；
    - 按层遍历队列：
        - 记录当前层的橘子数量（`levelSize`），确保每一层对应一分钟；
        - 取出队首腐烂橘子，检查其四个相邻单元格；
        - 若相邻单元格是新鲜橘子（状态`1`）：
            - 将其状态改为`2`（标记为腐烂）；
            - `freshCount`减1；
            - 将该单元格坐标加入队列，用于下一层扩散；
        - 每遍历完一层，若当前层有橘子被腐烂（即队列非空且不是初始状态），时间`minutes`加1；
3. **结果判断**：
    - BFS结束后，若`freshCount`为0，返回`minutes`；否则返回`-1`。

## Java代码实现
```java
import java.util.LinkedList;
import java.util.Queue;

public class RottingOranges {
    public int orangesRotting(int[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }

        int rows = grid.length;
        int cols = grid[0].length;
        Queue<int[]> queue = new LinkedList<>(); // 存储腐烂橘子的坐标（x,y）
        int freshCount = 0; // 新鲜橘子总数
        int minutes = 0; // 腐烂所需时间

        // 方向数组：上下左右四个方向
        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

        // 第一步：初始化队列和新鲜橘子计数
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (grid[i][j] == 2) {
                    queue.offer(new int[]{i, j}); // 腐烂橘子入队
                } else if (grid[i][j] == 1) {
                    freshCount++; // 统计新鲜橘子
                }
            }
        }

        // 边界情况：没有新鲜橘子，直接返回0
        if (freshCount == 0) {
            return 0;
        }

        // 第二步：多源BFS遍历
        while (!queue.isEmpty()) {
            int levelSize = queue.size(); // 当前层的腐烂橘子数量（对应当前分钟要处理的橘子）
            boolean hasRotten = false; // 标记当前层是否有新鲜橘子被腐烂

            // 处理当前层的所有腐烂橘子
            for (int i = 0; i < levelSize; i++) {
                int[] curr = queue.poll();
                int x = curr[0];
                int y = curr[1];

                // 遍历四个相邻方向
                for (int[] dir : dirs) {
                    int nx = x + dir[0];
                    int ny = y + dir[1];

                    // 检查相邻单元格是否合法且为新鲜橘子
                    if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && grid[nx][ny] == 1) {
                        grid[nx][ny] = 2; // 标记为腐烂
                        freshCount--; // 新鲜橘子数减1
                        queue.offer(new int[]{nx, ny}); // 加入队列，用于下一层扩散
                        hasRotten = true;
                    }
                }
            }

            // 只有当前层有橘子腐烂时，时间才加1（避免最后一层遍历完多算1分钟）
            if (hasRotten) {
                minutes++;
            }
        }

        // 第三步：判断结果
        return freshCount == 0 ? minutes : -1;
    }
}
```

## 关键注意事项
1. **方向数组的使用**：避免重复编写上下左右的坐标计算，简化代码；
2. **层序遍历的核心**：通过`levelSize`控制每一层的处理，确保每一层对应一分钟，避免时间统计错误；
3. **`hasRotten`标记**：防止最后一层遍历完（此时已无新鲜橘子可腐烂）仍加1分钟，例如：所有新鲜橘子在第2分钟被腐烂，第3分钟队列中仍有腐烂橘子，但无相邻新鲜橘子，此时不应加时；
4. **边界条件处理**：
    - 网格为空时返回0；
    - 无新鲜橘子时返回0；
    - 无腐烂橘子但有新鲜橘子时返回`-1`；
5. **状态修改时机**：新鲜橘子被腐烂后立即修改状态为`2`，避免被重复入队。

## 测试用例
### 测试用例1：正常情况（全腐烂）
```java
int[][] grid = {
    {2,1,1},
    {1,1,0},
    {0,1,1}
};
// 输出：4
// 解释：
// 第0分钟：(0,0)腐烂
// 第1分钟：(0,1)、(1,0)腐烂
// 第2分钟：(0,2)、(1,1)、(2,1)腐烂
// 第3分钟：(2,2)腐烂
// 总时间4分钟
```

### 测试用例2：存在无法腐烂的新鲜橘子
```java
int[][] grid = {
    {2,1,1},
    {0,1,1},
    {1,0,1}
};
// 输出：-1
// 解释：右下角(2,2)的新鲜橘子被空单元格包围，无法腐烂
```

### 测试用例3：无新鲜橘子
```java
int[][] grid = {
    {2,0,2},
    {0,0,0},
    {2,0,2}
};
// 输出：0
```

### 测试用例4：无腐烂橘子（全新鲜）
```java
int[][] grid = {
    {1,1,1},
    {1,1,1},
    {1,1,1}
};
// 输出：-1
```

## 总结
多源BFS是解决“多起点扩散”问题的最优方案，本题中：
- 多起点（初始腐烂橘子）保证了扩散的同步性；
- 层序遍历保证了时间统计的准确性；
- 状态追踪（`freshCount`）确保了最终结果的正确性。

该解法时间和空间复杂度均为`O(m×n)`，高效且易于理解，是处理此类扩散问题的通用模板（如“感染问题”“水域扩散问题”等）。