https://leetcode.cn/problems/partition-labels/description/?envType=study-plan-v2&envId=top-100-liked

# 划分字母区间（LeetCode 763）详细解法 - Java实现
## 题目描述
字符串 `S` 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。

**示例**：
- 输入：`S = "ababcbacabc"`
- 输出：`[9,7]`
- 解释：
    - 第一个片段是 `"ababcbaca"`（长度9），包含所有出现的 `a`、`b`、`c`（`a`最后出现于索引8，`b`最后出现于索引5，`c`最后出现于索引7）；
    - 第二个片段是 `"bc"`（原示例输出为7，实际完整输入应为 `"ababcbacabc"`，正确划分是 `[9,7]`，第二个片段包含剩余的 `b`、`c`、`a` 等，最终覆盖到索引15）。

## 核心思路
本题的核心是 **贪心算法**，核心思想是：
1. **记录每个字母的最后出现位置**：先遍历字符串，用数组/哈希表存储每个字母在字符串中最后一次出现的索引；
2. **动态扩展当前片段的边界**：遍历字符串时，维护当前片段的「起始索引」和「最远边界」：
    - 对于当前字符 `c`，其最后出现位置是 `last[c]`，当前片段的最远边界需更新为 `max(当前边界, last[c])`；
    - 当遍历到的索引 `i` 等于当前片段的最远边界时，说明当前片段已包含所有该片段中字母的所有出现（再往后的字母不会出现在当前片段），此时划分片段，记录长度，并更新起始索引为 `i+1`。

该思路的本质是「让每个片段尽可能短，同时满足同一字母不跨片段」，最终实现「划分尽可能多的片段」。

### Java代码实现（带详细注释）
```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        int[] last = new int[26];
        for(int i = 0; i < s.length(); i++) {
            last[s.charAt(i) - 'a'] = i; // 每个字母的最远下标
        }
        List<Integer> result = new ArrayList<>();
        int maxIndex = 0;
        int lastIndex = 0;
        for(int i = 0; i < s.length(); i++) {
            // 更新当前片段的最远边界：必须覆盖到字符的最后出现位置
            maxIndex = Math.max(last[s.charAt(i) - 'a'], maxIndex);
            // 当i到达当前片段的最远边界，划分片段
            if(i == maxIndex) {
                result.add(maxIndex - lastIndex + 1);
                lastIndex = i + 1;
            }
        }

        return result;
    }
}
```