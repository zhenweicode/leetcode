https://leetcode.cn/problems/next-permutation/description/?envType=study-plan-v2&envId=top-100-liked


# 下一个排列（LeetCode 31）详细解法 - Java实现
## 题目描述
实现获取 **下一个排列** 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即紧接在当前排列之后的最小排列）。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

**要求**：必须 **原地** 修改，只允许使用额外常数空间。

**示例**：
- 输入：`nums = [1,2,3]` → 输出：`[1,3,2]`（下一个更大的排列）
- 输入：`nums = [3,2,1]` → 输出：`[1,2,3]`（无更大排列，返回最小排列）
- 输入：`nums = [1,1,5]` → 输出：`[1,5,1]`
- 输入：`nums = [1,3,2]` → 输出：`[2,1,3]`

## 核心思路
下一个排列的核心是「找到最小的增量变化」，本质是通过 **“找断点→换小数→逆序尾”** 三步实现，无需暴力枚举所有排列：

### 关键观察（字典序规律）
字典序中下一个更大的排列，是在当前排列基础上，**尽量保持前面的数字不变，只修改后面尽可能短的部分**，具体规律：
1. 从后往前找「第一个非递增的断点」：即找到最小的索引 `i`，使得 `nums[i] < nums[i+1]`（说明 `i` 后面的数字是降序的，无法通过调整后面的数字得到更大排列，需修改 `i` 位置的数字）；
2. 若找不到断点（整个数组降序）：直接逆序数组，得到最小排列；
3. 找到断点后，从后往前找「第一个比 `nums[i]` 大的数字 `nums[j]`」：这是能替换 `nums[i]` 且使排列最小的数字（因为后面是降序，最右边的大数字最小）；
4. 交换 `nums[i]` 和 `nums[j]`：此时 `i` 后面的数字仍为降序（因为 `nums[j]` 是后面最小的大数字）；
5. 逆序 `i` 后面的数字：将降序改为升序，得到最小的增量排列（因为逆序后是 `i` 后面最小的排列）。

| 解法                | 时间复杂度 | 空间复杂度 | 特点                     |
|---------------------|------------|------------|--------------------------|
| 字典序三步法（推荐）| O(n)       | O(1)       | 原地修改，最优解，面试核心 |

## 解法：字典序三步法（详细实现）
### 实现步骤
1. **找断点 `i`**：从数组末尾往前遍历，找到第一个 `nums[i] < nums[i+1]` 的索引 `i`（若遍历完未找到，`i = -1`）；
2. **处理无断点情况**：若 `i == -1`（数组降序），直接逆序整个数组，返回；
3. **找交换点 `j`**：从数组末尾往前遍历，找到第一个 `nums[j] > nums[i]` 的索引 `j`；
4. **交换 `nums[i]` 和 `nums[j]`**：替换后保持前面的数字不变，确保增量最小；
5. **逆序 `i` 后面的数字**：将 `i+1` 到数组末尾的降序部分逆序为升序，得到最小的下一个排列。

### 关键逻辑
- 为什么找「第一个非递增断点」？因为断点后面的数字是降序的，无法通过调整后面的数字得到更大排列，必须修改断点位置；
- 为什么找「最后一个比 `nums[i]` 大的数字」？因为后面是降序，最右边的大数字是最小的大数字，替换后能保证排列增量最小；
- 为什么逆序后面的数字？交换后后面仍是降序，逆序后变为升序，是该部分最小的排列，确保整体是下一个最小的更大排列。

### Java代码实现（带详细注释）
```java
public class NextPermutation {
    public void nextPermutation(int[] nums) {
        if (nums == null || nums.length <= 1) {
            return; // 数组长度≤1，无下一个排列（或唯一排列）
        }

        int n = nums.length;

        // 步骤1：从后往前找第一个断点i（nums[i] < nums[i+1]）
        int i = n - 2;
        while (i >= 0 && nums[i] >= nums[i+1]) {
            i--; // 后面的数字降序，继续往前找
        }

        // 步骤2：若找到断点，找j并交换；否则逆序整个数组
        if (i != -1) {
            // 步骤2.1：从后往前找第一个比nums[i]大的数字nums[j]
            int j = n - 1;
            while (nums[j] <= nums[i]) {
                j--;
            }
            // 步骤2.2：交换nums[i]和nums[j]
            swap(nums, i, j);
        }

        // 步骤3：逆序i后面的数字（i=-1时逆序整个数组）
        reverse(nums, i + 1, n - 1);
    }

    // 辅助方法：交换数组中两个元素
    private void swap(int[] nums, int a, int b) {
        int temp = nums[a];
        nums[a] = nums[b];
        nums[b] = temp;
    }

    // 辅助方法：逆序数组从left到right的部分（闭区间）
    private void reverse(int[] nums, int left, int right) {
        while (left < right) {
            swap(nums, left, right);
            left++;
            right--;
        }
    }
}
```

### 执行流程示例
#### 示例1：`nums = [1,3,2]`（找下一个排列）
1. **找断点i**：
   - `i=1`（nums[1]=3，nums[2]=2 → 3≥2，i--）；
   - `i=0`（nums[0]=1，nums[1]=3 → 1<3，找到断点i=0）；
2. **找j并交换**：
   - 从后往前找第一个>1的数字：j=2（nums[2]=2）；
   - 交换nums[0]和nums[2] → 数组变为 `[2,3,1]`；
3. **逆序i后面的部分**（i+1=1到2）：
   - 逆序 `[3,1]` → 变为 `[1,3]`；
   - 最终数组：`[2,1,3]`（正确）。

#### 示例2：`nums = [3,2,1]`（无下一个排列）
1. **找断点i**：
   - `i=1`（3≥2→i--），`i=0`（2≥1→i--），`i=-1`（无断点）；
2. **逆序整个数组**：
   - 逆序 `[3,2,1]` → `[1,2,3]`（正确）。

#### 示例3：`nums = [1,2,3]`（基础情况）
1. **找断点i**：`i=1`（nums[1]=2 < nums[2]=3）；
2. **找j**：j=2（nums[2]=3>2），交换后数组 `[1,3,2]`；
3. **逆序i+1=2到2**：无变化，最终结果 `[1,3,2]`（正确）。

## 关键注意事项
1. **边界条件处理**：
   - 数组长度≤1：直接返回（无下一个排列）；
   - 所有元素相同（如 `[1,1,1]`）：找断点时i=-1，逆序后仍是原数组（正确，无更大排列）；
2. **指针遍历方向**：找断点和交换点时均从后往前，确保效率和正确性；
3. **交换后的逆序**：无论是否找到断点，都要逆序（无断点时逆序整个数组，得到最小排列）；
4. **原地修改要求**：仅使用常数空间（swap和reverse均为原地操作），满足题目要求；
5. **字典序正确性**：交换的是“最小的大数字”，逆序后是“最小的尾部排列”，确保整体是下一个最小的更大排列。