https://leetcode.cn/problems/implement-trie-prefix-tree/description/?envType=study-plan-v2&envId=top-100-liked


# 前缀树（Trie）详细解法 - Java实现
## 题目背景
前缀树（又称字典树）是一种高效的字符串存储与查询数据结构，核心优势是：
- 快速插入字符串（时间复杂度O(L)，L为字符串长度）；
- 快速查询字符串是否存在（O(L)）；
- 快速查询是否存在以某个前缀开头的字符串（O(L)）；
- 空间高效（共享字符串前缀，避免重复存储）。

常见应用场景：自动补全、拼写检查、前缀匹配、IP路由最长前缀匹配等。本文将实现前缀树的核心操作，并结合LeetCode 208题（实现Trie）详细讲解。

## 核心思路
### 前缀树的结构定义
前缀树的每个节点包含两个核心部分：
1. **子节点数组/哈希表**：存储当前节点的所有子节点（对应下一个字符）。由于英文字母通常为26个小写字母，优先使用大小为26的数组（效率高于哈希表），索引对应字符`c - 'a'`；
2. **结束标记**：标记当前节点是否是某个字符串的结尾（例如存储"apple"时，最后一个字符'e'的节点需标记为结束）。

### 核心操作实现逻辑
1. **插入（insert）**：
    - 从根节点出发，遍历字符串的每个字符；
    - 对每个字符，计算其在子节点数组中的索引，若子节点不存在则创建新节点；
    - 移动到子节点，重复步骤2，直到字符串遍历结束；
    - 标记最后一个节点为字符串结束。

2. **查询（search）**：
    - 从根节点出发，遍历字符串的每个字符；
    - 若当前字符对应的子节点不存在，直接返回`false`；
    - 移动到子节点，重复步骤2，直到字符串遍历结束；
    - 检查最后一个节点是否有结束标记，有则返回`true`，否则返回`false`（例如查询"app"时，若仅插入过"apple"，则返回`false`）。

3. **前缀查询（startsWith）**：
    - 逻辑与`search`类似，但无需检查结束标记；
    - 若字符串遍历完成且所有字符对应的子节点都存在，返回`true`（表示存在该前缀），否则返回`false`。

## 完整Java实现（LeetCode 208题）
### 1. 节点类定义
```java
class TrieNode {
    // 子节点数组：存储26个小写字母对应的子节点
    TrieNode[] children;
    // 结束标记：true表示当前节点是某个字符串的结尾
    boolean isEnd;

    // 构造方法：初始化子节点数组和结束标记
    public TrieNode() {
        children = new TrieNode[26]; // 索引0对应'a'，1对应'b'，...，25对应'z'
        isEnd = false;
    }
}
```

### 2. 前缀树类（核心操作）
```java
public class Trie {
    // 根节点：前缀树的入口，无实际字符含义
    private TrieNode root;

    // 构造方法：初始化根节点
    public Trie() {
        root = new TrieNode();
    }

    /**
     * 插入字符串到前缀树
     * @param word 要插入的字符串（假设仅包含小写英文字母）
     */
    public void insert(String word) {
        TrieNode curr = root; // 从根节点开始
        for (char c : word.toCharArray()) {
            int index = c - 'a'; // 计算字符对应的数组索引
            // 若子节点不存在，创建新节点
            if (curr.children[index] == null) {
                curr.children[index] = new TrieNode();
            }
            // 移动到子节点
            curr = curr.children[index];
        }
        // 字符串遍历结束，标记当前节点为结束
        curr.isEnd = true;
    }

    /**
     * 查询字符串是否在 prefixTree 中
     * @param word 要查询的字符串
     * @return 存在返回true，否则返回false
     */
    public boolean search(String word) {
        TrieNode curr = root;
        for (char c : word.toCharArray()) {
            int index = c - 'a';
            // 子节点不存在，直接返回false
            if (curr.children[index] == null) {
                return false;
            }
            curr = curr.children[index];
        }
        // 必须检查结束标记（避免前缀匹配误判）
        return curr.isEnd;
    }

    /**
     * 查询是否存在以指定前缀开头的字符串
     * @param prefix 前缀字符串
     * @return 存在返回true，否则返回false
     */
    public boolean startsWith(String prefix) {
        TrieNode curr = root;
        for (char c : prefix.toCharArray()) {
            int index = c - 'a';
            if (curr.children[index] == null) {
                return false;
            }
            curr = curr.children[index];
        }
        // 无需检查结束标记，只要前缀遍历完成即可
        return true;
    }
}
```

## 关键注意事项
1. **子节点数组的索引计算**：`c - 'a'` 仅适用于小写英文字母，若需支持大写字母、数字或特殊字符，需调整数组大小或改用`HashMap<Character, TrieNode>`（例如支持大小写字母时，数组大小改为52，或用哈希表更灵活）；
2. **结束标记的作用**：`isEnd` 是区分“完整字符串”和“前缀”的关键，例如插入"apple"后，`search("app")` 返回`false`，但`startsWith("app")` 返回`true`；
3. **根节点的特殊性**：根节点不存储任何字符，仅作为所有字符串的公共起点，其`isEnd` 始终为`false`（除非插入空字符串，需额外处理）；
4. **空字符串处理**：若需支持空字符串插入，可在初始化时将根节点的`isEnd` 设为`true`，或在`insert("")` 时直接标记根节点`isEnd = true`；
5. **空间优化**：若字符集过大（如包含Unicode），数组会浪费空间，此时改用`HashMap<Character, TrieNode>` 存储子节点，仅在需要时创建对应字符的节点，减少空间开销。

## 扩展功能实现（可选）
### 1. 删除字符串（进阶操作）
删除操作需考虑三种情况：
- 待删除字符串不存在：直接返回；
- 待删除字符串是其他字符串的前缀：仅取消末尾节点的`isEnd` 标记；
- 待删除字符串的节点有独立子路径：从末尾向上删除无其他子节点且非结束标记的节点。

实现代码：
```java
public void delete(String word) {
    deleteHelper(root, word, 0);
}

// 递归辅助删除：返回当前节点是否需要被删除（无其他子节点且非结束标记）
private boolean deleteHelper(TrieNode node, String word, int index) {
    // 递归终止条件：字符串遍历完成
    if (index == word.length()) {
        // 若当前节点不是结束标记，说明字符串不存在
        if (!node.isEnd) {
            return false;
        }
        // 取消结束标记
        node.isEnd = false;
        // 若当前节点无其他子节点，返回true表示可删除
        return hasNoChildren(node);
    }

    char c = word.charAt(index);
    int childIndex = c - 'a';
    TrieNode child = node.children[childIndex];

    // 子节点不存在，字符串不存在
    if (child == null) {
        return false;
    }

    // 递归删除子节点，判断子节点是否需要删除
    boolean needDeleteChild = deleteHelper(child, word, index + 1);

    // 若子节点需要删除，移除当前节点对其的引用
    if (needDeleteChild) {
        node.children[childIndex] = null;
        // 当前节点若无其他子节点且非结束标记，返回true表示可删除
        return hasNoChildren(node) && !node.isEnd;
    }

    // 子节点无需删除，当前节点也无需删除
    return false;
}

// 辅助方法：判断节点是否无任何子节点
private boolean hasNoChildren(TrieNode node) {
    for (TrieNode child : node.children) {
        if (child != null) {
            return false;
        }
    }
    return true;
}
```

### 2. 支持大小写字母/数字的前缀树（哈希表实现）
```java
class TrieNode {
    HashMap<Character, TrieNode> children;
    boolean isEnd;

    public TrieNode() {
        children = new HashMap<>();
        isEnd = false;
    }
}

public class Trie {
    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    public void insert(String word) {
        TrieNode curr = root;
        for (char c : word.toCharArray()) {
            // 若子节点不存在，创建新节点
            curr.children.computeIfAbsent(c, k -> new TrieNode());
            curr = curr.children.get(c);
        }
        curr.isEnd = true;
    }

    public boolean search(String word) {
        TrieNode curr = root;
        for (char c : word.toCharArray()) {
            if (!curr.children.containsKey(c)) {
                return false;
            }
            curr = curr.children.get(c);
        }
        return curr.isEnd;
    }

    public boolean startsWith(String prefix) {
        TrieNode curr = root;
        for (char c : prefix.toCharArray()) {
            if (!curr.children.containsKey(c)) {
                return false;
            }
            curr = curr.children.get(c);
        }
        return true;
    }
}
```