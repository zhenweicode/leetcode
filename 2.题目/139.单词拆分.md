# 目录
* [题目地址](#题目地址)
* [题目描述](#题目描述)
* [解题思路](#解题思路)
* [解法1-动态规划](#解法1-动态规划)



# 题目地址
难易程度：
- ![medium.jpg](../.images/medium.jpg)

是否经典：
- ⭐️

https://leetcode-cn.com/problems/word-break/

# 题目描述
```text
给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

说明：

拆分时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。

示例 1：

输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。

示例 2：

输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
     注意你可以重复使用字典中的单词。

示例 3：

输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false

```


# 解题思路
- 回溯

- 记忆化回溯

- 动态规划




# 解法1-回溯
## 关键点
最简单的实现方法是用递归和回溯。为了找到解，我们可以检查字典单词中每一个单词的可能前缀，如果在字典中出现过，那么去掉这个前缀后剩余部分回归调用。同时，如果某次函数调用中发现整个字符串都已经被拆分且在字典中出现过了，函数就返回 true 。

## 代码
```java
public class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        return word_Break(s, new HashSet(wordDict), 0);
    }
    public boolean word_Break(String s, Set<String> wordDict, int start) {
        if (start == s.length()) {
            return true;
        }
        for (int end = start + 1; end <= s.length(); end++) {
            if (wordDict.contains(s.substring(start, end)) && word_Break(s, wordDict, end)) {
                return true;
            }
        }
        return false;
    }
}
```


## 复杂度
- 时间复杂度：$O(n^n)$ 。考虑最坏情况，单词为aaaab而字典中是a,aa,aaa,aaaa
- 空间复杂度：O(n) 。回溯树的深度最深达到 n 。


# 解法2-记忆化回溯
## 关键点
考虑最坏情况，单词为aaaab而字典中是a,aa,aaa,aaaa。

回溯aaaab的时候要计算aaab，aab，ab

回溯aaab的时候要计算aab，ab

有重复计算


## 代码
```java
public class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        return word_Break(s, new HashSet<>(wordDict), 0, new Boolean[s.length()]);
    }

    private boolean word_Break(String s, Set<String> wordDict, int start, Boolean[] memo) {
        if (start == s.length()) {
            return true;
        }
        if (memo[start] != null) {
            return memo[start];
        }
        for (int end = start + 1; end <= s.length(); end++) {
            if (wordDict.contains(s.substring(start, end)) && word_Break(s, wordDict, end, memo)) {
                memo[start] = true;
                return true;
            }
        }
        return memo[start] = false;
    }
}
```


## 复杂度
- 时间复杂度：$O(n^2)$ 。回溯树的大小最多达到 $n^2$。
- 空间复杂度：O(n) 。回溯树的深度最深达到 n 。


# 解法3-动态规划
## 关键点
1. 初始化dp=[False,⋯,False]，长度为n+1。n为字符串长度。dp[i]表示s的前i位是否可以用wordDict中的单词表示。
2. 初始化dp[0]=True，空字符可以被表示。
3. 遍历字符串的所有子串，遍历开始索引i，遍历区间[0,n)：
- 遍历结束索引j，遍历区间[i+1,n+1)：
    - 若dp[i]=True且s[i,⋯,j)在wordlist中：dp[j]=True。解释：dp[i]=True说明s的前i位可以用wordDict表示，则s[i,⋯,j)出现在wordDict中，说明s的前j位可以表示。
4. 返回dp[n]

## 代码
```java
public class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> wordDictSet = new HashSet<>(wordDict);
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
}
```


## 复杂度
- 时间复杂度：$O(n^2)$。
- 空间复杂度：O(n)。
