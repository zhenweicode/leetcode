
https://leetcode.cn/problems/course-schedule/description/?envType=study-plan-v2&envId=top-100-liked

# 课程表（LeetCode 207）详细解法 - Java实现
## 题目描述
你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1`。
在选修某些课程之前需要先学习其他课程，例如，想要学习课程 `0`，你需要先学习课程 `1`，我们用一个匹配来表示：`[0, 1]`（即“先修1，再修0”）。
给定课程总数和一个先修课程的列表 `prerequisites`，判断是否可能完成所有课程的学习。如果可以，返回 `true`；否则，返回 `false`。

## 核心思路
本题本质是 **判断有向图是否存在环**（环检测问题）：
- 每门课程是有向图的一个节点；
- 先修关系 `[a, b]` 对应有向边 `b → a`（表示“b是a的前置条件”）；
- 若图中存在环（例如：a→b，b→c，c→a），则无法完成所有课程（循环依赖）；
- 若图中无环（是一个有向无环图DAG），则可以完成所有课程。

常用解法有两种：
1. **深度优先搜索（DFS）**：通过递归遍历每个节点，追踪“当前路径”（递归栈），若发现节点被再次访问且在当前路径中，则存在环；
2. **广度优先搜索（BFS，优先，因为可以解决后续输出课程顺序的问题）**：基于“拓扑排序”，通过统计每个节点的入度，逐步删除入度为0的节点（无前置依赖的课程），最终若删除的节点数等于总课程数，则无环。

两种方法时间复杂度均为 **O(n + m)**（n为课程数，m为先修关系数），空间复杂度为 **O(n + m)**（存储图结构和辅助数据结构）。


## 解法1：广度优先搜索（BFS）- 拓扑排序
### 实现原理
1. **图的表示**：邻接表存储有向图（同DFS）；
2. **入度统计**：用数组 `inDegree` 存储每个节点的入度（即前置课程的数量）；
3. **初始化队列**：将所有入度为 `0` 的节点（无前置依赖的课程）加入队列（拓扑排序的起点）；
4. **BFS遍历**：
   - 取出队首节点 `u`，统计已访问的节点数 `count`；
   - 遍历 `u` 的所有邻接节点 `v`（即依赖 `u` 的课程）：
      - 将 `v` 的入度减 `1`（因为 `u` 已完成）；
      - 若 `v` 的入度变为 `0`（所有前置依赖已完成），加入队列；
5. **结果判断**：若 `count == numCourses`（所有课程都能通过拓扑排序完成），则无环，返回 `true`；否则存在环，返回 `false`。

### Java代码实现
```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class CourseSchedule {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        // 邻接表：存储有向图
        List<List<Integer>> adj = new ArrayList<>();
        // 入度数组：inDegree[u] 表示课程u的前置课程数量
        int[] inDegree = new int[numCourses];

        // 初始化邻接表
        for (int i = 0; i < numCourses; i++) {
            adj.add(new ArrayList<>());
        }

        // 构建图和入度数组
        for (int[] p : prerequisites) {
            int a = p[0]; // 目标课程
            int b = p[1]; // 前置课程
            adj.get(b).add(a); // b → a
            inDegree[a]++; // a的入度+1（多一个前置条件）
        }

        // 队列：存储入度为0的节点（无前置依赖的课程）
        Queue<Integer> queue = new LinkedList<>();
        int count = 0; // 已完成的课程数

        // 初始化队列：将所有入度为0的节点加入
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                queue.offer(i);
                count++;
            }
        }

        // BFS遍历
        while (!queue.isEmpty()) {
            int u = queue.poll();
            // 遍历u的所有邻接节点v（依赖u的课程）
            for (int v : adj.get(u)) {
                inDegree[v]--; // 前置课程u已完成，v的入度-1
                if (inDegree[v] == 0) {
                    // v的所有前置依赖已完成，加入队列
                    queue.offer(v);
                    count++;
                }
            }
        }

        // 所有课程都能完成（无环）则count等于课程数
        return count == numCourses;
    }
}
```


## 解法2：深度优先搜索（DFS）- 环检测
### 实现原理
1. **图的表示**：用邻接表（`List<List<Integer>> adj`）存储有向图，`adj[u]` 表示所有以 `u` 为前置条件的课程（即 `u → v` 的所有 `v`）；
2. **状态标记**：用数组 `visited` 标记每个节点的状态：
   - `0`：未访问过；
   - `1`：正在访问中（在当前递归栈中）；
   - `2`：已访问完成（无环路径）；
3. **DFS遍历**：
   - 对每个未访问的节点启动DFS；
   - 递归时，先标记节点为 `1`（正在访问）；
   - 遍历该节点的所有邻接节点：
      - 若邻接节点状态为 `1`：存在环，返回 `false`；
      - 若邻接节点状态为 `0`：递归遍历，若递归返回 `false`，则整体返回 `false`；
   - 递归结束后，标记节点为 `2`（访问完成），返回 `true`；
4. **结果判断**：所有节点遍历完成后无环，返回 `true`。

### Java代码实现
```java
import java.util.ArrayList;
import java.util.List;

public class CourseSchedule {
    // 邻接表：存储有向图
    private List<List<Integer>> adj;
    // 节点状态：0=未访问，1=正在访问（递归栈中），2=已访问完成
    private int[] visited;
    // 是否存在环
    private boolean hasCycle;

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        // 初始化邻接表
        adj = new ArrayList<>();
        for (int i = 0; i < numCourses; i++) {
            adj.add(new ArrayList<>());
        }
        // 构建有向图：prerequisites[i] = [a, b] → b → a
        for (int[] p : prerequisites) {
            int a = p[0];
            int b = p[1];
            adj.get(b).add(a); // b的邻接表添加a，表示先修b再修a
        }

        visited = new int[numCourses];
        hasCycle = false;

        // 遍历所有未访问的节点
        for (int i = 0; i < numCourses; i++) {
            if (visited[i] == 0) {
                dfs(i);
                if (hasCycle) {
                    return false;
                }
            }
        }

        return !hasCycle;
    }

    private void dfs(int u) {
        // 标记为正在访问（递归栈中）
        visited[u] = 1;
        // 遍历u的所有邻接节点v
        for (int v : adj.get(u)) {
            if (visited[v] == 0) {
                // 未访问，递归遍历
                dfs(v);
                if (hasCycle) {
                    return; // 发现环，提前返回
                }
            } else if (visited[v] == 1) {
                // 正在访问中（在当前递归栈），存在环
                hasCycle = true;
                return;
            }
            // visited[v] == 2：已访问完成，无环，跳过
        }
        // 所有邻接节点遍历完成，标记为已访问
        visited[u] = 2;
    }
}
```

## 关键注意事项
1. **图的构建**：先修关系 `[a, b]` 对应边 `b → a`，而非 `a → b`，避免逻辑倒置（核心易错点）；
2. **状态标记（DFS）**：必须区分“正在访问”和“已访问完成”，否则会误判环（例如：节点A→B，B→C，A→C，遍历A时C被标记为已访问，而非环）；
3. **入度统计（BFS）**：入度数组的初始化和更新必须准确，否则会导致部分节点无法入队；
4. **边界条件**：
   - 无先修课程（`prerequisites` 为空）：直接返回 `true`；
   - 课程数为0：返回 `true`（按题目约定，无课程需修）；
   - 存在孤立节点（无前置也无后续课程）：不影响结果，孤立节点入度为0，会被计入 `count`。

## 测试用例
### 测试用例1：无环（可完成）
```java
int numCourses = 2;
int[][] prerequisites = {{1, 0}}; // 先修0，再修1
// 输出：true
```

### 测试用例2：有环（不可完成）
```java
int numCourses = 2;
int[][] prerequisites = {{1, 0}, {0, 1}}; // 0→1，1→0，循环依赖
// 输出：false
```

### 测试用例3：多依赖无环
```java
int numCourses = 4;
int[][] prerequisites = {{1, 0}, {2, 0}, {3, 1}, {3, 2}}; // 0→1→3，0→2→3
// 输出：true
```

### 测试用例4：孤立节点
```java
int numCourses = 3;
int[][] prerequisites = {{1, 0}}; // 课程2无依赖，孤立节点
// 输出：true
```

## 总结
| 解法       | 时间复杂度 | 空间复杂度 | 特点                     |
|------------|------------|------------|--------------------------|
| DFS（环检测） | O(n + m)   | O(n + m)   | 递归实现，代码简洁，需注意栈溢出（课程数极大时） |
| BFS（拓扑排序） | O(n + m)  | O(n + m)   | 迭代实现，无栈溢出风险，可直接扩展到“课程表II”（求拓扑排序） |

实际开发中：
- 若仅需判断是否可完成（环检测），两种方法均可；
- 若需输出课程学习顺序（后续扩展需求），优先选择BFS（拓扑排序天然输出顺序）；
- 课程数极大时（如n>1e4），优先BFS（避免DFS递归栈溢出，可通过迭代DFS优化，但代码复杂度增加）。


# 解法1-广度优先遍历
## 关键点
本题可约化为： 课程安排图是否是 有向无环图(DAG)。即课程间规定了前置条件，但不能构成任何环路，否则课程前置条件将不成立。

通过课程前置条件列表 prerequisites 可以得到课程安排图的 邻接表 adjacency，以降低算法时间复杂度

算法流程：
1. 统计课程安排图中每个节点的入度，生成入度表 indegrees。
2. 借助一个队列 queue，将所有入度为 0 的节点入队。
3. 当 queue 非空时，依次将队首节点出队，在课程安排图中删除此节点 pre：
    - 并不是真正从邻接表中删除此节点 pre，而是将此节点对应所有邻接节点 cur 的入度 −1，即 indegrees[cur] -= 1。
    - 当入度 −1后邻接节点 cur 的入度为 0，说明 cur 所有的前驱节点已经被 “删除”，此时将 cur 入队。
4. 在每次 pre 出队时，执行 numCourses--；
    - 若整个课程安排图是有向无环图（即可以安排），则所有节点一定都入队并出队过，即完成拓扑排序。换个角度说，若课程安排图中存在环，一定有节点的入度始终不为 0。
    - 因此，拓扑排序出队次数等于课程个数，返回 numCourses == 0 判断课程是否可以成功安排。

## 代码
```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        int[] indegrees = new int[numCourses]; // 课程入度表
        List<List<Integer>> adjacency = new ArrayList<>();  // 课程安排图的邻接表
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; i++)
            adjacency.add(new ArrayList<>());

        for (int[] p : prerequisites) { // 获取每门课的入度和邻接表，其中cp[1]是cp[0]的前置
            indegrees[p[0]]++;
            adjacency.get(p[1]).add(p[0]);
        }

        for (int i = 0; i < numCourses; i++)  // 获取所有入度为零的课程
            if (indegrees[i] == 0) queue.add(i);

        while (!queue.isEmpty()) {  // 广度优先遍历，BFS
            int pre = queue.poll();
            numCourses--;
            for (int cur : adjacency.get(pre)) {
                if (--indegrees[cur] == 0) queue.add(cur);
            }
        }

        return numCourses == 0;
    }
}
```

# 拓展题目
## 210. 课程表 II
```text
现在你总共有 n 门课需要选，记为 0 到 n-1。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]

给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。

可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。

示例 1:

输入: 2, [[1,0]] 
输出: [0,1]
解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
示例 2:

输入: 4, [[1,0],[2,0],[3,1],[3,2]]
输出: [0,1,2,3] or [0,2,1,3]
解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
```

```java
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
      // 1. 初始化图（邻接表）和入度数组
      List<List<Integer>> adj = new ArrayList<>();
      int[] inDegree = new int[numCourses];
      for (int i = 0; i < numCourses; i++) {
         adj.add(new ArrayList<>());
      }

      // 2. 构建图和入度数组
      for (int[] p : prerequisites) {
         int a = p[0]; // 目标课程（需先修b才能学a）
         int b = p[1]; // 前置课程
         adj.get(b).add(a); // 边：b → a（b的邻接表添加a）
         inDegree[a]++; // a的入度+1（多一个前置条件）
      }

      // 3. 初始化队列：入度为0的课程入队
      Queue<Integer> queue = new LinkedList<>();
      for (int i = 0; i < numCourses; i++) {
         if (inDegree[i] == 0) {
            queue.offer(i);
         }
      }

      // 4. BFS遍历，生成拓扑排序结果
      List<Integer> topoOrder = new ArrayList<>();
      while (!queue.isEmpty()) {
         int u = queue.poll();
         topoOrder.add(u); // 加入拓扑排序结果

         // 遍历u的所有依赖课程v，更新入度
         for (int v : adj.get(u)) {
            inDegree[v]--;
            if (inDegree[v] == 0) { // 所有前置依赖完成，入队
               queue.offer(v);
            }
         }
      }

      // 5. 判断是否存在环：结果长度等于课程数则无环，否则有环
      if (topoOrder.size() != numCourses) {
         return new int[0];
      }

      // 6. 转换为数组返回
      int[] result = new int[numCourses];
      for (int i = 0; i < numCourses; i++) {
         result[i] = topoOrder.get(i);
      }
      return result;
   }

}
```

## 复杂度
- 时间复杂度：O(N+M)： 遍历一个图需要访问所有节点和所有临边，N 和 M 分别为节点数量和临边数量；
- 空间复杂度：O(N+M)： 为建立邻接表所需额外空间，adjacency 长度为 N ，并存储 M 条临边的数据。