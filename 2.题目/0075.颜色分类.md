# 题目地址
难易程度：
- ![medium.jpg](../.images/medium.jpg)

是否经典：
- ⭐️

https://leetcode-cn.com/problems/sort-colors/

# 题目描述
```text
给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

注意:
不能使用代码库中的排序函数来解决这道题。

示例:

输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
进阶：

一个直观的解决方案是使用计数排序的两趟扫描算法。
首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
你能想出一个仅使用常数空间的一趟扫描算法吗？
```


# 解题思路
- 三指针


# 解法1-三指针
## 关键点
用三个指针划分三个区间，遍历数组时实时调整指针位置：
- `left`：指向「0区间的右边界」（`left` 左侧全是0）；
- `mid`：遍历指针，用于扫描数组（`mid` 左侧是已处理的0和1）；
- `right`：指向「2区间的左边界」（`right` 右侧全是2）。

### 执行规则
1. 初始化 `left=0`，`mid=0`，`right=nums.length-1`；
2. 当 `mid <= right` 时（`mid` 未扫描到2区间）：
    - 若 `nums[mid] == 0`：交换 `nums[left]` 和 `nums[mid]`，`left++`（0区间扩大），`mid++`（已处理，继续扫描）；
    - 若 `nums[mid] == 1`：无需交换，`mid++`（1区间自然扩大）；
    - 若 `nums[mid] == 2`：交换 `nums[mid]` 和 `nums[right]`，`right--`（2区间扩大），**mid不递增**（交换后的元素未处理，需重新判断）。

### 关键逻辑
- 交换0时，`mid` 可递增：因为 `left` 初始在0位置，且只有处理过的0/1才会让 `left` 移动，交换过来的元素必然是0或1（已处理）；
- 交换2时，`mid` 不可递增：交换过来的元素可能是0或1（未处理），需重新判断其归属。

## 代码
```java
public class SortColors {
    public void sortColors(int[] nums) {
        int n = nums.length;
        int left = 0;   // 0区间的右边界（左侧全是0）
        int mid = 0;    // 遍历指针
        int right = n - 1; // 2区间的左边界（右侧全是2）

        while (mid <= right) {
            if (nums[mid] == 0) {
                // 交换到0区间，left和mid都右移
                swap(nums, left, mid);
                left++;
                mid++;
            } else if (nums[mid] == 1) {
                // 1区间直接扩大，mid右移
                mid++;
            } else { // nums[mid] == 2
                // 交换到2区间，right左移，mid不移动（交换后的元素需重新判断）
                swap(nums, mid, right);
                right--;
            }
        }
    }

    // 辅助方法：交换数组中两个元素
    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

## 复杂度
- 时间复杂度：O(N)
- 空间复杂度：O(1)


# 解法2-双指针两次遍历（直观易懂）
### 核心思想
分两步处理，每次只关注一种颜色，用双指针将目标颜色交换到前端：
1. 第一次遍历：将所有0交换到数组左侧（用 `p0` 指针记录0的右边界）；
2. 第二次遍历：将所有1交换到0的右侧（用 `p1` 指针记录1的右边界）；
3. 剩余元素自然是2，无需额外处理。

### 实现步骤
1. 第一次遍历（处理0）：
    - 初始化 `p0=0`；
    - 遍历数组，若 `nums[i] == 0`，交换 `nums[p0]` 和 `nums[i]`，`p0++`；
2. 第二次遍历（处理1）：
    - 初始化 `p1=p0`（从0的右边界开始）；
    - 遍历数组（从 `p0` 开始，前面全是0），若 `nums[i] == 1`，交换 `nums[p1]` 和 `nums[i]`，`p1++`。

### Java代码实现
```java
public class SortColors {
    public void sortColors(int[] nums) {
        if (nums == null || nums.length <= 1) {
            return;
        }

        int n = nums.length;
        int p0 = 0;

        // 第一步：将所有0移到数组左侧
        for (int i = 0; i < n; i++) {
            if (nums[i] == 0) {
                swap(nums, i, p0);
                p0++;
            }
        }

        // 第二步：将所有1移到0的右侧
        int p1 = p0;
        for (int i = p0; i < n; i++) {
            if (nums[i] == 1) {
                swap(nums, i, p1);
                p1++;
            }
        }

        // 剩余元素都是2，无需处理
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```


# 解法3-先统计三种颜色的出现次数，再根据次数原地修改数组：
1. 第一趟遍历：统计0、1、2的出现次数（`count0`、`count1`、`count2`）；
2. 第二趟遍历：
    - 前 `count0` 个位置填0；
    - 中间 `count1` 个位置填1；
    - 最后 `count2` 个位置填2。

### 优点
逻辑最简单，无需交换操作，适合入门理解排序本质；
### 缺点
需要两次遍历，且修改数组时覆盖原有元素（但题目允许原地修改）。

### Java代码实现
```java
public class SortColors {
    public void sortColors(int[] nums) {
        if (nums == null || nums.length <= 1) {
            return;
        }

        // 第一步：统计0、1、2的出现次数
        int count0 = 0, count1 = 0, count2 = 0;
        for (int num : nums) {
            if (num == 0) {
                count0++;
            } else if (num == 1) {
                count1++;
            } else {
                count2++;
            }
        }

        // 第二步：原地填充数组
        int index = 0;
        // 填充0
        for (int i = 0; i < count0; i++) {
            nums[index++] = 0;
        }
        // 填充1
        for (int i = 0; i < count1; i++) {
            nums[index++] = 1;
        }
        // 填充2
        for (int i = 0; i < count2; i++) {
            nums[index++] = 2;
        }
    }
}
```
