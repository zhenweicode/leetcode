
# 目录
* [括号字符串的有效性](#括号字符串的有效性)
* [最长有效括号](#最长有效括号)
    * [题解1:动态规划](##解法1:动态规划)

***

# 括号字符串的有效性
给定一个字符串str，判断是不是整体有效的括号字符串。

【举例】
1. str="（）"，返回true；str="（（）（））"，返回true；str="（（））"，返回true。 
2. str="（））"。返回false；str="（）（"，返回false；str="（）a（）"，返回false。

【解答】
1. 从左到右遍历字符串str，判断每一个字符是不是'（'或'）'，如果不是，就直接返回false。
2. 遍历到每一个字符时，都检查到目前为止'（'和'）'的数量，如果'）'更多， 则直接返回false。
3. 遍历后检查'（'和'）'的数量，如果一样多，则返回true，否则返回false。

【代码】
```Java
public class ParenthesesProblem {
    public static boolean isValid(String str) {
        if (str == null || str.equals("")) {
            return false;
        }
        char[] chars = str.toCharArray();
        int status = 0;
        for (int i = 0; i < chars.length; i++) {
            if (chars[i] != ')' && chars[i] != '(') {
                return false;
            }
            if (chars[i] == ')' && --status < 0) {
                return false;
            }
            if (chars[i] == '(') {
                status++;
            }
        }
        return status == 0;
    }
}
```

***

# 最长有效括号
给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度

示例 1:

```
输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
```

示例 2:

```
输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
```

## 题解1:动态规划
【解答】
用动态规划求解，可以做到时间复杂度为O(N)，额外空间复杂度为O(N)。首先生成长度和str字符串一样的数组dp[]，dp[i]值的含义为str[0..i] 中必须以字符str[i]结尾的最长的有效括号子串长度。那么dp[i]值可以按如下方式求解：
1. dp[0]=0。只含有一个字符肯定不是有效括号字符串，长度自然是0。
2. 从左到右依次遍历str[1..N-1]的每个字符，假设遍历到str[i]。
3. 如果str[i]=='（'，有效括号字符串必然是以'）'结尾，而不是以'（'结尾， 所以dp[i]=0。
4. 如果str[i]=='）'，那么以str[i]结尾的最长有效括号子串可能存在。dp[i-1]的值代表必须以str[i-1]结尾的最长有效括号子串的长度，所以如果i-dp[i-1]-1位置上的字符是'（'，就能与当前位置的str[i]字符再配出一对有效括号。比如"（（）（））"，假设遍历到最后一个字符'）'，必须以倒数第二个字符结尾的最长有效括号子串是"（）（）"，找到这个子串之前的字符，即i-dp[i-1]-1位置的字符，发现是'（'，所以它可以和最后一个字符再配出一对有效括号。如果该情况发生，dp[i]的值起码是dp[i-1]+2，但还有一部分长度容易被人忽略。比如，"（）（（））"，假设遍历到最后一个字符'）'，通过上面的过程找到的必须以最后字符结尾的最长有效括号子串起码是"（（））"，但是前面还有一 段"（）"，可以和"（（））"结合在一起构成更大的有效括号子串。也就是说， str[i-dp[i-1]-1]和str[i]配成了一对，这时还应该把dp[i-dp[i-1]-2]的值加到dp[i]中，这么做表示把str[i-dp[i-1]-2]结尾的最长有效括号子串接到前面，才能得到以当前字符结尾的最长有效括号子串。
5. dp[0..N-1]中的最大值就是最终的结果。

【代码】
```Java
public class ParenthesesProblem {
    public static int maxLength(String str) {
        if (str == null || str.equals("")) {
            return 0;
        }
        char[] chars = str.toCharArray();
        int[] dp = new int[chars.length];
        int pre = 0;
        int res = 0;
        for (int i = 1; i < chars.length; i++) {
            if (chars[i] == ')') {
                pre = i - dp[i - 1] - 1;
                if (pre >= 0 && chars[pre] == '(') {
                    dp[i] = dp[i - 1] + 2 + (pre > 0 ? dp[pre - 1] : 0);
                }
            }
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

## 题解1:


# 参考
- [leetcode-最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)
- 程序员代码面试指南：P273